
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>adapters: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/deuna_card_adapter.go (95.2%)</option>
				
				<option value="file1">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/resources/dto/response/card.go (100.0%)</option>
				
				<option value="file2">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/usecases/card.go (97.7%)</option>
				
				<option value="file3">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/usecases/delete_card.go (95.5%)</option>
				
				<option value="file4">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/usecases/queries/get_card_by_user.go (100.0%)</option>
				
				<option value="file5">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/usecases/queries/get_cards.go (100.0%)</option>
				
				<option value="file6">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/collection_account/queries/get_collection_account_by_route.go (90.0%)</option>
				
				<option value="file7">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/collection_account/use_cases/create_collection_account.go (100.0%)</option>
				
				<option value="file8">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/collection_account_route/use_cases/create_collection_account_route.go (100.0%)</option>
				
				<option value="file9">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/collection_account_route/use_cases/disable_collection_account_route.go (100.0%)</option>
				
				<option value="file10">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/collection_center/use_cases/collection_center.go (100.0%)</option>
				
				<option value="file11">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/common/adapters/mail_adapter.go (100.0%)</option>
				
				<option value="file12">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/common/context_enterprise_id.go (0.0%)</option>
				
				<option value="file13">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/notification/services/notification_service.go (97.2%)</option>
				
				<option value="file14">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/deuna_order_adapter.go (89.5%)</option>
				
				<option value="file15">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/resources/dto/request/order.go (100.0%)</option>
				
				<option value="file16">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/services/order_notification_orchestrator.go (97.6%)</option>
				
				<option value="file17">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/services/order_payment_failed_notification_service.go (100.0%)</option>
				
				<option value="file18">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/services/order_payment_processed_notification_service.go (100.0%)</option>
				
				<option value="file19">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/use_cases/create/create_order_usecase.go (86.7%)</option>
				
				<option value="file20">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/use_cases/queries/get_order_status_query.go (100.0%)</option>
				
				<option value="file21">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/activities/capture_payment_activity.go (100.0%)</option>
				
				<option value="file22">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/activities/check_order_existence.go (100.0%)</option>
				
				<option value="file23">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/activities/create_payment_order_activity.go (100.0%)</option>
				
				<option value="file24">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/activities/generate_payment_receipt_activity.go (100.0%)</option>
				
				<option value="file25">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/activities/notify_order_change_activity.go (100.0%)</option>
				
				<option value="file26">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/activities/post_processing_payment_order_activity.go (100.0%)</option>
				
				<option value="file27">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/activities/release_payment_activity.go (100.0%)</option>
				
				<option value="file28">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/capture_flow_payment_workflow.go (96.4%)</option>
				
				<option value="file29">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/payment_order_payment_workflow.go (93.3%)</option>
				
				<option value="file30">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/payment_order_workflow_out.go (100.0%)</option>
				
				<option value="file31">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/payment_process_workflow_input.go (0.0%)</option>
				
				<option value="file32">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/post_processing_payment_workflow.go (91.2%)</option>
				
				<option value="file33">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/process_order_workflow.go (100.0%)</option>
				
				<option value="file34">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_concept/use_cases/create_payment_concept.go (100.0%)</option>
				
				<option value="file35">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_method/use_cases/payment_method.go (100.0%)</option>
				
				<option value="file36">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/payment_capture_flow_adapter.go (81.0%)</option>
				
				<option value="file37">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/payment_order_adapter.go (87.5%)</option>
				
				<option value="file38">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils/deuna_amount.go (100.0%)</option>
				
				<option value="file39">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils/deuna_order_id.go (100.0%)</option>
				
				<option value="file40">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/use_cases/capture_flow/payment_capture.go (80.0%)</option>
				
				<option value="file41">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/use_cases/capture_flow/payment_release.go (82.4%)</option>
				
				<option value="file42">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/use_cases/create/create_payment_order.go (96.4%)</option>
				
				<option value="file43">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/use_cases/post_payment/post_processing_payment_order_use_case.go (96.6%)</option>
				
				<option value="file44">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_receipt/adapters/pdf_generator/generate_payment_receipt.go (85.7%)</option>
				
				<option value="file45">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_receipt/adapters/pdf_generator/pdf_util.go (91.3%)</option>
				
				<option value="file46">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_receipt/interfaces/pdf_generator.go (100.0%)</option>
				
				<option value="file47">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_receipt/use_case/generate_receipt_payment_impl.go (100.0%)</option>
				
				<option value="file48">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/adapters/models/refund_adapter_model.go (100.0%)</option>
				
				<option value="file49">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/adapters/partial_refund_adapter.go (100.0%)</option>
				
				<option value="file50">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/adapters/refund_adapter.go (93.3%)</option>
				
				<option value="file51">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/use_cases/partial_refund.go (90.0%)</option>
				
				<option value="file52">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/use_cases/refund_total.go (93.1%)</option>
				
				<option value="file53">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/deuna/create_user.go (96.1%)</option>
				
				<option value="file54">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/login_adapter.go (33.3%)</option>
				
				<option value="file55">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources/dto/request/create_user_deuna.go (100.0%)</option>
				
				<option value="file56">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/utils/mappers_member.go (0.0%)</option>
				
				<option value="file57">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/utils/mappers_user.go (88.9%)</option>
				
				<option value="file58">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/utils/country.go (88.2%)</option>
				
				<option value="file59">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/utils/currency.go (100.0%)</option>
				
				<option value="file60">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/enums/status_type.go (100.0%)</option>
				
				<option value="file61">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/errors/card_creation.go (0.0%)</option>
				
				<option value="file62">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/errors/card_creation_db.go (100.0%)</option>
				
				<option value="file63">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/errors/card_deletion.go (100.0%)</option>
				
				<option value="file64">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/errors/card_deletion_db.go (100.0%)</option>
				
				<option value="file65">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/errors/card_error_get_db.go (100.0%)</option>
				
				<option value="file66">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/errors/card_is_duplicate.go (0.0%)</option>
				
				<option value="file67">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/errors/card_is_not_from_member.go (100.0%)</option>
				
				<option value="file68">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/errors/card_not_found.go (100.0%)</option>
				
				<option value="file69">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/collection_center/errors/collection_account.go (100.0%)</option>
				
				<option value="file70">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities/collection_account_route.go (100.0%)</option>
				
				<option value="file71">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities/collection_center.go (100.0%)</option>
				
				<option value="file72">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities/collection_center_payment_method.go (0.0%)</option>
				
				<option value="file73">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities/payment_concept.go (33.3%)</option>
				
				<option value="file74">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities/payment_method.go (50.0%)</option>
				
				<option value="file75">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities/payment_order.go (52.2%)</option>
				
				<option value="file76">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities/payment_receipt.go (100.0%)</option>
				
				<option value="file77">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities/user.go (71.4%)</option>
				
				<option value="file78">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums/account_type.go (100.0%)</option>
				
				<option value="file79">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums/associated_origin.go (100.0%)</option>
				
				<option value="file80">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums/payment_flow.go (100.0%)</option>
				
				<option value="file81">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums/payment_flow_actions.go (100.0%)</option>
				
				<option value="file82">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums/payment_method_enum.go (100.0%)</option>
				
				<option value="file83">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums/payment_status.go (96.2%)</option>
				
				<option value="file84">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums/status_route.go (100.0%)</option>
				
				<option value="file85">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/collection_account_not_found.go (100.0%)</option>
				
				<option value="file86">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/invalid_amount_error.go (100.0%)</option>
				
				<option value="file87">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/invalid_country_code_error.go (100.0%)</option>
				
				<option value="file88">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/invalid_currency_code_error.go (100.0%)</option>
				
				<option value="file89">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/invalid_user_id_error.go (100.0%)</option>
				
				<option value="file90">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/order_already_exist.go (100.0%)</option>
				
				<option value="file91">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/order_create_validation_error.go (100.0%)</option>
				
				<option value="file92">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/order_not_found.go (100.0%)</option>
				
				<option value="file93">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/order_payment_not_found_error.go (100.0%)</option>
				
				<option value="file94">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/payment_order_code_error.go (0.0%)</option>
				
				<option value="file95">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/payment_receipt_already_exist.go (100.0%)</option>
				
				<option value="file96">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/refund_can_not_applied_error.go (100.0%)</option>
				
				<option value="file97">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/refund_create_validation_error.go (100.0%)</option>
				
				<option value="file98">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors/unsupported_user_type_error.go (0.0%)</option>
				
				<option value="file99">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate/create_command_handler.go (100.0%)</option>
				
				<option value="file100">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate/order.go (93.1%)</option>
				
				<option value="file101">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate/when_order_authorized.go (100.0%)</option>
				
				<option value="file102">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate/when_order_created.go (93.8%)</option>
				
				<option value="file103">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate/when_order_payment_processing_started.go (100.0%)</option>
				
				<option value="file104">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate/when_order_processed.go (100.0%)</option>
				
				<option value="file105">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate/when_order_processed_fail.go (100.0%)</option>
				
				<option value="file106">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate/when_payment_captured.go (100.0%)</option>
				
				<option value="file107">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate/when_payment_partial_refunded.go (77.8%)</option>
				
				<option value="file108">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate/when_payment_refunded.go (85.7%)</option>
				
				<option value="file109">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate/when_payment_released.go (100.0%)</option>
				
				<option value="file110">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command/create_order_command.go (97.7%)</option>
				
				<option value="file111">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command/create_partial_payment_refund.go (100.0%)</option>
				
				<option value="file112">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command/create_payment_captured.go (100.0%)</option>
				
				<option value="file113">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command/create_payment_order_authorized.go (100.0%)</option>
				
				<option value="file114">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command/create_payment_order_command.go (90.0%)</option>
				
				<option value="file115">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command/create_payment_order_fail_command.go (100.0%)</option>
				
				<option value="file116">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command/create_payment_order_processed_command.go (100.0%)</option>
				
				<option value="file117">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command/create_payment_refunded.go (100.0%)</option>
				
				<option value="file118">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command/create_payment_released.go (100.0%)</option>
				
				<option value="file119">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events/order_created.go (100.0%)</option>
				
				<option value="file120">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events/order_payment_authorized.go (100.0%)</option>
				
				<option value="file121">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events/order_payment_captured.go (100.0%)</option>
				
				<option value="file122">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events/order_payment_failed.go (100.0%)</option>
				
				<option value="file123">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events/order_payment_partial_refunded.go (100.0%)</option>
				
				<option value="file124">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events/order_payment_processed.go (100.0%)</option>
				
				<option value="file125">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events/order_payment_processing_started.go (100.0%)</option>
				
				<option value="file126">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events/order_payment_refunded.go (100.0%)</option>
				
				<option value="file127">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events/order_payment_released.go (100.0%)</option>
				
				<option value="file128">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/integration_events/base_payment_order_integration_event.go (100.0%)</option>
				
				<option value="file129">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/integration_events/order_payment_failed_integration_event.go (100.0%)</option>
				
				<option value="file130">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/integration_events/order_payment_processed_integration_event.go (100.0%)</option>
				
				<option value="file131">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/user/errors/user_already_exists.go (100.0%)</option>
				
				<option value="file132">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/user/errors/user_billing_information_not_found.go (0.0%)</option>
				
				<option value="file133">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/user/errors/user_create.go (100.0%)</option>
				
				<option value="file134">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/user/errors/user_email_not_found.go (100.0%)</option>
				
				<option value="file135">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/user/errors/user_error_deuna.go (100.0%)</option>
				
				<option value="file136">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/user/errors/user_error_getting.go (100.0%)</option>
				
				<option value="file137">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/user/errors/user_login.go (100.0%)</option>
				
				<option value="file138">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/user/errors/user_not_found.go (100.0%)</option>
				
				<option value="file139">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/user/errors/user_phone_not_found.go (100.0%)</option>
				
				<option value="file140">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/address.go (100.0%)</option>
				
				<option value="file141">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/associated_origin.go (100.0%)</option>
				
				<option value="file142">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/card_info.go (100.0%)</option>
				
				<option value="file143">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/cc_payment_method.go (100.0%)</option>
				
				<option value="file144">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/country.go (88.9%)</option>
				
				<option value="file145">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/currency_amount.go (100.0%)</option>
				
				<option value="file146">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/currency_code.go (100.0%)</option>
				
				<option value="file147">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/device_payment_method.go (100.0%)</option>
				
				<option value="file148">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/order_status.go (100.0%)</option>
				
				<option value="file149">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/payment_method.go (92.0%)</option>
				
				<option value="file150">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/payment_methods/token_card.go (100.0%)</option>
				
				<option value="file151">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/user_type.go (100.0%)</option>
				
				<option value="file152">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/webhook_url.go (92.3%)</option>
				
				<option value="file153">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/capture_flow/capture_flow_handler.go (91.7%)</option>
				
				<option value="file154">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/capture_flow/dto/request/capture_request.go (100.0%)</option>
				
				<option value="file155">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/capture_flow/dto/request/release_request.go (100.0%)</option>
				
				<option value="file156">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/capture_flow/dto/response/capture_response.go (100.0%)</option>
				
				<option value="file157">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/capture_flow/dto/response/release_response.go (100.0%)</option>
				
				<option value="file158">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/card/card.handler.go (100.0%)</option>
				
				<option value="file159">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/card/card_delete.handler.go (100.0%)</option>
				
				<option value="file160">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/card/dto/request/card.go (90.9%)</option>
				
				<option value="file161">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account/collection_account.handler.go (0.0%)</option>
				
				<option value="file162">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account/dto/request/collection_account.go (0.0%)</option>
				
				<option value="file163">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account/dto/response/collection_account.go (100.0%)</option>
				
				<option value="file164">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account_route/collection_account_route.handler.go (0.0%)</option>
				
				<option value="file165">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account_route/dto/request/collection_center_account_route.go (0.0%)</option>
				
				<option value="file166">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account_route/dto/response/collection_center_account_route.go (100.0%)</option>
				
				<option value="file167">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_center/collection_center_handler.go (0.0%)</option>
				
				<option value="file168">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_center/dto/request/collection_center.go (0.0%)</option>
				
				<option value="file169">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_center/dto/response/collection_center.go (100.0%)</option>
				
				<option value="file170">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/request/order.go (94.7%)</option>
				
				<option value="file171">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/request/order_with_payments.go (0.0%)</option>
				
				<option value="file172">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/request/payment_methods/card_data_dto.go (100.0%)</option>
				
				<option value="file173">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/request/payment_order.go (94.2%)</option>
				
				<option value="file174">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/request/refund.go (100.0%)</option>
				
				<option value="file175">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/order_handler.go (46.9%)</option>
				
				<option value="file176">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/order_payments_handler.go (0.0%)</option>
				
				<option value="file177">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/payment_order_handler.go (92.3%)</option>
				
				<option value="file178">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/refund_handler.go (95.5%)</option>
				
				<option value="file179">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_concept/dto/request/payment_concept.go (0.0%)</option>
				
				<option value="file180">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_concept/dto/response/payment_concept.go (100.0%)</option>
				
				<option value="file181">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_concept/payment_concept.handler.go (0.0%)</option>
				
				<option value="file182">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_method/dto/request/payment_method.go (0.0%)</option>
				
				<option value="file183">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_method/dto/response/payment_method.go (100.0%)</option>
				
				<option value="file184">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_method/payment_method.handler.go (0.0%)</option>
				
				<option value="file185">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/user/user.handler.go (0.0%)</option>
				
				<option value="file186">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/webhooks/webhooks.handler.go (84.6%)</option>
				
				<option value="file187">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/aws/dynamo_client.go (0.0%)</option>
				
				<option value="file188">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/aws/s3_client_impl.go (11.1%)</option>
				
				<option value="file189">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/db/postgres_connection.go (0.0%)</option>
				
				<option value="file190">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/config/deunaHttpConfig.go (0.0%)</option>
				
				<option value="file191">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/config/mail_client_config.go (0.0%)</option>
				
				<option value="file192">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/deuna_auth_client.go (93.1%)</option>
				
				<option value="file193">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/deuna_capture_flow_client.go (81.0%)</option>
				
				<option value="file194">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/deuna_card_client.go (93.3%)</option>
				
				<option value="file195">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/deuna_login_client.go (0.0%)</option>
				
				<option value="file196">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/deuna_order_client.go (88.9%)</option>
				
				<option value="file197">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/deuna_payment_client.go (92.1%)</option>
				
				<option value="file198">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/deuna_refund_client.go (66.7%)</option>
				
				<option value="file199">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/deuna_user_client.go (100.0%)</option>
				
				<option value="file200">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/mail_client.go (90.9%)</option>
				
				<option value="file201">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/member_client.go (92.3%)</option>
				
				<option value="file202">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/webhooks/bills_api_webhook_url.go (100.0%)</option>
				
				<option value="file203">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/webhooks/webhook_notification_resource.go (85.0%)</option>
				
				<option value="file204">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/card/entities/card.go (100.0%)</option>
				
				<option value="file205">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/card/read_repository.go (100.0%)</option>
				
				<option value="file206">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/card/write_respository.go (81.8%)</option>
				
				<option value="file207">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_account/collection_account_repository.go (100.0%)</option>
				
				<option value="file208">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_account/entities/collection_account_entity.go (100.0%)</option>
				
				<option value="file209">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_account/read_repository.go (83.3%)</option>
				
				<option value="file210">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_account_route/collection_account_route.go (0.0%)</option>
				
				<option value="file211">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_center/collection_center_repository.go (80.0%)</option>
				
				<option value="file212">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/deuna_payment/deuna_order_repository.go (91.7%)</option>
				
				<option value="file213">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/deuna_payment/entities/deuna_payment.go (100.0%)</option>
				
				<option value="file214">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/eventsourcing/order_eventsourcing_repository.go (0.0%)</option>
				
				<option value="file215">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/order/entities/order.go (88.6%)</option>
				
				<option value="file216">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/order/read_repository.go (100.0%)</option>
				
				<option value="file217">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/order/write_repository.go (100.0%)</option>
				
				<option value="file218">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_concept/payment_concept_repository.go (0.0%)</option>
				
				<option value="file219">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_method/payment_method_repository.go (0.0%)</option>
				
				<option value="file220">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_order/entities/payment_order.go (100.0%)</option>
				
				<option value="file221">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_order/read_repository.go (83.3%)</option>
				
				<option value="file222">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_order/update_status_repository.go (76.2%)</option>
				
				<option value="file223">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_order/utils/generate_payment_order_id.go (100.0%)</option>
				
				<option value="file224">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_order/write_repository.go (100.0%)</option>
				
				<option value="file225">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_receipt/entities/payment_receipt_dto.go (93.8%)</option>
				
				<option value="file226">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_receipt/payment_receipt_repository.go (100.0%)</option>
				
				<option value="file227">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/refund/entities/refund.go (94.4%)</option>
				
				<option value="file228">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/refund/read_repository.go (80.0%)</option>
				
				<option value="file229">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/refund/write_repository.go (0.0%)</option>
				
				<option value="file230">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/user/entities/user.go (100.0%)</option>
				
				<option value="file231">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/user/read_repository.go (88.9%)</option>
				
				<option value="file232">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/user/write_repository.go (100.0%)</option>
				
				<option value="file233">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/storage/cdn_url_provider.go (0.0%)</option>
				
				<option value="file234">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/storage/disk_storage_adapter.go (0.0%)</option>
				
				<option value="file235">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/storage/mock_cdn_url_provider.go (100.0%)</option>
				
				<option value="file236">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/storage/payment_receipt_bucket.go (0.0%)</option>
				
				<option value="file237">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/storage/s3_storage_adapter.go (100.0%)</option>
				
				<option value="file238">gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/storage/storage_provider.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package adapters

import (
        "context"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/resources/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/resources/dto/response"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/deuna"
)

type CardAdapter interface {
        CreateCard(
                ctx context.Context,
                userID string,
                userType string,
                enterpriseID string,
                body request.CreateCardRequestDTO,
        ) (response.CardResponseDataDTO, error)

        DeleteCard(
                ctx context.Context,
                cardID string,
                externalCardID string,
                userID string,
                enterpriseID string,
        ) (response.DeleteCardResponseDTO, error)
}

type DeunaCardAdapterImpl struct {
        client       resources.DeunaCardResourceIF
        loginAdapter adapters.DeunaLoginAdapter
        userAdapter  deuna.CreateUserUseDeunaAdapterIF
}

func NewDeunaCardAdapter(
        client resources.DeunaCardResourceIF,
        loginAdapter adapters.DeunaLoginAdapter,
        userAdapter deuna.CreateUserUseDeunaAdapterIF,
) CardAdapter <span class="cov8" title="1">{
        return &amp;DeunaCardAdapterImpl{
                userAdapter:  userAdapter,
                client:       client,
                loginAdapter: loginAdapter,
        }
}</span>

func (d *DeunaCardAdapterImpl) CreateCard(
        oldContext context.Context,
        userID string,
        userType string,
        enterpriseID string,
        body request.CreateCardRequestDTO,
) (response.CardResponseDataDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[response.CardResponseDataDTO](
                oldContext,
                "DeunaCardAdapterImpl.CreateCard",
                func(ctx context.Context, span decorators.Span) (response.CardResponseDataDTO, error) </span><span class="cov8" title="1">{
                        user, err := d.userAdapter.GetOrCreateUser(ctx, userID, userType, enterpriseID)

                        if err != nil </span><span class="cov8" title="1">{
                                return response.CardResponseDataDTO{}, err
                        }</span>

                        <span class="cov8" title="1">token, err := d.loginAdapter.Login(ctx, user.ExternalUserID)
                        if err != nil </span><span class="cov8" title="1">{
                                return response.CardResponseDataDTO{}, err
                        }</span>

                        <span class="cov8" title="1">cardResponse, err := d.client.CreateCard(ctx, body, user.ExternalUserID, token)
                        if err != nil </span><span class="cov0" title="0">{
                                return response.CardResponseDataDTO{}, err
                        }</span>

                        <span class="cov8" title="1">cardResponse.InternalUserID = user.ID

                        return cardResponse, nil</span>
                },
        )
}

func (d *DeunaCardAdapterImpl) DeleteCard(
        ctx context.Context,
        cardID string,
        externalCardID string,
        userID string,
        enterpriseID string,
) (response.DeleteCardResponseDTO, error) <span class="cov8" title="1">{
        user, err := d.userAdapter.GetUser(ctx, userID, enterpriseID)

        if err != nil </span><span class="cov8" title="1">{
                return response.DeleteCardResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">cardBody := request.DeleteCardRequestDTO{
                CardId: externalCardID,
                UserId: user.ExternalUserID,
        }

        token, err := d.loginAdapter.Login(ctx, cardBody.UserId)

        if err != nil </span><span class="cov8" title="1">{
                return response.DeleteCardResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">return d.client.DeleteCard(ctx, cardBody, token)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package response

type CardResponseDTO struct {
        Data CardResponseDataDTO `json:"data"`
}

type CardResponseDataDTO struct {
        ID                      string `json:"id"`
        UserID                  string `json:"user_id"`
        CardHolder              string `json:"card_holder"`
        CardHolderDni           string `json:"card_holder_dni"`
        Company                 string `json:"company"`
        LastFour                string `json:"last_four"`
        FirstSix                string `json:"first_six"`
        ExpirationDate          string `json:"expiration_date"`
        IsValid                 bool   `json:"is_valid"`
        IsExpired               bool   `json:"is_expired"`
        VerifiedBy              string `json:"verified_by"`
        VerifiedWithTransaction string `json:"verified_with_transaction_id"`
        VerifiedAt              string `json:"verified_at"`
        LastUsed                string `json:"last_used"`
        CreatedAt               string `json:"created_at"`
        UpdatedAt               string `json:"updated_at"`
        DeletedAt               string `json:"deleted_at"`
        BankName                string `json:"bank_name"`
        CountryIso              string `json:"country_iso"`
        CardType                string `json:"card_type"`
        Source                  string `json:"source"`
        ZipCode                 string `json:"zip_code"`
        Vault                   string `json:"vault"`
        InternalUserID          string `json:"internal_user_id"`
}

func (c CardResponseDTO) IsEmpty() bool <span class="cov8" title="1">{
        return c.Data.ID == ""
}</span>

type DeleteCardResponseDTO struct {
        Code    string `json:"code"`
        Message string `json:"message"`
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package usecases

import (
        "context"
        "fmt"
        "sync"
        "time"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters"
        cardRepository "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/notification/constants"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/notification/services"
        log "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/observability/adapters"
        userRepository "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/repository"
        errorsBusiness "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/projections"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/card/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/card/dto/response"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/card/entities"
)

const (
        cardsPerBatch = 3 // Cantidad de tarjetas por lote (batch)
        numWorkers    = 5 // Número de workers concurrentes
)

type CardUsecaseIF interface {
        CreateCard(
                ctx context.Context,
                request request.CardRequest,
                enterpriseId string,
                preferredLanguage string,
        ) (response.CardResponse, error)

        TriggerCardExpiringSoonNotifications(
                ctx context.Context,
                request request.NotificationCardExpiringSoonRequestDTO,
        ) (response.NotificationCardExpiringSoonResponseDTO, error)
}

type CardUseCase struct {
        cardWriteRepository cardRepository.CardWriteRepositoryIF
        cardReadRepository  cardRepository.CardReadRepositoryIF
        userReadRepository  userRepository.UserReadRepositoryIF
        cardAdapter         adapters.CardAdapter
        notificationService services.NotificationService
        log                 log.Logger
}

func NewCardUseCase(
        cardAdapter adapters.CardAdapter,
        cardWriteRepository cardRepository.CardWriteRepositoryIF,
        cardReadRepository cardRepository.CardReadRepositoryIF,
        userReadRepository userRepository.UserReadRepositoryIF,
        notificationService services.NotificationService,
        log log.Logger,
) CardUsecaseIF <span class="cov8" title="1">{
        return &amp;CardUseCase{
                cardWriteRepository: cardWriteRepository,
                cardReadRepository:  cardReadRepository,
                userReadRepository:  userReadRepository,
                cardAdapter:         cardAdapter,
                notificationService: notificationService,
                log:                 log,
        }
}</span>

func (p *CardUseCase) CreateCard(
        ctx context.Context,
        request request.CardRequest,
        enterpriseID string,
        preferredLanguage string,
) (response.CardResponse, error) <span class="cov8" title="1">{
        newCard := entities.NewCard(
                request,
                enterpriseID,
        )

        createCardErr := p.cardWriteRepository.CreateCard(ctx, &amp;newCard)

        if createCardErr != nil </span><span class="cov8" title="1">{
                return response.CardResponse{}, errorsBusiness.NewCreateCardDBError(createCardErr)
        }</span>

        <span class="cov8" title="1">email, getEmailByUserIDErr := p.userReadRepository.GetEmailByUserID(ctx, request.UserID, enterpriseID)

        if getEmailByUserIDErr != nil </span><span class="cov8" title="1">{
                p.log.Warn(ctx, fmt.Sprintf("%v", getEmailByUserIDErr))
        }</span>

        <span class="cov8" title="1">formattedActionDate := newCard.CreatedAt.UTC().
                In(time.FixedZone("UTC-6", -6*60*60)).Format("2006-01-02 15:04")

        notifyCardAdditionErr := p.notificationService.NotifyCardAddition(
                ctx,
                []constants.NotificationChannel{constants.EmailChannel},
                &amp;request.UserID,
                &amp;email,
                &amp;formattedActionDate,
                &amp;newCard.LastFour,
                preferredLanguage,
        )

        if notifyCardAdditionErr != nil </span><span class="cov0" title="0">{
                p.log.Warn(ctx, fmt.Sprintf("%v", notifyCardAdditionErr))
        }</span>

        <span class="cov8" title="1">return response.CardResponse{
                ID:             newCard.ID.String(),
                CardTokenID:    newCard.ExternalCardID,
                Alias:          newCard.Alias,
                LastFour:       newCard.LastFour,
                Brand:          newCard.Brand,
                IsDefault:      newCard.IsDefault,
                IsRecurrent:    newCard.IsRecurrent,
                ExpirationDate: newCard.ExpirationDate.Format("01/06"),
        }, nil</span>
}

func (p *CardUseCase) TriggerCardExpiringSoonNotifications(
        ctx context.Context,
        request request.NotificationCardExpiringSoonRequestDTO,
) (response.NotificationCardExpiringSoonResponseDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator(
                ctx,
                "CardUseCase.TriggerCardExpiringSoonNotifications",
                func(ctx context.Context, span decorators.Span) (response.NotificationCardExpiringSoonResponseDTO, error) </span><span class="cov8" title="1">{
                        nextMonthCurrentDate := time.Now().AddDate(0, 1, 0)

                        notificationCardExpiringSoonProjections, err := p.cardReadRepository.GetCardsExpiringSoon(
                                ctx,
                                nextMonthCurrentDate.Month(),
                                nextMonthCurrentDate.Year(),
                        )
                        if err != nil </span><span class="cov8" title="1">{
                                return response.NotificationCardExpiringSoonResponseDTO{}, err
                        }</span>

                        <span class="cov8" title="1">if len(notificationCardExpiringSoonProjections) == 0 </span><span class="cov8" title="1">{
                                return response.NotificationCardExpiringSoonResponseDTO{
                                        Message: "no cards found to trigger expiring soon notifications",
                                }, nil
                        }</span>

                        <span class="cov8" title="1">expiringSoonCardJobs := make(
                                chan []projections.NotificationCardExpiringSoonProjection,
                                (len(notificationCardExpiringSoonProjections)+cardsPerBatch-1)/cardsPerBatch,
                        )
                        errChan := make(chan error, len(notificationCardExpiringSoonProjections))
                        var wg sync.WaitGroup

                        for range make([]struct{}, numWorkers) </span><span class="cov8" title="1">{
                                wg.Add(1)
                                go func() </span><span class="cov8" title="1">{
                                        defer wg.Done()
                                        for expiringSoonCardBatch := range expiringSoonCardJobs </span><span class="cov8" title="1">{
                                                p.processRetrievedCards(
                                                        ctx,
                                                        expiringSoonCardBatch,
                                                        request.NotificationChannels,
                                                        errChan,
                                                )
                                        }</span>
                                }()
                        }

                        <span class="cov8" title="1">for i := 0; i &lt; len(notificationCardExpiringSoonProjections); i += cardsPerBatch </span><span class="cov8" title="1">{
                                end := min(i+cardsPerBatch, len(notificationCardExpiringSoonProjections))
                                expiringSoonCardJobs &lt;- notificationCardExpiringSoonProjections[i:end]
                        }</span>
                        <span class="cov8" title="1">close(expiringSoonCardJobs)

                        wg.Wait()
                        close(errChan)

                        for err := range errChan </span><span class="cov8" title="1">{
                                p.log.Warn(ctx, fmt.Sprintf("%v", err))
                        }</span>

                        <span class="cov8" title="1">return response.NotificationCardExpiringSoonResponseDTO{
                                Message: "card expiring soon notification has been triggered",
                        }, nil</span>
                })
}

func (p *CardUseCase) processRetrievedCards(
        ctx context.Context,
        notificationCardExpiringSoonProjections []projections.NotificationCardExpiringSoonProjection,
        notificationChannels []constants.NotificationChannel,
        errChan chan error,
) <span class="cov8" title="1">{
        for _, projection := range notificationCardExpiringSoonProjections </span><span class="cov8" title="1">{
                err := p.notificationService.NotifyCardExpiringSoon(
                        ctx,
                        notificationChannels,
                        projection,
                )

                if err != nil </span><span class="cov8" title="1">{
                        errChan &lt;- err
                        continue</span>
                }

                <span class="cov8" title="1">p.log.Info(ctx, "the notification has been triggered successfully")</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package usecases

import (
        "context"
        "errors"
        "fmt"
        "time"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters"
        cardRepository "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/notification/constants"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/notification/services"
        log "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/observability/adapters"
        userRepository "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/repository"
        enums "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card"
        errorsBusiness "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/card/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/card/dto/response"
        "gorm.io/gorm"
)

type DeleteCardUseCaseIF interface {
        DeleteCard(
                ctx context.Context,
                request request.DeleteCardRequest,
                enterpriseId string,
                userLanguage string,
        ) (response.DeleteCardResponse, error)
}

type DeleteCardUseCase struct {
        cardAdapter         adapters.CardAdapter
        cardWriteRepository cardRepository.CardWriteRepositoryIF
        cardReadRepository  cardRepository.CardReadRepositoryIF
        userReadRepository  userRepository.UserReadRepositoryIF
        notificationService services.NotificationService
        log                 log.Logger
}

func NewDeleteCardUseCase(
        cardAdapter adapters.CardAdapter,
        cardWriteRepository cardRepository.CardWriteRepositoryIF,
        cardReadRepository cardRepository.CardReadRepositoryIF,
        userReadRepository userRepository.UserReadRepositoryIF,
        notificationService services.NotificationService,
        log log.Logger,
) DeleteCardUseCaseIF <span class="cov8" title="1">{
        return &amp;DeleteCardUseCase{
                cardAdapter:         cardAdapter,
                cardWriteRepository: cardWriteRepository,
                cardReadRepository:  cardReadRepository,
                userReadRepository:  userReadRepository,
                notificationService: notificationService,
                log:                 log,
        }
}</span>

func (p *DeleteCardUseCase) DeleteCard(
        ctx context.Context,
        request request.DeleteCardRequest,
        enterpriseID string,
        userLanguage string,
) (response.DeleteCardResponse, error) <span class="cov8" title="1">{
        actionDate := time.Now().UTC().In(time.FixedZone("UTC-6", -6*60*60))

        cardUserEmailProjection, getCardAndUserEmailByUserIDErr := p.cardReadRepository.GetCardAndUserEmailByUserID(
                ctx,
                request.UserID,
                request.CardID,
                enterpriseID,
        )

        if getCardAndUserEmailByUserIDErr != nil </span><span class="cov8" title="1">{
                if errors.Is(getCardAndUserEmailByUserIDErr, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return response.DeleteCardResponse{}, errorsBusiness.NewCardNotFoundError(
                                request.CardID,
                                getCardAndUserEmailByUserIDErr,
                        )
                }</span>

                <span class="cov8" title="1">return response.DeleteCardResponse{}, getCardAndUserEmailByUserIDErr</span>
        }

        <span class="cov8" title="1">deletecardr, deleteCardErr := p.cardAdapter.DeleteCard(
                ctx,
                cardUserEmailProjection.ID,
                cardUserEmailProjection.ExternalCardID,
                request.UserID,
                enterpriseID,
        )

        if deleteCardErr != nil </span><span class="cov8" title="1">{
                return response.DeleteCardResponse{}, errorsBusiness.NewDeleteCardError(enums.ProvidersDeUna, deleteCardErr)
        }</span>

        <span class="cov8" title="1">deleteCardResponse := response.DeleteCardResponse{}

        if deletecardr.Message == "" </span><span class="cov8" title="1">{
                deleteCardResponse.Status = "Success"
                deleteCardResponse.Message = "Card successfully deleted."
        }</span>

        <span class="cov8" title="1">deleteCardErr = p.cardWriteRepository.DeleteCard(ctx, request.CardID)

        if deleteCardErr != nil </span><span class="cov8" title="1">{
                return response.DeleteCardResponse{}, errorsBusiness.NewDeleteCardDBError(deleteCardErr)
        }</span>

        <span class="cov8" title="1">formattedActionDate := actionDate.Format("2006-01-02 15:04")

        notifyCardDeletionErr := p.notificationService.NotifyCardDeletion(
                ctx,
                []constants.NotificationChannel{constants.EmailChannel},
                &amp;cardUserEmailProjection.UserID,
                &amp;cardUserEmailProjection.Email,
                &amp;formattedActionDate,
                &amp;cardUserEmailProjection.LastFour,
                userLanguage,
        )

        if notifyCardDeletionErr != nil </span><span class="cov0" title="0">{
                p.log.Warn(ctx, fmt.Sprintf("%v", notifyCardDeletionErr))
        }</span>

        <span class="cov8" title="1">return deleteCardResponse, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package queries

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/repository"
        errorsBusiness "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
)

type GetCardByUserUsecaseIF interface {
        GetCardByIDAndUserID(ctx context.Context, userID, cardID, enterpriseID string) (entities.Card, error)
}

type GetCardByUserUsecase struct {
        repository repository.CardReadRepositoryIF
}

func NewGetCardByUserUsecase(
        repository repository.CardReadRepositoryIF,
) GetCardByUserUsecaseIF <span class="cov8" title="1">{
        return &amp;GetCardByUserUsecase{
                repository: repository,
        }
}</span>

func (p *GetCardByUserUsecase) GetCardByIDAndUserID(
        ctx context.Context, userID, cardID, enterpriseID string,
) (entities.Card, error) <span class="cov8" title="1">{
        card, err := p.repository.GetCardByUserID(ctx, userID, cardID, enterpriseID)

        if err != nil </span><span class="cov8" title="1">{
                return entities.Card{}, errorsBusiness.NewCardIsNotFromMember(userID, err)
        }</span>

        <span class="cov8" title="1">return entities.Card{
                ID:                card.ID.String(),
                ExternalCardID:    card.ExternalCardID,
                UserID:            card.UserID,
                CardHolder:        card.CardHolder,
                Alias:             card.Alias,
                Bin:               card.Bin,
                LastFour:          card.LastFour,
                Brand:             card.Brand,
                ExpirationDate:    card.ExpirationDate.String(),
                CardType:          card.CardType,
                Status:            card.Status,
                IsDefault:         card.IsDefault,
                IsRecurrent:       card.IsRecurrent,
                RetryAttempts:     card.RetryAttempts,
                EnterpriseID:      card.EnterpriseID,
                CardFailureReason: card.CardFailureReason,
                CardFailureCode:   card.CardFailureCode,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package queries

import (
        "context"
        "errors"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/repository"
        repositoryUser "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/repository"
        errorsBusiness "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/errors"
        errorsBusinessUser "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/user/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/card/dto/response"
        "gorm.io/gorm"
)

type GetCardUsecaseIF interface {
        GetCardsByUserID(ctx context.Context, memberId, enterpriseId string) ([]response.CardResponse, error)
}

type GetCardUsecase struct {
        repository     repository.CardReadRepositoryIF
        repositoryUser repositoryUser.UserReadRepositoryIF
}

func NewGetCardUsecase(
        repository repository.CardReadRepositoryIF,
        repositoryUser repositoryUser.UserReadRepositoryIF) GetCardUsecaseIF <span class="cov8" title="1">{
        return &amp;GetCardUsecase{
                repository:     repository,
                repositoryUser: repositoryUser,
        }
}</span>

func (p *GetCardUsecase) GetCardsByUserID(
        ctx context.Context, userID, enterpriseID string,
) ([]response.CardResponse, error) <span class="cov8" title="1">{
        _, err := p.repositoryUser.GetUserByID(ctx, userID, enterpriseID)

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, errorsBusinessUser.NewUserNotFoundError(userID, err)
                }</span>

                <span class="cov8" title="1">return []response.CardResponse{}, err</span>
        }

        <span class="cov8" title="1">cards, err := p.repository.GetCardsByUserID(ctx, userID, enterpriseID)

        if err != nil </span><span class="cov8" title="1">{
                return []response.CardResponse{}, errorsBusiness.NewCardErrorGetDB(err)
        }</span>

        <span class="cov8" title="1">return cards.ToDTO(), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package queries

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/collection_account/repositories"
        entitiesDomain "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

type GetCollectionAccountByRouteUsecaseIF interface {
        GetCollectionAccountByRoute(
                ctx context.Context,
                country, associatedOrigin,
                currency, enterpriseId string,
        ) (entitiesDomain.CollectionAccount, error)
}

type GetCollectionAccountByRouteUsecase struct {
        repository repositories.CollectionAccountReadRepositoryIF
}

func NewGetCollectionAccountByRouteUsecase(
        repository repositories.CollectionAccountReadRepositoryIF,
) GetCollectionAccountByRouteUsecaseIF <span class="cov8" title="1">{
        return &amp;GetCollectionAccountByRouteUsecase{
                repository: repository,
        }
}</span>

func (p *GetCollectionAccountByRouteUsecase) GetCollectionAccountByRoute(
        ctx context.Context, country, associatedOrigin, currency, enterpriseId string,
) (entitiesDomain.CollectionAccount, error) <span class="cov8" title="1">{
        collectionAccount, err := p.repository.GetCollectionAccountRoute(ctx, country, associatedOrigin, currency, enterpriseId)

        if err != nil </span><span class="cov8" title="1">{
                return entitiesDomain.CollectionAccount{}, errors.NewCollectionAccountNotFound()
        }</span>

        <span class="cov8" title="1">if collectionAccount.IsEmpty() </span><span class="cov8" title="1">{
                return entitiesDomain.CollectionAccount{}, errors.NewCollectionAccountNotFound()
        }</span>

        <span class="cov8" title="1">currencyCode, err := value_objects.NewCurrencyCode(collectionAccount.CurrencyCode)
        if err != nil </span><span class="cov0" title="0">{
                return entitiesDomain.CollectionAccount{}, err
        }</span>

        <span class="cov8" title="1">return entitiesDomain.CollectionAccount{
                ID:                     collectionAccount.ID.String(),
                AccountType:            collectionAccount.AccountType,
                CollectionCenterID:     collectionAccount.CollectionCenterID,
                CurrencyCode:           currencyCode,
                AccountNumber:          collectionAccount.AccountNumber,
                BankName:               collectionAccount.BankName,
                InterbankAccountNumber: collectionAccount.InterbankAccountNumber,
                EnterpriseID:           collectionAccount.EnterpriseID,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package usecases

import (
        "context"
        "errors"
        "fmt"
        "slices"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/utils"
        errorsBussines "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/collection_center/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account/dto/response"
        repository "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_account"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_account/entities"
        repositoryCollection "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_center"
        "gorm.io/gorm"
)

type CollectionAccountUsecaseIF interface {
        Create(
                ctx context.Context,
                collectionaccount request.CollectionAccountRequest,
                enterpriseId string,
        ) (response.CollectionAccountResponse, error)
}

type CollectionAccountUsecaseImpl struct {
        repository           repository.CollectionAccountRepositoryIF
        repoCollectionCenter repositoryCollection.CollectionCenterRepositoryIF
}

func NewCollectionAccountUsecase(
        repository repository.CollectionAccountRepositoryIF,
        repoCollectionCenter repositoryCollection.CollectionCenterRepositoryIF,
) CollectionAccountUsecaseIF <span class="cov8" title="1">{
        return &amp;CollectionAccountUsecaseImpl{
                repository:           repository,
                repoCollectionCenter: repoCollectionCenter,
        }
}</span>

func (p *CollectionAccountUsecaseImpl) Create(
        ctx context.Context,
        collectionAccount request.CollectionAccountRequest,
        enterpriseId string,
) (response.CollectionAccountResponse, error) <span class="cov8" title="1">{
        collectionCenter, err := p.repoCollectionCenter.FindByID(ctx, collectionAccount.CollectionCenterID, enterpriseId)

        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return response.CollectionAccountResponse{}, errorsBussines.NewCollectionCenterNotFoundError(err)
                }</span>

                <span class="cov8" title="1">return response.CollectionAccountResponse{}, err</span>
        }

        <span class="cov8" title="1">if !collectionCenter.IsEmpty() </span><span class="cov8" title="1">{
                if !slices.Contains(collectionCenter.AvailableCurrencies, collectionAccount.CurrencyCode) </span><span class="cov8" title="1">{
                        return response.CollectionAccountResponse{}, errorsBussines.NewInvalidCurrencyCodeError(
                                errors.New("currency code not available"),
                        )
                }</span>
        }

        <span class="cov8" title="1">accountFound, err := p.repository.FindByAccountNumber(ctx, collectionAccount.AccountNumber, enterpriseId)

        if err != nil </span><span class="cov8" title="1">{
                if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return response.CollectionAccountResponse{}, errorsBussines.NewCollectionAccountAlreadyExistsError(
                                err,
                        )
                }</span>
        }

        <span class="cov8" title="1">if !accountFound.IsEmpty() </span><span class="cov8" title="1">{
                return response.CollectionAccountResponse{}, errorsBussines.NewCollectionAccountAlreadyExistsError(
                        errors.New("account number already exists"),
                )
        }</span>

        <span class="cov8" title="1">if !utils.IsValidCurrencyCode(collectionAccount.CurrencyCode) </span><span class="cov8" title="1">{
                return response.CollectionAccountResponse{}, errorsBussines.NewInvalidCurrencyCodeError(
                        fmt.Errorf("%s is not a valid currency code", collectionAccount.CurrencyCode),
                )
        }</span>

        <span class="cov8" title="1">if !collectionAccount.AccountType.IsValid() </span><span class="cov8" title="1">{
                return response.CollectionAccountResponse{}, errorsBussines.NewInvalidAccountTypeError(
                        errors.New("invalid account type"),
                )
        }</span>

        <span class="cov8" title="1">entity := entities.NewCollectionAccountEntity(collectionAccount, enterpriseId)
        err = p.repository.Create(ctx, entity)

        if err != nil </span><span class="cov8" title="1">{
                return response.CollectionAccountResponse{}, errorsBussines.NewCollectionAccountError(err)
        }</span>

        <span class="cov8" title="1">return response.NewCollectionAccountResponse(entity), nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package usecases

import (
        "context"
        "errors"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/utils"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account_route/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account_route/dto/response"
        "gorm.io/gorm"

        repositoriesCollectionAccount "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_account"
        repositories "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_account_route"

        errorBusiness "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/collection_center/errors"
)

type CollectionAccountRouteUsecaseIF interface {
        Create(
                ctx context.Context,
                collection request.CollectionAccountRouteRequest,
                enterpriseId string,
        ) (response.CollectionAccountRouteResponse, error)
        Disable(ctx context.Context, id, enterpriseId string) (response.CollectionAccountRouteDisableResponse, error)
}

type CollectionAccountRouteUsecase struct {
        repository                  repositories.CollectionCenterAccountRouteRepositoryIF
        repositoryCollectionAccount repositoriesCollectionAccount.CollectionAccountRepositoryIF
}

func NewCollectionAccountRepositoryIF(
        repository repositories.CollectionCenterAccountRouteRepositoryIF,
        repositoryCollectionAccount repositoriesCollectionAccount.CollectionAccountRepositoryIF,
) CollectionAccountRouteUsecaseIF <span class="cov8" title="1">{
        return &amp;CollectionAccountRouteUsecase{
                repository:                  repository,
                repositoryCollectionAccount: repositoryCollectionAccount,
        }
}</span>

func (c *CollectionAccountRouteUsecase) Create(
        ctx context.Context,
        collection request.CollectionAccountRouteRequest,
        enterpriseId string,
) (response.CollectionAccountRouteResponse, error) <span class="cov8" title="1">{
        if !utils.IsValidCountryCode(collection.CountryCode) </span><span class="cov8" title="1">{
                return response.CollectionAccountRouteResponse{}, errorBusiness.NewInvalidCountryCodeError(
                        errors.New("invalid country code"),
                )
        }</span>

        <span class="cov8" title="1">if !utils.IsValidCurrencyCode(collection.CurrencyCode) </span><span class="cov8" title="1">{
                return response.CollectionAccountRouteResponse{}, errorBusiness.NewInvalidCountryCodeError(
                        errors.New("invalid currency code"),
                )
        }</span>

        <span class="cov8" title="1">if !collection.AssociatedOrigin.IsValid() </span><span class="cov8" title="1">{
                return response.CollectionAccountRouteResponse{}, errorBusiness.NewInvalidAssociatedOriginsError(
                        errors.New("invalid associated origin"),
                )
        }</span>

        <span class="cov8" title="1">routeFound, err := c.repository.FindRouteBy(
                ctx,
                collection.CountryCode,
                collection.CurrencyCode,
                collection.AssociatedOrigin.String(),
                enterpriseId,
        )

        if err != nil </span><span class="cov8" title="1">{
                if !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return response.CollectionAccountRouteResponse{}, errorBusiness.NewCollectionAccountFindByError(err)
                }</span>
        }

        <span class="cov8" title="1">if !routeFound.IsEmpty() </span><span class="cov8" title="1">{
                return response.CollectionAccountRouteResponse{},
                        errorBusiness.NewCollectionAccountRouteAlreadyExist(
                                errors.New("collection account route already exists"),
                        )
        }</span>

        <span class="cov8" title="1">collectionAccount, err := c.repositoryCollectionAccount.FindById(ctx, collection.CollectionAccountID, enterpriseId)
        if err != nil || collectionAccount.IsEmpty() </span><span class="cov8" title="1">{
                return response.CollectionAccountRouteResponse{}, errorBusiness.NewCollectionAccountNotFoundError(
                        errors.New("collection account not found"),
                )
        }</span>

        <span class="cov8" title="1">if collectionAccount.CurrencyCode != collection.CurrencyCode </span><span class="cov8" title="1">{
                return response.CollectionAccountRouteResponse{}, errorBusiness.NewCollectionAccountCurrencyCodeError(
                        errors.New("currency code does not match"),
                )
        }</span>

        <span class="cov8" title="1">entity := entities.NewCollectionAccountRouteEntity(
                collection,
                enterpriseId,
        )

        err = c.repository.Create(ctx, entity)
        if err != nil </span><span class="cov8" title="1">{
                return response.CollectionAccountRouteResponse{}, errorBusiness.NewCollectionAccountRouteCreateError(err)
        }</span>

        <span class="cov8" title="1">return response.NewCollectionAccountRouteResponse(
                entity,
        ), nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package usecases

import (
        "context"
        "time"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account_route/dto/response"
)

func (c *CollectionAccountRouteUsecase) Disable(
        ctx context.Context, id, enterpriseId string,
) (response.CollectionAccountRouteDisableResponse, error) <span class="cov8" title="1">{
        err := c.repository.Disable(ctx, id, enterpriseId)
        if err != nil </span><span class="cov8" title="1">{
                return response.CollectionAccountRouteDisableResponse{}, err
        }</span>

        <span class="cov8" title="1">return response.CollectionAccountRouteDisableResponse{
                ID:         id,
                Status:     "disabled",
                DisabledAt: time.Now().String(),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package usecases

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/utils"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_center/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_center/dto/response"
        repositories "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_center"
)

type CollectionCenterUsecaseIF interface {
        Create(ctx context.Context,
                request request.CollectionCenterRequest,
                enterpriseID string) (response.CollectionCenterResponse, error)
}

type CollectionCenterUsecase struct {
        repository repositories.CollectionCenterRepositoryIF
}

func NewCollectionCenterUsecase(repository repositories.CollectionCenterRepositoryIF) CollectionCenterUsecaseIF <span class="cov8" title="1">{
        return &amp;CollectionCenterUsecase{
                repository: repository,
        }
}</span>

func (c *CollectionCenterUsecase) Create(ctx context.Context,
        request request.CollectionCenterRequest,
        enterpriseID string,
) (response.CollectionCenterResponse, error) <span class="cov8" title="1">{
        request.AvailableCurrencies = utils.RemoveDuplicateCurrencies(request.AvailableCurrencies)

        collectionCenterEntity := entities.NewCollectionCenterEntity(
                request,
                enterpriseID,
        )

        err := utils.ValidateCurrencies(collectionCenterEntity.AvailableCurrencies)

        if err != nil </span><span class="cov8" title="1">{
                return response.CollectionCenterResponse{}, err
        }</span>

        <span class="cov8" title="1">err = c.repository.Create(ctx, collectionCenterEntity)

        if err != nil </span><span class="cov8" title="1">{
                return response.CollectionCenterResponse{}, err
        }</span>

        <span class="cov8" title="1">return response.NewCollectionCenterResponse(
                collectionCenterEntity,
        ), nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package adapters

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/notification/constants"
)

type Metadata map[string]any

func (m *Metadata) Add(key, value string) <span class="cov8" title="1">{
        if *m == nil </span><span class="cov8" title="1">{
                *m = make(Metadata)
        }</span>
        <span class="cov8" title="1">(*m)[key] = value</span>
}

type MailRequest struct {
        Recipient string                          `json:"recipient"`
        Content   string                          `json:"content"`
        Title     string                          `json:"title"`
        Channels  []constants.NotificationChannel `json:"channels"`
        Metadata  Metadata                        `json:"metadata"`
}

type MailAdapterIF interface {
        Send(ctx context.Context, request MailRequest) error
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package common

import "context"

const enterpriseIDKey = "Ctx_enterpriseID"

func SetEnterpriseID(ctx context.Context, enterpriseID string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, enterpriseIDKey, enterpriseID)
}</span>

func GetEnterpriseID(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        enterpriseID, ok := ctx.Value(enterpriseIDKey).(string)

        return enterpriseID, ok
}</span>

func ExistsEnterpriseID(ctx context.Context) bool <span class="cov0" title="0">{
        _, ok := ctx.Value(enterpriseIDKey).(string)

        return ok
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package services

import (
        "context"
        "strings"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"
        commonAdapters "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/common/adapters"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/notification/constants"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/notification/dto"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/projections"
)

type NotificationService interface {
        NotifyCardAddition(
                ctx context.Context,
                notificationChannels []constants.NotificationChannel,
                userID *string,
                email *string,
                actionDate *string,
                lastFour *string,
                userLanguage string,
        ) error

        NotifyCardDeletion(
                ctx context.Context,
                notificationChannels []constants.NotificationChannel,
                userID *string,
                email *string,
                actionDate *string,
                lastFour *string,
                userLanguage string,
        ) error

        NotifyCardExpiringSoon(
                ctx context.Context,
                notificationChannels []constants.NotificationChannel,
                projection projections.NotificationCardExpiringSoonProjection,
        ) error
}

type notificationServiceImpl struct {
        mailAdapter   commonAdapters.MailAdapterIF
        memberAdapter commonAdapters.MemberAdapterIF
}

func NewNotificationService(
        mailAdapter commonAdapters.MailAdapterIF,
        memberAdapter commonAdapters.MemberAdapterIF,
) NotificationService <span class="cov8" title="1">{
        return &amp;notificationServiceImpl{
                mailAdapter:   mailAdapter,
                memberAdapter: memberAdapter,
        }
}</span>

func (nsi *notificationServiceImpl) NotifyCardAddition(
        ctx context.Context,
        channels []constants.NotificationChannel,
        userID, email, actionDate, lastFour *string,
        lang string,
) error <span class="cov8" title="1">{
        return nsi.sendCardNotification(
                ctx,
                &amp;dto.CardNotificationDTO{
                        NotificationType: constants.NotificationTypeCardAddition,
                        Template:         "card-addition",
                        UserID:           *userID,
                        Email:            *email,
                        ActionDate:       *actionDate,
                        LastFour:         *lastFour,
                        Language:         lang,
                        Channels:         channels,
                },
        )
}</span>

func (nsi *notificationServiceImpl) NotifyCardDeletion(
        ctx context.Context,
        channels []constants.NotificationChannel,
        userID, email, actionDate, lastFour *string,
        lang string,
) error <span class="cov8" title="1">{
        return nsi.sendCardNotification(
                ctx,
                &amp;dto.CardNotificationDTO{
                        NotificationType: constants.NotificationTypeCardDeletion,
                        Template:         "card-remotion",
                        UserID:           *userID,
                        Email:            *email,
                        ActionDate:       *actionDate,
                        LastFour:         *lastFour,
                        Language:         lang,
                        Channels:         channels,
                },
        )
}</span>

func (nsi *notificationServiceImpl) NotifyCardExpiringSoon(
        ctx context.Context,
        channels []constants.NotificationChannel,
        notificationCardExpiringSoonProjection projections.NotificationCardExpiringSoonProjection,
) error <span class="cov8" title="1">{
        formattedDate := notificationCardExpiringSoonProjection.ExpirationDate.Format("01/06")

        userInfo, err := nsi.memberAdapter.GetUserProfileInfo(
                ctx,
                notificationCardExpiringSoonProjection.UserID,
                notificationCardExpiringSoonProjection.EnterpriseID,
        )
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">title, lang := nsi.getTitleAndLanguage(
                userInfo.PreferenceLanguage,
                constants.NotificationTypeCardExpiringSoon,
        )

        metadata := commonAdapters.Metadata{}
        metadata.Add("language", lang)
        metadata.Add("template", "card-expiration")
        metadata.Add("to", notificationCardExpiringSoonProjection.Email)
        metadata.Add("card_last_digits", notificationCardExpiringSoonProjection.LastFour)
        metadata.Add("card_expiration_date", formattedDate)
        metadata.Add("update_card_button_cta", config.Config().NotificationLinkEmail.Wallet)

        return nsi.mailAdapter.Send(ctx, commonAdapters.MailRequest{
                Recipient: notificationCardExpiringSoonProjection.UserID,
                Content:   "Your card is about to expire",
                Title:     title,
                Channels:  channels,
                Metadata:  metadata,
        })</span>
}

func (nsi *notificationServiceImpl) sendCardNotification(
        ctx context.Context,
        cardNotificationDTO *dto.CardNotificationDTO,
) error <span class="cov8" title="1">{
        title, language := nsi.getTitleAndLanguage(cardNotificationDTO.Language, cardNotificationDTO.NotificationType)

        metadata := commonAdapters.Metadata{}
        metadata.Add("language", language)
        metadata.Add("template", cardNotificationDTO.Template)
        metadata.Add("to", cardNotificationDTO.Email)
        metadata.Add("card_last_digits", cardNotificationDTO.LastFour)
        metadata.Add("action_date", cardNotificationDTO.ActionDate)
        metadata.Add("manage_cards_button_cta", config.Config().NotificationLinkEmail.Wallet)
        metadata.Add("contact_support_button_cta", config.Config().NotificationLinkEmail.ContactSupport)

        return nsi.mailAdapter.Send(ctx, commonAdapters.MailRequest{
                Recipient: cardNotificationDTO.UserID,
                Content:   "Card notification",
                Title:     title,
                Channels:  cardNotificationDTO.Channels,
                Metadata:  metadata,
        })
}</span>

func (nsi *notificationServiceImpl) getTitleAndLanguage(
        userLanguage string,
        notificationType constants.NotificationType,
) (string, string) <span class="cov8" title="1">{
        language := strings.ToLower(userLanguage)
        if language == "" </span><span class="cov8" title="1">{
                language = "en"
        }</span>

        <span class="cov8" title="1">titleMap, ok := constants.TitlesMap[notificationType]
        if !ok </span><span class="cov0" title="0">{
                titleMap = constants.TitlesMap[constants.NotificationTypeCardExpiringSoon]
        }</span>

        <span class="cov8" title="1">title, ok := titleMap[language]
        if !ok </span><span class="cov8" title="1">{
                title = titleMap["en"]
        }</span>

        <span class="cov8" title="1">return title, language</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package adapters

import (
        "context"
        "os"

        "github.com/shopspring/decimal"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/resources/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/resources/dto/response"
        repository2 "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
)

type OrderAdapterIF interface {
        CreateOrder(
                ctx context.Context, orderID string, paymentID string, currencyCode string, paymentTotal decimal.Decimal,
                paymentFlow enums.PaymentFlowEnum,
        ) (response.DeunaOrderResponseDTO, error)
        GetOrderByReferenceID(ctx context.Context, referenceID string, enterpriseID string) (entities.Order, error)
}

type DeunaOrderAdapter struct {
        readRepository  repository.OrderReadRepositoryIF
        resource        resources.DeunaOrderResourceIF
        deunaRepository repository2.DeunaOrderRepository
}

func NewOrderAdapter(
        readRepository repository.OrderReadRepositoryIF,
        deunaRepository repository2.DeunaOrderRepository,
        resource resources.DeunaOrderResourceIF,
) OrderAdapterIF <span class="cov8" title="1">{
        return &amp;DeunaOrderAdapter{
                readRepository:  readRepository,
                resource:        resource,
                deunaRepository: deunaRepository,
        }
}</span>

func (a *DeunaOrderAdapter) CreateOrder(
        ctx context.Context, orderID string, paymentID string, currencyCode string, paymentTotal decimal.Decimal,
        paymentFlow enums.PaymentFlowEnum,
) (response.DeunaOrderResponseDTO, error) <span class="cov8" title="1">{
        if token, _ := a.deunaRepository.GetTokenByOrderAndPaymentID(ctx, orderID, paymentID); token != "" </span><span class="cov8" title="1">{
                return response.DeunaOrderResponseDTO{
                        Token: token,
                }, nil
        }</span>

        <span class="cov8" title="1">deunaFlowType, err := paymentFlow.DeunaFlowType()

        if err != nil </span><span class="cov8" title="1">{
                return response.DeunaOrderResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">deunaOrderID := utils.NewDeunaOrderID(orderID, paymentID)

        orderDTO := request.CreateDeunaOrderRequestDTO{
                Order: request.DeunaOrder{
                        OrderID:     deunaOrderID.GetID(),
                        Currency:    currencyCode,
                        TotalAmount: utils.NewDeunaAmount(paymentTotal),
                        SubTotal:    utils.NewDeunaAmount(paymentTotal),
                        StoreCode:   "all",
                        WebhooksURL: request.WebhooksURL{
                                NotifyOrder: os.Getenv("DEUNA_NOTIFY_ORDER"),
                        },
                        Metadata: &amp;map[string]interface{}{
                                "additional_data.flow_type": deunaFlowType,
                        },
                },
                OrderType: request.DeunaOrderType(request.DeUnaNow.String()),
        }

        deunaResponse, err := a.resource.CreateOrder(ctx, orderDTO)

        if err != nil </span><span class="cov0" title="0">{
                return response.DeunaOrderResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">createErr := a.deunaRepository.CreatePaymentOrderDeuna(ctx, paymentID, orderID, deunaResponse.Token)

        if createErr != nil </span><span class="cov0" title="0">{
                return response.DeunaOrderResponseDTO{}, createErr
        }</span>

        <span class="cov8" title="1">return deunaResponse, nil</span>
}

func (a *DeunaOrderAdapter) GetOrderByReferenceID(ctx context.Context, referenceID string, enterpriseID string) (entities.Order, error) <span class="cov8" title="1">{
        orderFound, err := a.readRepository.GetOrderByReferenceID(ctx, referenceID, enterpriseID)

        if err != nil </span><span class="cov8" title="1">{
                return entities.Order{}, err
        }</span>

        <span class="cov8" title="1">return entities.Order{
                ID: orderFound.ID,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package request

import (
        "time"
)

type DeunaOrderType string

const (
        DeUnaCheckout DeunaOrderType = "DEUNA_CHECKOUT"
        DeUnaNow      DeunaOrderType = "DEUNA_NOW"
        PaymentLink   DeunaOrderType = "PAYMENT_LINK"
        AirlineOrder  DeunaOrderType = "AIRLINE_ORDER"
)

type CreateDeunaOrderRequestDTO struct {
        Order     DeunaOrder     `json:"order"`
        OrderType DeunaOrderType `json:"order_type"`
}

func (d DeunaOrderType) String() string <span class="cov8" title="1">{
        return string(d)
}</span>

type DeunaOrder struct {
        BillingAddress        *OrderAddress           `json:"billing_address"`
        Currency              string                  `json:"currency"`
        Items                 []Item                  `json:"items"`
        Metadata              *map[string]interface{} `json:"metadata"`
        PayerInfo             PayerInfo               `json:"payer_info"`
        ShippingAddress       *OrderAddress           `json:"shipping_address"`
        Description           *string                 `json:"description"`
        ExpiresAt             *time.Time              `json:"expires_at"`
        IncludePaymentOptions []PaymentOption         `json:"include_payment_options"`
        OrderID               string                  `json:"order_id"`
        StoreCode             string                  `json:"store_code"`
        SubTotal              int64                   `json:"sub_total"`
        TotalAmount           int64                   `json:"total_amount"`
        Timezone              string                  `json:"timezone"`
        TotalTaxAmount        int64                   `json:"total_tax_amount"`
        TotalDiscount         int64                   `json:"total_discount"`
        ItemsTotalAmount      int                     `json:"items_total_amount"`
        WebhooksURL           WebhooksURL             `json:"webhook_urls"`
}

type WebhooksURL struct {
        NotifyOrder string `json:"notify_order"`
}

type OrderAddress struct {
        ID                    int     `json:"id"`
        AddressType           string  `json:"address_type"`
        Country               string  `json:"country"`
        IsDefault             bool    `json:"is_default"`
        AdditionalDescription string  `json:"additional_description"`
        Address1              string  `json:"address1"`
        Address2              string  `json:"address2"`
        City                  string  `json:"city"`
        Email                 string  `json:"email"`
        FirstName             string  `json:"first_name"`
        LastName              string  `json:"last_name"`
        Lat                   float64 `json:"lat"`
        Lng                   float64 `json:"lng"`
        Phone                 string  `json:"phone"`
        StateName             string  `json:"state_name"`
        UserID                string  `json:"user_id"`
        Zipcode               string  `json:"zipcode"`
}

type Item struct {
        ID          string        `json:"id"`
        TaxAmount   MonetaryValue `json:"tax_amount"`
        Taxable     bool          `json:"taxable"`
        TotalAmount MonetaryValue `json:"total_amount"`
        UnitPrice   MonetaryValue `json:"unit_price"`
        Brand       string        `json:"brand"`
        Category    string        `json:"category"`
        Description string        `json:"description"`
        Name        string        `json:"name"`
        Quantity    int           `json:"quantity"`
}

type MonetaryValue struct {
        Currency       string  `json:"currency"`
        CurrencySymbol string  `json:"currency_symbol"`
        Amount         float64 `json:"amount"`
        OriginalAmount float64 `json:"original_amount,omitempty"`
        TotalDiscount  float64 `json:"total_discount,omitempty"`
}

type PayerInfo struct {
        Email string `json:"email"`
}

type PaymentOption struct {
        PaymentMethod string   `json:"payment_method"`
        Processors    []string `json:"processors"`
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package services

import (
        "context"
        "fmt"
        "sync"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/event_store"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/integration_events"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

type BillsApiWebhookUrl value_objects.WebhookUrl

type OrderNotificationStrategyIF interface {
        NotifyChange(ctx context.Context, orderID string, paymentID string) error
}

type OrderNotificationOrchestrator struct {
        orderRepository          event_store.OrderEventRepository
        orderFailedNotification  OrderFailedNotificationServiceIF
        orderSuccessNotification OrderProcessedNotificationServiceIF
        billsApiWebHookUrl       BillsApiWebhookUrl
}

func NewOrderNotificationOrchestrator(
        orderRepository event_store.OrderEventRepository,
        orderFailedNotification OrderFailedNotificationServiceIF,
        orderSuccessNotification OrderProcessedNotificationServiceIF,
        billsApiWebHookUrl BillsApiWebhookUrl,
) OrderNotificationStrategyIF <span class="cov8" title="1">{
        return &amp;OrderNotificationOrchestrator{
                orderRepository:          orderRepository,
                orderFailedNotification:  orderFailedNotification,
                orderSuccessNotification: orderSuccessNotification,
                billsApiWebHookUrl:       billsApiWebHookUrl,
        }
}</span>

func (o *OrderNotificationOrchestrator) notifyErrorBillsApi(
        oldCtx context.Context, failEvent integration_events.OrderFailedPaidIntegrationEvent,
) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(oldCtx,
                "OrderNotificationOrchestrator.notifyErrorBillsApi",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        return o.orderFailedNotification.Notify(ctx, value_objects.WebhookUrl(o.billsApiWebHookUrl), failEvent)
                }</span>)
}

func (o *OrderNotificationOrchestrator) notifySuccessBillsApi(oldCtx context.Context, ev integration_events.OrderPaymentProcessedIntegrationEvent) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(oldCtx,
                "OrderNotificationOrchestrator.notifySuccessBillsApi",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        return o.orderSuccessNotification.Notify(ctx, value_objects.WebhookUrl(o.billsApiWebHookUrl), ev)
                }</span>)
}

func (o *OrderNotificationOrchestrator) NotifyChange(oldCtx context.Context, orderID string, paymentID string) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(oldCtx,
                "OrderNotificationOrchestrator.NotifyChange",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        var order aggregate.Order
                        if err := o.orderRepository.Get(ctx, orderID, &amp;order); err != nil </span><span class="cov8" title="1">{
                                return errors.NewOrderNotFoundError(orderID)
                        }</span>

                        <span class="cov8" title="1">payment, err := order.FindPaymentByID(paymentID)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.NewOrderPaymentNotFoundError(orderID, paymentID)
                        }</span>

                        <span class="cov8" title="1">params := integration_events.IntegrationEventsParams{
                                ReferenceOrderID:   order.ID,
                                ReferencePaymentID: payment.ID,
                                AssociatedPayment:  payment.OriginType.Type.String(),
                                TotalOrderAmount:   order.TotalAmount.Value.InexactFloat64(),
                                Currency:           order.Currency.Code,
                                UserID:             order.User.ID,
                                UserType:           order.User.Type.String(),
                                EnterpriseID:       order.EnterpriseID,
                                TotalOrderPaid:     order.GetTotalProcessed().Value.InexactFloat64(),
                                TotalPaymentAmount: order.TotalAmount.Value.InexactFloat64(),
                                Metadata:           order.Metadata,
                                PaymentFlow:        payment.PaymentFlow,
                                ReceiptUrl:         payment.ReceiptUrl,
                                CardData: integration_events.CardData{
                                        CardNumber:    payment.PaymentCard.CardLast4,
                                        CardType:      payment.PaymentCard.CardBrand,
                                        MethodPayment: payment.PaymentCard.CardType,
                                },
                        }

                        numOfWorkers := 2
                        errChan := make(chan error, numOfWorkers)
                        wg := &amp;sync.WaitGroup{}

                        if payment.Status.IsFailure() </span><span class="cov8" title="1">{
                                failEvent := integration_events.NewOrderFailedIntegrationEvent(params, payment.FailureReason, payment.Status.String())
                                wg.Add(2)

                                go func(w *sync.WaitGroup) </span><span class="cov8" title="1">{
                                        errChan &lt;- o.orderFailedNotification.Notify(ctx, order.WebhookUrl, failEvent)
                                        w.Done()
                                }</span>(wg)

                                <span class="cov8" title="1">go func(w *sync.WaitGroup) </span><span class="cov8" title="1">{
                                        billsError := o.notifyErrorBillsApi(ctx, failEvent)
                                        errChan &lt;- fmt.Errorf("billsError: %v", billsError)
                                        w.Done()
                                }</span>(wg)

                        } else<span class="cov8" title="1"> {
                                successEvent := integration_events.NewOrderPaymentProcessedIntegrationEvent(params, payment.AuthorizationCode, payment.Status.String())
                                wg.Add(2)

                                go func(w *sync.WaitGroup) </span><span class="cov8" title="1">{
                                        errChan &lt;- o.orderSuccessNotification.Notify(ctx, order.WebhookUrl, successEvent)
                                        w.Done()
                                }</span>(wg)

                                <span class="cov8" title="1">go func(w *sync.WaitGroup) </span><span class="cov8" title="1">{
                                        errChan &lt;- o.notifySuccessBillsApi(ctx, successEvent)
                                        w.Done()
                                }</span>(wg)
                        }

                        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                                wg.Wait()
                                close(errChan)
                        }</span>()

                        <span class="cov8" title="1">var finalErr error = nil

                        for incomingErr := range errChan </span><span class="cov8" title="1">{
                                if incomingErr != nil </span><span class="cov8" title="1">{
                                        finalErr = incomingErr
                                }</span>
                        }

                        <span class="cov8" title="1">return finalErr</span>
                })
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package services

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/integration_events"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

type OrderFailedNotificationServiceIF interface {
        Notify(ctx context.Context, webhookUrl value_objects.WebhookUrl, event integration_events.OrderFailedPaidIntegrationEvent) error
}

type OrderFailedNotificationService struct {
        resource resources.WebhookNotificationResourceIF
}

func NewOrderFailedNotificationService(
        resource resources.WebhookNotificationResourceIF,
) OrderFailedNotificationServiceIF <span class="cov8" title="1">{
        return &amp;OrderFailedNotificationService{
                resource: resource,
        }
}</span>

func (s *OrderFailedNotificationService) Notify(ctx context.Context, webhookUrl value_objects.WebhookUrl, event integration_events.OrderFailedPaidIntegrationEvent) error <span class="cov8" title="1">{
        return s.resource.SendNotification(ctx, webhookUrl, event)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package services

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/integration_events"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

type OrderProcessedNotificationServiceIF interface {
        Notify(ctx context.Context, webhookUrl value_objects.WebhookUrl, event integration_events.OrderPaymentProcessedIntegrationEvent) error
}

type OrderProcessedNotificationService struct {
        resource resources.WebhookNotificationResourceIF
}

func NewOrderProcessedNotificationService(
        resource resources.WebhookNotificationResourceIF,
) OrderProcessedNotificationServiceIF <span class="cov8" title="1">{
        return &amp;OrderProcessedNotificationService{
                resource: resource,
        }
}</span>

func (s *OrderProcessedNotificationService) Notify(ctx context.Context, webhookUrl value_objects.WebhookUrl, event integration_events.OrderPaymentProcessedIntegrationEvent) error <span class="cov8" title="1">{
        return s.resource.SendNotification(ctx, webhookUrl, event)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package create

import (
        "context"
        "errors"
        "gitlab.com/clubhub.ai1/go-libraries/eventsourcing"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        errors2 "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors"

        log "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/observability/adapters"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/event_store"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/response"
)

type CreateOrderUseCaseIF interface {
        Create(ctx context.Context, cmd command.CreateOrderCommand) (response.OrderResponseDTO, error)
}

type CreateOrderUseCaseImpl struct {
        repository event_store.OrderEventRepository
        log        log.Logger
}

func NewCreateOrderUseCase(
        logger log.Logger,
        repository event_store.OrderEventRepository,
) CreateOrderUseCaseIF <span class="cov8" title="1">{
        return &amp;CreateOrderUseCaseImpl{
                repository: repository,
                log:        logger,
        }
}</span>

func (c *CreateOrderUseCaseImpl) Create(oldCtx context.Context, cmd command.CreateOrderCommand) (response.OrderResponseDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[response.OrderResponseDTO](
                oldCtx,
                "CreateOrderUseCaseImpl.Create",
                func(ctx context.Context, span decorators.Span) (response.OrderResponseDTO, error) </span><span class="cov8" title="1">{
                        o := new(aggregate.Order)
                        if err := c.repository.Get(ctx, cmd.ReferenceID, o); err != nil </span><span class="cov8" title="1">{
                                if errors.Is(err, eventsourcing.ErrAggregateAlreadyExists) </span><span class="cov8" title="1">{
                                        return response.OrderResponseDTO{}, errors2.NewOrderAlreadyExistError(cmd.ReferenceID)
                                }</span>

                                <span class="cov8" title="1">if !errors.Is(err, eventsourcing.ErrAggregateNotFound) </span><span class="cov0" title="0">{
                                        return response.OrderResponseDTO{}, err
                                }</span>
                        }

                        <span class="cov8" title="1">order, err := aggregate.Create(cmd)
                        if err != nil </span><span class="cov0" title="0">{
                                return response.OrderResponseDTO{}, err
                        }</span>

                        <span class="cov8" title="1">err = c.repository.Create(ctx, order)

                        if err != nil </span><span class="cov8" title="1">{
                                return response.OrderResponseDTO{}, err
                        }</span>

                        <span class="cov8" title="1">return response.OrderResponseDTO{
                                ReferenceOrderID: order.ID,
                        }, nil</span>
                })
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package queries

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"

        log "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/observability/adapters"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/response"
)

type QueriesOrderUseCaseIF interface {
        GetOrderDetail(ctx context.Context, orderID, enterpriseID string) (response.GetOrderResponseDTO, error)
        GetOrderPayments(ctx context.Context, orderID, enterpriseID string) (*response.GetOrderPaymentResponseDTO, error)
}

type QueriesOrderUseCaseImpl struct {
        ReadRepository repository.OrderReadRepositoryIF
        log            log.Logger
}

func NewQueriesOrderUseCase(
        logger log.Logger,
        readRepository repository.OrderReadRepositoryIF,
) QueriesOrderUseCaseIF <span class="cov8" title="1">{
        return &amp;QueriesOrderUseCaseImpl{
                ReadRepository: readRepository,
                log:            logger,
        }
}</span>

func (c *QueriesOrderUseCaseImpl) GetOrderDetail(oldCtx context.Context, orderID, enterpriseID string) (response.GetOrderResponseDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator(
                oldCtx,
                "QueriesOrderUseCaseImpl.GetOrderDetail",
                func(ctx context.Context, span decorators.Span) (response.GetOrderResponseDTO, error) </span><span class="cov8" title="1">{
                        order, err := c.ReadRepository.GetOrderByReferenceID(ctx, orderID, enterpriseID)

                        if err != nil </span><span class="cov8" title="1">{
                                return response.GetOrderResponseDTO{}, err
                        }</span>

                        <span class="cov8" title="1">metadata := make(map[string]string)

                        err = json.Unmarshal([]byte(order.Metadata), &amp;metadata)

                        if err != nil </span><span class="cov8" title="1">{
                                return response.GetOrderResponseDTO{}, err
                        }</span>

                        <span class="cov8" title="1">return response.GetOrderResponseDTO{
                                ReferenceOrderID: order.ReferenceOrderID,
                                Status:           enums.PaymentStatus(order.Status),
                                Total:            order.TotalAmount,
                                Currency:         order.CurrencyCode,
                                CountryCode:      order.CountryCode,
                                Metadata:         metadata,
                        }, nil</span>
                })
}

func (c *QueriesOrderUseCaseImpl) GetOrderPayments(ctx context.Context, orderID, enterpriseID string) (*response.GetOrderPaymentResponseDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator(
                ctx,
                "QueriesOrderUseCaseImpl.GetOrderPayments",
                func(ctx context.Context, span decorators.Span) (*response.GetOrderPaymentResponseDTO, error) </span><span class="cov8" title="1">{
                        orderPaymentProjection, getOrderPaymentErr := c.ReadRepository.GetOrderPayments(ctx, orderID, enterpriseID)

                        if getOrderPaymentErr != nil </span><span class="cov8" title="1">{
                                return nil, getOrderPaymentErr
                        }</span>

                        <span class="cov8" title="1">if len(orderPaymentProjection) == 0 </span><span class="cov8" title="1">{
                                return nil, errors.New("order not found with id: " + orderID)
                        }</span>

                        <span class="cov8" title="1">first := orderPaymentProjection[0]
                        payments := make([]response.PaymentDTO, 0, len(orderPaymentProjection))

                        metadata := make(map[string]string)
                        if first.Metadata != "" &amp;&amp; json.Unmarshal([]byte(first.Metadata), &amp;metadata) != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("error unmarshalling metadata for order: %s", orderID)
                        }</span>

                        <span class="cov8" title="1">for _, payment := range orderPaymentProjection </span><span class="cov8" title="1">{
                                if payment.PaymentID != "" </span><span class="cov8" title="1">{
                                        payments = append(payments, response.PaymentDTO{
                                                ID:                payment.PaymentID,
                                                Status:            payment.PaymentStatus,
                                                PaymentMethod:     payment.PaymentMethod,
                                                CardID:            payment.CardID,
                                                AuthorizationCode: payment.AuthorizationCode,
                                                PaymentOrderID:    payment.PaymentOrderID,
                                        })
                                }</span>
                        }

                        <span class="cov8" title="1">return &amp;response.GetOrderPaymentResponseDTO{
                                ReferenceOrderID: first.ReferenceOrderID,
                                Status:           enums.PaymentStatus(first.OrderStatus),
                                Total:            first.TotalAmount,
                                Currency:         first.CurrencyCode,
                                CountryCode:      first.CountryCode,
                                Metadata:         metadata,
                                Payments:         payments,
                        }, nil</span>

                },
        )
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package activities

import (
        "context"

        "gitlab.com/clubhub.ai1/go-libraries/saga/errors"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/use_cases/capture_flow"
)

const CapturePaymentActivityName = "CapturePaymentActivity"

type CapturePaymentActivity struct {
        capturePaymentUseCase capture_flow.PaymentCaptureUseCaseIF
}

func NewCapturePaymentActivity(capturePaymentUseCase capture_flow.PaymentCaptureUseCaseIF) *CapturePaymentActivity <span class="cov8" title="1">{
        return &amp;CapturePaymentActivity{
                capturePaymentUseCase: capturePaymentUseCase,
        }
}</span>

func (c *CapturePaymentActivity) CapturePayment(ctx context.Context, OrderID, PaymentID string) error <span class="cov8" title="1">{
        return errors.WrapActivityError(c.capturePaymentUseCase.CapturePayment(ctx, OrderID, PaymentID))
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package activities

import (
        "context"
        "errors"
        "gitlab.com/clubhub.ai1/go-libraries/eventsourcing"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/event_store"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate"
)

const CheckOrderExistenceActivityName = "CheckOrderExistenceActivity"

type CheckOrderActivity struct {
        repository event_store.OrderEventRepository
}

func NewCheckOrderActivity(repository event_store.OrderEventRepository) *CheckOrderActivity <span class="cov8" title="1">{
        return &amp;CheckOrderActivity{
                repository: repository,
        }
}</span>

func (a *CheckOrderActivity) CheckOrderExistence(ctx context.Context, orderID string) (bool, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[bool](
                ctx,
                "CreatePaymentOrderActivity.CheckOrderExistence",
                func(ctx context.Context, span decorators.Span) (bool, error) </span><span class="cov8" title="1">{
                        o := new(aggregate.Order)
                        err := a.repository.Get(ctx, orderID, o)

                        if err != nil </span><span class="cov8" title="1">{
                                if errors.Is(err, eventsourcing.ErrAggregateNotFound) </span><span class="cov8" title="1">{
                                        return false, nil
                                }</span>
                                <span class="cov8" title="1">return false, err</span>
                        }

                        <span class="cov8" title="1">return !o.IsEmpty(), nil</span>
                })
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package activities

import (
        "context"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/go-libraries/saga/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/use_cases/create"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/response"
)

const CreatePaymentOrderActivityName = "CreatePaymentOrderActivity"

type CreatePaymentOrderActivity struct {
        useCase create.CreatePaymentOrderUseCaseIF
}

func NewCreatePaymentOrderActivity(useCase create.CreatePaymentOrderUseCaseIF) *CreatePaymentOrderActivity <span class="cov8" title="1">{
        return &amp;CreatePaymentOrderActivity{
                useCase: useCase,
        }
}</span>

func (a *CreatePaymentOrderActivity) CreatePaymentOrder(ctx context.Context, cmd command.CreatePaymentOrderCommand) (response.PaymentOrderResponseDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[response.PaymentOrderResponseDTO](
                ctx,
                "CreatePaymentOrderActivity.CreatePaymentOrder",
                func(ctx context.Context, span decorators.Span) (response.PaymentOrderResponseDTO, error) </span><span class="cov8" title="1">{
                        payment, err := a.useCase.CreatePaymentOrder(ctx, cmd)
                        return payment, errors.WrapActivityError(err)
                }</span>)
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package activities

import (
        "context"
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/go-libraries/saga/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/event_store"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_receipt/use_case"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/payment_receipt/command"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
        "time"
)

const GenerateReceiptActivityName = "generate_receipt_activity"

type GeneratePaymentReceiptActivity struct {
        useCase    use_case.GenerateReceiptPaymentUseCase
        repository event_store.OrderEventRepository
}

func NewGeneratePaymentReceiptActivity(
        useCase use_case.GenerateReceiptPaymentUseCase, repository event_store.OrderEventRepository,
) *GeneratePaymentReceiptActivity <span class="cov8" title="1">{
        return &amp;GeneratePaymentReceiptActivity{
                useCase:    useCase,
                repository: repository,
        }
}</span>

func (n *GeneratePaymentReceiptActivity) GenerateReceipt(oldCtx context.Context, referenceID string, paymentID string) (entities.PaymentReceipt, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[entities.PaymentReceipt](oldCtx, "GeneratePaymentReceiptActivity.GenerateReceipt",
                func(ctx context.Context, span decorators.Span) (entities.PaymentReceipt, error) </span><span class="cov8" title="1">{

                        order := new(aggregate.Order)
                        err := n.repository.Get(ctx, referenceID, order)

                        if err != nil </span><span class="cov8" title="1">{
                                return entities.PaymentReceipt{}, errors.WrapActivityError(err)
                        }</span>

                        <span class="cov8" title="1">payment, err := order.FindPaymentByID(paymentID)
                        if err != nil </span><span class="cov8" title="1">{
                                return entities.PaymentReceipt{}, errors.WrapActivityError(fmt.Errorf("payment not found"))
                        }</span>

                        <span class="cov8" title="1">paymentAmount, _ := value_objects.NewCurrencyAmount(order.Currency, payment.Total.Value)

                        cmd := command.CreatePaymentReceiptCommand{
                                UserID:           order.User.ID,
                                EnterpriseID:     order.EnterpriseID,
                                Email:            order.Email,
                                ReferenceOrderID: referenceID,
                                PaymentID:        paymentID,
                                PaymentStatus:    string(payment.Status),
                                PaymentAmount:    paymentAmount,
                                PaymentCountry:   order.CountryCode,
                                PaymentMethod:    payment.Method,
                                PaymentDate:      payment.CreatedAt.Format(time.RFC3339),
                        }

                        receipt, genErr := n.useCase.Generate(ctx, cmd)

                        if genErr != nil </span><span class="cov8" title="1">{
                                return receipt, errors.WrapActivityError(genErr)
                        }</span>

                        <span class="cov8" title="1">return receipt, nil</span>
                })
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package activities

import (
        "context"
        "gitlab.com/clubhub.ai1/go-libraries/saga/errors"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/services"
)

const NotifyOrderChangeActivityName = "NotifyOrderChangeActivity"

type NotifyOrderChangeActivity struct {
        orderNotificationStrategy services.OrderNotificationStrategyIF
}

func NewNotifyOrderChangeActivity(orderNotificationStrategy services.OrderNotificationStrategyIF) *NotifyOrderChangeActivity <span class="cov8" title="1">{
        return &amp;NotifyOrderChangeActivity{
                orderNotificationStrategy: orderNotificationStrategy,
        }
}</span>

type NotifyOrderChangeParams struct {
        OrderID   string
        PaymentID string
}

func (n *NotifyOrderChangeActivity) NotifyOrderChange(ctx context.Context, params NotifyOrderChangeParams) error <span class="cov8" title="1">{
        return errors.WrapActivityError(n.orderNotificationStrategy.NotifyChange(ctx, params.OrderID, params.PaymentID))
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package activities

import (
        "context"

        postpayment "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/use_cases/post_payment"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
)

const PostProcessingPaymentOrderActivityName = "PostProcessingPaymentOrderActivity"

type PostProcessingPaymentOrderActivity struct {
        useCase postpayment.PostProcessingPaymentOrderUseCaseIF
}

func NewPostProcessingPaymentOrderActivity(useCase postpayment.PostProcessingPaymentOrderUseCaseIF) *PostProcessingPaymentOrderActivity <span class="cov8" title="1">{
        return &amp;PostProcessingPaymentOrderActivity{
                useCase: useCase,
        }
}</span>

func (a *PostProcessingPaymentOrderActivity) PostProcessingPaymentOrder(ctx context.Context, cmd postpayment.PostProcessingPaymentOrderCommand) (enums.PaymentFlowEnum, error) <span class="cov8" title="1">{
        return a.useCase.PostProcessPaymentOrder(ctx, cmd)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package activities

import (
        "context"

        "gitlab.com/clubhub.ai1/go-libraries/saga/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/use_cases/capture_flow"
)

const ReleasePaymentActivityName = "ReleasePaymentActivity"

type ReleasePaymentActivity struct {
        releasePaymentUseCase capture_flow.PaymentReleaseUseCaseIF
}

func NewReleasePaymentActivity(releasePaymentUseCase capture_flow.PaymentReleaseUseCaseIF) *ReleasePaymentActivity <span class="cov8" title="1">{
        return &amp;ReleasePaymentActivity{
                releasePaymentUseCase: releasePaymentUseCase,
        }
}</span>

func (r *ReleasePaymentActivity) ReleasePayment(ctx context.Context, orderID, paymentID, reason string) error <span class="cov8" title="1">{
        return errors.WrapActivityError(r.releasePaymentUseCase.ReleasePayment(ctx, orderID, paymentID, reason))
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package worfkflows

import (
        "fmt"
        "time"

        "gitlab.com/clubhub.ai1/go-libraries/saga/activity"
        "gitlab.com/clubhub.ai1/go-libraries/saga/workflow"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/activities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        enums2 "go.temporal.io/api/enums/v1"
)

const (
        CaptureFlowSignalName = "captureFlowSignal"
        CaptureFlowTimeout    = 2 * time.Minute
        TimeoutReason         = "Timeout: No se recibió señal de captura en el tiempo esperado"
)

type CompleteCaptureFlowSignal struct {
        OrderReferecenId string
        PaymentID        string
        Reason           string
        Action           enums.PaymentFlowActionEnum
}

func GetCaptureFlowSignalName(paymentOrderID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%s", CaptureFlowSignalName, paymentOrderID)
}</span>

func GetCaptureFlowWorkflowName(paymentOrderID string) string <span class="cov8" title="1">{
        return fmt.Sprintf("CaptureFlow-%s", paymentOrderID)
}</span>

func CallCaptureFlowWorkflow(ctx workflow.Context, referenceOrderID string, paymentID string) workflow.ChildWorkflowFuture <span class="cov8" title="1">{
        deunaOrderID := utils.NewDeunaOrderID(referenceOrderID, paymentID)
        cwo := workflow.ChildWorkflowOptions{
                WorkflowID:        GetCaptureFlowWorkflowName(deunaOrderID.GetID()),
                ParentClosePolicy: enums2.PARENT_CLOSE_POLICY_ABANDON,
        }

        ctx = workflow.WithChildOptions(ctx, cwo)

        return workflow.ExecuteChildWorkflow(ctx, CaptureFlowWorkflow, referenceOrderID, paymentID)
}</span>

func CaptureFlowWorkflow(ctx workflow.Context, referenceOrderID string, paymentID string) error <span class="cov8" title="1">{
        var processSignal CompleteCaptureFlowSignal

        ao := activity.ActivityOptions{
                StartToCloseTimeout: 10 * time.Second,
                RetryPolicy: &amp;activity.RetryPolicy{
                        InitialInterval:    1 * time.Second,
                        BackoffCoefficient: 2.0,
                        MaximumInterval:    10 * time.Second,
                        MaximumAttempts:    2,
                },
        }

        ctx = activity.WithActivityOptions(ctx, ao)

        var capturePaymentActivity *activities.CapturePaymentActivity
        var releasePaymentActivity *activities.ReleasePaymentActivity
        var paymentCaptureFlowErr error

        selector := workflow.NewSelector(ctx)

        signalChan := workflow.GetSignalChannel(ctx, CaptureFlowSignalName)

        timeoutChan := workflow.NewTimer(ctx, CaptureFlowTimeout)

        selector.AddReceive(signalChan, func(c workflow.ReceiveChannel, more bool) </span><span class="cov8" title="1">{
                c.Receive(ctx, &amp;processSignal)
        }</span>)

        <span class="cov8" title="1">selector.AddFuture(timeoutChan, func(f workflow.Future) </span><span class="cov8" title="1">{
                processSignal.Action = enums.ReleasePayment
                processSignal.OrderReferecenId = referenceOrderID
                processSignal.PaymentID = paymentID
                processSignal.Reason = TimeoutReason
        }</span>)

        <span class="cov8" title="1">selector.Select(ctx)

        if processSignal.Action.IsCapture() </span><span class="cov8" title="1">{
                paymentCaptureFlowErr = workflow.ExecuteActivity(ctx, capturePaymentActivity.CapturePayment,
                        processSignal.OrderReferecenId, processSignal.PaymentID).Get(ctx, nil)
        }</span> else<span class="cov8" title="1"> if processSignal.Action.IsRelease() </span><span class="cov8" title="1">{
                paymentCaptureFlowErr = workflow.ExecuteActivity(ctx, releasePaymentActivity.ReleasePayment,
                        processSignal.OrderReferecenId, processSignal.PaymentID, processSignal.Reason).Get(ctx, nil)
        }</span>

        <span class="cov8" title="1">return paymentCaptureFlowErr</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package worfkflows

import (
        "gitlab.com/clubhub.ai1/go-libraries/saga/activity"
        "gitlab.com/clubhub.ai1/go-libraries/saga/workflow"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/activities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/response"
        enums2 "go.temporal.io/api/enums/v1"

        "time"
)

func GetProcessOrderPaymentWorkflowName(paymentID string) string <span class="cov8" title="1">{
        return "ProcessOrderPaymentWorkflow_" + paymentID
}</span>

func CallProcessOrderPaymentChildWorkflow(ctx workflow.Context, cmd command.CreatePaymentOrderCommand) workflow.ChildWorkflowFuture <span class="cov8" title="1">{
        cwo := workflow.ChildWorkflowOptions{
                WorkflowID:        GetProcessOrderPaymentWorkflowName(cmd.Payment.ID),
                ParentClosePolicy: enums2.PARENT_CLOSE_POLICY_ABANDON,
        }

        ctx = workflow.WithChildOptions(ctx, cwo)

        return workflow.ExecuteChildWorkflow(ctx, ProcessOrderPaymentWorkflow, cmd)
}</span>

func ProcessOrderPaymentWorkflow(ctx workflow.Context, cmd command.CreatePaymentOrderCommand) error <span class="cov8" title="1">{
        ao := activity.ActivityOptions{
                StartToCloseTimeout: 10 * time.Second,
                RetryPolicy: &amp;activity.RetryPolicy{
                        InitialInterval:    1 * time.Second,
                        BackoffCoefficient: 2.0,
                        MaximumInterval:    10 * time.Second,
                        MaximumAttempts:    2,
                },
        }

        ctx = activity.WithActivityOptions(ctx, ao)

        var paymentOrderActivity *activities.CreatePaymentOrderActivity
        var paymentOrderResponse response.PaymentOrderResponseDTO

        err := workflow.ExecuteActivity(ctx, paymentOrderActivity.CreatePaymentOrder, cmd).Get(ctx, &amp;paymentOrderResponse)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">wfFuture := CallPostProcessingPaymentWorkflow(ctx, cmd.ReferenceOrderID, cmd.Payment.ID)

        // Wait for the child workflow to start.
        if getChildWorkflowErr := wfFuture.GetChildWorkflowExecution().Get(ctx, nil); getChildWorkflowErr != nil </span><span class="cov0" title="0">{
                return getChildWorkflowErr
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package worfkflows

import "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"

type PaymentStatus struct {
        Reference     string `json:"reference"`
        Status        string `json:"status"`
        FailureReason string `json:"failure_reason,omitempty"`
}

func NewNotProcessedStatus(referenceID string) PaymentStatus <span class="cov8" title="1">{
        return PaymentStatus{
                Reference: referenceID,
                Status:    enums.PaymentNotProcessed.String(),
        }
}</span>

func NewFailedPaymentStatus(referenceID, failureReason string) PaymentStatus <span class="cov8" title="1">{
        return PaymentStatus{
                Reference:     referenceID,
                Status:        enums.PaymentFailed.String(),
                FailureReason: failureReason,
        }
}</span>

func NewProcessingPaymentStatus(referenceID string) PaymentStatus <span class="cov8" title="1">{
        return PaymentStatus{
                Reference: referenceID,
                Status:    enums.PaymentProcessing.String(),
        }
}</span>

type PaymentOrderWorkflowOut struct {
        ReferenceOrderID string          `json:"reference_order_id,omitempty"`
        Payments         []PaymentStatus `json:"payments,omitempty"`
}

func NewPaymentOrderWorkflowOut(referenceOrderID string) *PaymentOrderWorkflowOut <span class="cov8" title="1">{
        return &amp;PaymentOrderWorkflowOut{ReferenceOrderID: referenceOrderID}
}</span>

func (p *PaymentOrderWorkflowOut) InitStatus(paymentReferenceID string) <span class="cov8" title="1">{
        p.Payments = append(p.Payments, NewNotProcessedStatus(paymentReferenceID))
}</span>

func (p *PaymentOrderWorkflowOut) ChangePaymentStatus(paymentStatus PaymentStatus) <span class="cov8" title="1">{
        for i, payment := range p.Payments </span><span class="cov8" title="1">{
                if payment.Reference == paymentStatus.Reference </span><span class="cov8" title="1">{
                        p.Payments[i] = paymentStatus
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package worfkflows

import "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"

type PaymentWorkflowInput struct {
        OrderID         string
        PaymentCommands []command.CreatePaymentOrderCommand
}

func NewPaymentWorkflowInput(
        orderID string,
        paymentCommands []command.CreatePaymentOrderCommand,
) PaymentWorkflowInput <span class="cov0" title="0">{
        return PaymentWorkflowInput{
                OrderID:         orderID,
                PaymentCommands: paymentCommands,
        }
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package worfkflows

import (
        "errors"
        "fmt"
        "time"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"

        "gitlab.com/clubhub.ai1/go-libraries/saga/activity"
        "gitlab.com/clubhub.ai1/go-libraries/saga/workflow"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/activities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils"
        postpaymentUseCase "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/use_cases/post_payment"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        enums2 "go.temporal.io/api/enums/v1"
)

const PaymentIntegrationProcessedSignalName = "paymentIntegrationProcessedSignal"

type PaymentProcessedSignal struct {
        AuthorizationCode   string
        OrderStatusString   string
        Status              enums.PaymentStatus
        OrderID             string
        PaymentID           string
        PaymentStatusString string
        PaymentReason       string
        PaymentCard         CardData
}

type CardData struct {
        CardBrand string
        CardLast4 string
        CardType  string
}

func GetPostProcessingWorkflowName(paymentOrderID string) string <span class="cov8" title="1">{
        return fmt.Sprintf("PostProcessingOrderPaymentWorkflow-%s", paymentOrderID)
}</span>

func CallPostProcessingPaymentWorkflow(ctx workflow.Context, referenceOrderID string, paymentID string) workflow.ChildWorkflowFuture <span class="cov8" title="1">{
        deunaOrderID := utils.NewDeunaOrderID(referenceOrderID, paymentID)
        cwo := workflow.ChildWorkflowOptions{
                WorkflowID:        GetPostProcessingWorkflowName(deunaOrderID.GetID()),
                ParentClosePolicy: enums2.PARENT_CLOSE_POLICY_ABANDON,
        }

        ctx = workflow.WithChildOptions(ctx, cwo)

        return workflow.ExecuteChildWorkflow(ctx, PostProcessingPaymentWorkflow, referenceOrderID, paymentID)
}</span>

func PostProcessingPaymentWorkflow(ctx workflow.Context, referenceOrderID string, paymentID string) error <span class="cov8" title="1">{
        var processSignal PaymentProcessedSignal
        var paymentErr error

        var postProcessingActivity *activities.PostProcessingPaymentOrderActivity
        var notifyOrderChangeActivity *activities.NotifyOrderChangeActivity
        var generatePaymentActivity *activities.GeneratePaymentReceiptActivity
        var captureFlow enums.PaymentFlowEnum = enums.Autocapture

        ao := activity.ActivityOptions{
                StartToCloseTimeout: 10 * time.Second,
                RetryPolicy: &amp;activity.RetryPolicy{
                        InitialInterval:    1 * time.Second,
                        BackoffCoefficient: 2.0,
                        MaximumInterval:    10 * time.Second,
                        MaximumAttempts:    2,
                },
        }

        ctx = activity.WithActivityOptions(ctx, ao)

        workflow.GetSignalChannel(ctx, PaymentIntegrationProcessedSignalName).Receive(ctx, &amp;processSignal)

        if processSignal.Status.IsFailure() </span><span class="cov8" title="1">{
                paymentErr = errors.New("payment failed")
        }</span>

        <span class="cov8" title="1">postProcessingCmd := postpaymentUseCase.PostProcessingPaymentOrderCommand{
                ReferenceOrderID:  referenceOrderID,
                PaymentID:         paymentID,
                Status:            processSignal.Status,
                AuthorizationCode: processSignal.AuthorizationCode,
                OrderStatusString: processSignal.OrderStatusString,
                PaymentReason:     processSignal.PaymentReason,
                PaymentCard: postpaymentUseCase.CardData{
                        CardBrand: processSignal.PaymentCard.CardBrand,
                        CardLast4: processSignal.PaymentCard.CardLast4,
                        CardType:  processSignal.PaymentCard.CardType,
                },
        }

        paymentErr = workflow.ExecuteActivity(ctx, postProcessingActivity.PostProcessingPaymentOrder, postProcessingCmd).
                Get(ctx, &amp;captureFlow)

        if paymentErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error in post processing: %w", paymentErr)
        }</span>

        <span class="cov8" title="1">notifyOrderChangeCmd := activities.NotifyOrderChangeParams{
                OrderID:   referenceOrderID,
                PaymentID: paymentID,
        }

        notifyOrderChangeErr := workflow.ExecuteActivity(
                ctx, notifyOrderChangeActivity.NotifyOrderChange, notifyOrderChangeCmd,
        ).
                Get(ctx, nil)

        if notifyOrderChangeErr != nil </span><span class="cov8" title="1">{
                fmt.Errorf("error in notify order change: %w", notifyOrderChangeErr)
        }</span>

        <span class="cov8" title="1">if captureFlow == enums.Capture </span><span class="cov8" title="1">{
                wfFuture := CallCaptureFlowWorkflow(ctx, referenceOrderID, paymentID)

                if getChildWorkflowErr := wfFuture.GetChildWorkflowExecution().Get(ctx, nil); getChildWorkflowErr != nil </span><span class="cov0" title="0">{
                        return getChildWorkflowErr
                }</span>
        }

        <span class="cov8" title="1">var paymentReceipt entities.PaymentReceipt

        if !processSignal.Status.IsFailure() </span><span class="cov8" title="1">{
                generateReceiptErr := workflow.ExecuteActivity(
                        ctx, generatePaymentActivity.GenerateReceipt, referenceOrderID, paymentID,
                ).
                        Get(ctx, &amp;paymentReceipt)

                if generateReceiptErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error in generate receipt: %w", generateReceiptErr)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package worfkflows

import (
        "gitlab.com/clubhub.ai1/go-libraries/saga/errors"
        errors2 "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors"
        "time"

        "gitlab.com/clubhub.ai1/go-libraries/saga/activity"
        "gitlab.com/clubhub.ai1/go-libraries/saga/workflow"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows/activities"
        "go.temporal.io/api/enums/v1"
)

func ProcessOrderWorkflow(ctx workflow.Context, workflowPaymentInput PaymentWorkflowInput) (*PaymentOrderWorkflowOut, error) <span class="cov8" title="1">{
        logger := workflow.GetLogger(ctx)
        orderID := workflowPaymentInput.OrderID

        paymentWorkflowOut := NewPaymentOrderWorkflowOut(orderID)

        for _, cmd := range workflowPaymentInput.PaymentCommands </span><span class="cov8" title="1">{
                paymentWorkflowOut.InitStatus(cmd.Payment.ID)
        }</span>

        <span class="cov8" title="1">ao := activity.ActivityOptions{
                StartToCloseTimeout: 10 * time.Second,
                RetryPolicy: &amp;activity.RetryPolicy{
                        InitialInterval:    1 * time.Second,
                        BackoffCoefficient: 2.0,
                        MaximumInterval:    10 * time.Second,
                        MaximumAttempts:    2,
                },
        }

        ctx = activity.WithActivityOptions(ctx, ao)

        var createOrderActivity *activities.CheckOrderActivity
        var existsOrder bool

        err := workflow.ExecuteActivity(ctx, createOrderActivity.CheckOrderExistence, orderID).
                Get(ctx, &amp;existsOrder)

        if err != nil </span><span class="cov8" title="1">{
                logger.Error("GetTokenByOrderAndPaymentID greeting failed.", "Error", err)
                return paymentWorkflowOut, nil
        }</span>

        <span class="cov8" title="1">if !existsOrder </span><span class="cov8" title="1">{
                return nil, errors.WrapActivityError(errors2.NewOrderNotFoundError(orderID))
        }</span>

        <span class="cov8" title="1">for _, paymentCommand := range workflowPaymentInput.PaymentCommands </span><span class="cov8" title="1">{
                paymentOrderID := workflowPaymentInput.OrderID + "_" + paymentCommand.Payment.ID
                cwo := workflow.ChildWorkflowOptions{
                        WorkflowID:        GetProcessOrderPaymentWorkflowName(paymentOrderID),
                        ParentClosePolicy: enums.PARENT_CLOSE_POLICY_ABANDON,
                }

                ctx = workflow.WithChildOptions(ctx, cwo)

                logger.Info("Starting child workflow", "WorkflowID", cwo.WorkflowID)

                callErr := CallProcessOrderPaymentChildWorkflow(ctx, paymentCommand).Get(ctx, nil)

                if callErr != nil </span><span class="cov8" title="1">{
                        paymentWorkflowOut.ChangePaymentStatus(NewFailedPaymentStatus(paymentCommand.Payment.ID, ""))
                        return paymentWorkflowOut, nil
                }</span> else<span class="cov8" title="1"> {
                        paymentWorkflowOut.ChangePaymentStatus(NewProcessingPaymentStatus(paymentCommand.Payment.ID))
                }</span>
        }

        <span class="cov8" title="1">return paymentWorkflowOut, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package usecases

import (
        "context"
        "errors"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_concept/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_concept/dto/response"
        repository "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_concept"
)

type PaymentConceptUsecaseIF interface {
        Create(
                ctx context.Context,
                payment request.PaymentConceptRequest,
                enterpriseId string,
        ) (response.PaymentConceptResponse, error)
}

type PaymentConceptUsecaseImpl struct {
        repository repository.PaymentConceptRepositoryIF
}

func NewPaymentConceptUsecase(repository repository.PaymentConceptRepositoryIF) PaymentConceptUsecaseIF <span class="cov8" title="1">{
        return &amp;PaymentConceptUsecaseImpl{
                repository: repository,
        }
}</span>

func (p *PaymentConceptUsecaseImpl) Create(
        ctx context.Context,
        payment request.PaymentConceptRequest,
        enterpriseId string,
) (response.PaymentConceptResponse, error) <span class="cov8" title="1">{
        entity := entities.NewPaymentConceptEntity(payment, enterpriseId)
        err := p.repository.Create(ctx, entity)

        if err != nil </span><span class="cov8" title="1">{
                return response.PaymentConceptResponse{}, errors.New("error creating payment concept")
        }</span>

        <span class="cov8" title="1">return response.NewPaymentConceptResponse(
                entity.ID.String(),
                entity.Name,
                entity.Code,
                entity.Description,
                entity.CreatedAt.String(),
        ), nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package usecases

import (
        "context"
        "fmt"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_method/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_method/dto/response"
        repositories "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_method"
)

type PaymentMethodUseCasesIF interface {
        Create(
                ctx context.Context,
                request request.PaymentMethodRequest,
                enterpriseId string,
        ) (response.PaymentMethodResponse, error)
}

type PaymentMethodUseCases struct {
        repository repositories.PaymentMethodRepositoryIF
}

func NewPaymentMethodUseCases(repository repositories.PaymentMethodRepositoryIF) PaymentMethodUseCasesIF <span class="cov8" title="1">{
        return &amp;PaymentMethodUseCases{
                repository: repository,
        }
}</span>

func (p *PaymentMethodUseCases) Create(
        ctx context.Context,
        request request.PaymentMethodRequest,
        enterpriseId string,
) (response.PaymentMethodResponse, error) <span class="cov8" title="1">{
        entity := entities.NewPaymentMethodEntity(
                request.Name,
                request.Code,
                request.Description,
                enterpriseId,
        )

        if err := p.repository.Create(ctx, entity); err != nil </span><span class="cov8" title="1">{
                return response.PaymentMethodResponse{}, fmt.Errorf("error creating payment method")
        }</span>

        <span class="cov8" title="1">return response.NewPaymentMethodResponse(
                entity.ID.String(),
                entity.Name,
                entity.Code,
                entity.Description,
        ), nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package adapter

import (
        "context"
        "errors"

        "github.com/shopspring/decimal"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils"
)

type PaymentCaptureFlowAdapterIF interface {
        CapturePayment(ctx context.Context, orderID, paymentID string, paymentTotal decimal.Decimal) error
        ReleasePayment(ctx context.Context, orderID, paymentID, reason string) error
}

type PaymentCaptureFlowAdapter struct {
        deunaCaptureFlowResource resources.DeunaCaptureFlowResourceIF
        deunaOrderRepository     repository.DeunaOrderRepository
}

func NewPaymentCaptureFlowAdapter(
        deunaCaptureFlowResource resources.DeunaCaptureFlowResourceIF,
        deunaOrderRepository repository.DeunaOrderRepository,
) PaymentCaptureFlowAdapterIF <span class="cov8" title="1">{
        return &amp;PaymentCaptureFlowAdapter{
                deunaCaptureFlowResource: deunaCaptureFlowResource,
                deunaOrderRepository:     deunaOrderRepository,
        }
}</span>

func (a *PaymentCaptureFlowAdapter) CapturePayment(ctx context.Context, orderID, paymentID string, paymentTotal decimal.Decimal) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(
                ctx,
                "PaymentCaptureFlowAdapter.CapturePayment",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        token, err := a.deunaOrderRepository.GetTokenByOrderAndPaymentID(ctx, orderID, paymentID)

                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">captureSuccess, err := a.deunaCaptureFlowResource.Capture(ctx, token, utils.NewDeunaAmount(paymentTotal))

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if !captureSuccess </span><span class="cov0" title="0">{
                                return errors.New("capture failed")
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                },
        )
}

func (a *PaymentCaptureFlowAdapter) ReleasePayment(ctx context.Context, orderID, paymentID, reason string) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(
                ctx,
                "PaymentCaptureFlowAdapter.ReleasePayment",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        token, err := a.deunaOrderRepository.GetTokenByOrderAndPaymentID(ctx, orderID, paymentID)

                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">releaseSuccess, err := a.deunaCaptureFlowResource.Release(ctx, token, reason)

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if !releaseSuccess </span><span class="cov0" title="0">{
                                return errors.New("release failed")
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                },
        )
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package adapter

import (
        "context"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        orderAdapter "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters"
        orderResponse "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/resources/dto/response"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/resources/dto/request"
        loginAdapter "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
        paymentOrderEntity "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_order/entities"
)

const (
        storeCode  = "all"
        creditCard = "credit_card"
)

type PaymentOrderAdapterIF interface {
        CreatePaymentOrder(
                ctx context.Context,
                cmd command.CreatePaymentOrderCommand,
                order *aggregate.Order,
                card entities.Card,
        ) error
}

type PaymentOrderAdapter struct {
        resource     resources.DeunaPaymentResourceIF
        orderAdapter orderAdapter.OrderAdapterIF
        loginAdapter loginAdapter.DeunaLoginAdapter
        readModel    repository.PaymentOrderRepositoryIF
}

func NewPaymentOrderAdapter(
        resource resources.DeunaPaymentResourceIF,
        orderAdapter orderAdapter.OrderAdapterIF,
        loginAdapter loginAdapter.DeunaLoginAdapter,
        readModel repository.PaymentOrderRepositoryIF,
) PaymentOrderAdapterIF <span class="cov8" title="1">{
        return &amp;PaymentOrderAdapter{
                resource:     resource,
                orderAdapter: orderAdapter,
                loginAdapter: loginAdapter,
                readModel:    readModel,
        }
}</span>

func (a *PaymentOrderAdapter) CreatePaymentOrder(
        oldCtx context.Context,
        cmd command.CreatePaymentOrderCommand,
        order *aggregate.Order,
        card entities.Card,
) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(
                oldCtx,
                "PaymentOrderAdapter.CreatePaymentOrder",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        orderCreated, err := a.createOrderDeUNA(ctx, cmd)

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">err = a.createPaymentOrderDeUNA(ctx, cmd, orderCreated.Token, card, order)

                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">purchaseOrderEntity := paymentOrderEntity.NewPaymentOrderEntity().
                                SetOrderID(order.ID).
                                SetAssociatedOrigin(cmd.AssociatedOrigin.Type.String()).
                                SetPaymentMethod(cmd.Payment.Method.Type.String()).
                                SetCurrencyCode(cmd.CurrencyCode.Code).
                                SetCountryCode(cmd.CountryCode).
                                SetCardID(card.ID).
                                SetCollectionAccountID(cmd.CollectionAccount.ID).
                                SetTransactionDate().
                                SetPaymentOrderID(cmd.Payment.ID).
                                SetEnterpriseID(order.EnterpriseID).
                                SetTotalAmount(cmd.Payment.Total.Value).
                                SetPaymentFlow(cmd.PaymentFlow).
                                SetStatus(enums.PaymentProcessing.String()).
                                Build()

                        return a.readModel.CreatePaymentOrder(ctx, purchaseOrderEntity)</span>
                },
        )
}

func (a *PaymentOrderAdapter) createOrderDeUNA(oldCtx context.Context, cmd command.CreatePaymentOrderCommand) (orderResponse.DeunaOrderResponseDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[orderResponse.DeunaOrderResponseDTO](
                oldCtx,
                "PaymentOrderAdapter.createOrderDeUNA",
                func(ctx context.Context, span decorators.Span) (orderResponse.DeunaOrderResponseDTO, error) </span><span class="cov8" title="1">{

                        orderDeUNA, err := a.orderAdapter.CreateOrder(
                                ctx, cmd.ReferenceOrderID, cmd.Payment.ID, cmd.CurrencyCode.Code,
                                cmd.Payment.Total.Value, cmd.PaymentFlow,
                        )

                        if err != nil </span><span class="cov0" title="0">{
                                return orderResponse.DeunaOrderResponseDTO{}, err
                        }</span>

                        <span class="cov8" title="1">return orderDeUNA, nil</span>
                })
}

func (a *PaymentOrderAdapter) createPaymentOrderDeUNA(
        oldCtx context.Context,
        cmd command.CreatePaymentOrderCommand,
        orderToken string,
        cardEntity entities.Card,
        order *aggregate.Order,
) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(
                oldCtx,
                "PaymentOrderAdapter.createPaymentOrderDeUNA",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        medata := map[string]interface{}{}
                        card := cmd.Payment.Method.CCData.Data

                        newPayment := request.DeunaOrderPaymentRequest{
                                OrderToken: orderToken,
                                CardID:     cardEntity.ExternalCardID,
                                Email:      order.Email,
                                CreditCard: &amp;request.CreditCardInfo{
                                        CardCVV: &amp;card.CVV,
                                },
                                Metadata:   &amp;medata,
                                MethodType: creditCard,
                                StoreCode:  storeCode,
                        }

                        token, err := a.loginAdapter.LoginWitUserID(ctx, cmd.User.ID, order.EnterpriseID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">makeOrderErr := a.resource.MakeOrderPayment(ctx, newPayment, token)

                        return makeOrderErr</span>
                })
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package utils

import "github.com/shopspring/decimal"

const precisionFloat = 2

type DeunaTotalRefundRequest struct {
        Reason string `json:"reason"`
}

type DeunaPartialRefundRequest struct {
        Amount int64  `json:"amount"`
        Reason string `json:"reason"`
}

func NewDeunaAmount(amount decimal.Decimal) int64 <span class="cov8" title="1">{
        const CentsPerUnit = 100

        return amount.Mul(decimal.NewFromInt(CentsPerUnit)).Truncate(precisionFloat).IntPart()
}</span>

func DeunaAmountToAmount(deunaAmount int64) decimal.Decimal <span class="cov8" title="1">{
        const CentsPerUnit = 100

        return decimal.NewFromInt(deunaAmount).Div(decimal.NewFromInt(CentsPerUnit)).Truncate(precisionFloat)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package utils

import (
        "fmt"
        "strings"
)

func composeDeunaOrderID(orderID string, paymentID string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-%s", orderID, paymentID)
}</span>

func ExtractFromDeunaOrderID(deunaOrderID string) (DeunaOrderID, error) <span class="cov8" title="1">{
        parts := strings.Split(deunaOrderID, "-")
        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                return DeunaOrderID{}, fmt.Errorf("invalid deunaOrderID: %s", deunaOrderID)
        }</span>
        <span class="cov8" title="1">orderID := strings.Join(parts[:len(parts)-1], "-")

        paymentID := parts[len(parts)-1]
        return DeunaOrderID{
                composedOrderID:  deunaOrderID,
                paymentID:        paymentID,
                referenceOrderID: orderID,
        }, nil</span>

}

type DeunaOrderID struct {
        composedOrderID  string
        paymentID        string
        referenceOrderID string
}

func NewDeunaOrderID(orderID, paymentID string) *DeunaOrderID <span class="cov8" title="1">{
        return &amp;DeunaOrderID{
                composedOrderID:  composeDeunaOrderID(orderID, paymentID),
                paymentID:        paymentID,
                referenceOrderID: orderID,
        }
}</span>

func (d DeunaOrderID) GetID() string <span class="cov8" title="1">{
        return d.composedOrderID
}</span>

func (d DeunaOrderID) GetOrderID() string <span class="cov8" title="1">{
        return d.referenceOrderID
}</span>

func (d DeunaOrderID) GetPaymentID() string <span class="cov8" title="1">{
        return d.paymentID
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package capture_flow

import (
        "context"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/event_store"
        adapter "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
)

type PaymentCaptureUseCaseIF interface {
        CapturePayment(ctx context.Context, orderID, paymentID string) error
}

type PaymentCaptureUseCase struct {
        repository                event_store.OrderEventRepository
        deunaOrderRepository      repository.DeunaOrderRepository
        paymentCaptureFlowAdapter adapter.PaymentCaptureFlowAdapterIF
        transactionsRepository    repository.TransactionsRepositoryIF
}

func NewPaymentCaptureUseCase(
        repository event_store.OrderEventRepository,
        deunaOrderRepository repository.DeunaOrderRepository,
        paymentCaptureFlowAdapter adapter.PaymentCaptureFlowAdapterIF,
        transactionsRepository repository.TransactionsRepositoryIF,
) PaymentCaptureUseCaseIF <span class="cov8" title="1">{
        return &amp;PaymentCaptureUseCase{
                repository:                repository,
                deunaOrderRepository:      deunaOrderRepository,
                paymentCaptureFlowAdapter: paymentCaptureFlowAdapter,
                transactionsRepository:    transactionsRepository,
        }
}</span>

func (u *PaymentCaptureUseCase) CapturePayment(ctx context.Context, orderID, paymentID string) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(
                ctx,
                "PaymentCaptureUseCase.CapturePayment",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        order := new(aggregate.Order)
                        err := u.repository.Get(ctx, orderID, order)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">payment, err := order.FindPaymentByID(paymentID)

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">err = u.paymentCaptureFlowAdapter.CapturePayment(ctx, orderID, paymentID, payment.Total.Value)

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">order.OrderPaymentCaptured(command.NewPaymentOrderCapturedCommand(
                                orderID,
                                paymentID,
                                payment.Total.Code.Code,
                                payment.Total.Value,
                        ))

                        err = u.transactionsRepository.UpdatePaymentOrderStatus(ctx, orderID, paymentID, order.EnterpriseID, enums.PaymentStatus(order.Status.Get()))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">err = u.repository.Save(ctx, order)

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                },
        )
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package capture_flow

import (
        "context"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/event_store"
        adapter "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
)

type PaymentReleaseUseCaseIF interface {
        ReleasePayment(ctx context.Context, orderID, paymentID, reason string) error
}

type PaymentReleaseUseCase struct {
        repository                event_store.OrderEventRepository
        paymentCaptureFlowAdapter adapter.PaymentCaptureFlowAdapterIF
        transactionsRepository    repository.TransactionsRepositoryIF
}

func NewPaymentReleaseUseCase(
        repository event_store.OrderEventRepository,
        paymentCaptureFlowAdapter adapter.PaymentCaptureFlowAdapterIF,
        transactionsRepository repository.TransactionsRepositoryIF,
) PaymentReleaseUseCaseIF <span class="cov8" title="1">{
        return &amp;PaymentReleaseUseCase{
                repository:                repository,
                paymentCaptureFlowAdapter: paymentCaptureFlowAdapter,
                transactionsRepository:    transactionsRepository,
        }
}</span>

func (u *PaymentReleaseUseCase) ReleasePayment(ctx context.Context, orderID, paymentID, reason string) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(
                ctx,
                "PaymentReleaseUseCase.ReleasePayment",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        order := new(aggregate.Order)
                        err := u.repository.Get(ctx, orderID, order)

                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">err = u.paymentCaptureFlowAdapter.ReleasePayment(ctx, orderID, paymentID, reason)

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">order.OrderPaymentReleased(command.NewPaymentOrderReleasedCommand(
                                orderID,
                                paymentID,
                                reason,
                        ))

                        err = u.transactionsRepository.UpdatePaymentOrderStatus(ctx, orderID, paymentID, order.EnterpriseID, enums.PaymentStatus(order.Status.Get()))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">err = u.repository.Save(ctx, order)

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                },
        )
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package create

import (
        "context"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        queriesCard "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/usecases/queries"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/collection_account/queries"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/event_store"
        adapter "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/response"
)

type CreatePaymentOrderUseCaseIF interface {
        CreatePaymentOrder(
                ctx context.Context,
                cmd command.CreatePaymentOrderCommand,
        ) (response.PaymentOrderResponseDTO, error)
}

type CreatePaymentOrderUseCaseImpl struct {
        repository             event_store.OrderEventRepository
        collectionAccountQuery queries.GetCollectionAccountByRouteUsecaseIF
        cardQuery              queriesCard.GetCardByUserUsecaseIF
        paymentOrderAdapter    adapter.PaymentOrderAdapterIF
}

func NewCreatePaymentOrderUseCase(
        repository event_store.OrderEventRepository,
        collectionAccountQuery queries.GetCollectionAccountByRouteUsecaseIF,
        cardQuery queriesCard.GetCardByUserUsecaseIF,
        paymentOrderAdapter adapter.PaymentOrderAdapterIF,
) CreatePaymentOrderUseCaseIF <span class="cov8" title="1">{
        return &amp;CreatePaymentOrderUseCaseImpl{
                repository:             repository,
                collectionAccountQuery: collectionAccountQuery,
                cardQuery:              cardQuery,
                paymentOrderAdapter:    paymentOrderAdapter,
        }
}</span>

func (p *CreatePaymentOrderUseCaseImpl) CreatePaymentOrder(
        ctx context.Context,
        cmd command.CreatePaymentOrderCommand,
) (response.PaymentOrderResponseDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[response.PaymentOrderResponseDTO](
                ctx,
                "CreatePaymentOrderUseCaseImpl.CreatePaymentOrder",
                func(ctx context.Context, span decorators.Span) (response.PaymentOrderResponseDTO, error) </span><span class="cov8" title="1">{
                        order := new(aggregate.Order)

                        err := p.repository.Get(ctx, cmd.ReferenceOrderID, order)

                        if err != nil </span><span class="cov8" title="1">{
                                return response.PaymentOrderResponseDTO{}, err
                        }</span>

                        <span class="cov8" title="1">collectionAccount, err := p.collectionAccountQuery.GetCollectionAccountByRoute(
                                ctx,
                                order.CountryCode.Iso3(),
                                cmd.AssociatedOrigin.Type.String(),
                                cmd.CurrencyCode.Code,
                                order.EnterpriseID,
                        )

                        if err != nil </span><span class="cov8" title="1">{
                                return response.PaymentOrderResponseDTO{}, err
                        }</span>

                        <span class="cov8" title="1">cmd = cmd.WithCollectionAccount(collectionAccount)

                        card, err := p.cardQuery.GetCardByIDAndUserID(ctx,
                                cmd.User.ID,
                                cmd.Payment.Method.CCData.Data.CardID,
                                order.EnterpriseID,
                        )

                        if err != nil </span><span class="cov8" title="1">{
                                return response.PaymentOrderResponseDTO{}, err
                        }</span>

                        <span class="cov8" title="1">paymentFlow, err := enums.NewPaymentFlowEnum(card.CardType, order.AllowCapture)

                        if err != nil </span><span class="cov0" title="0">{
                                return response.PaymentOrderResponseDTO{}, err
                        }</span>

                        <span class="cov8" title="1">cmd = cmd.WithPaymentFlow(paymentFlow)

                        cmd = cmd.WithCardData(card)

                        err = order.StartProcessingOrderPayment(cmd)

                        if err != nil </span><span class="cov8" title="1">{
                                return response.PaymentOrderResponseDTO{}, err
                        }</span>

                        <span class="cov8" title="1">adapterErr := p.paymentOrderAdapter.CreatePaymentOrder(ctx, cmd, order, card)

                        if adapterErr != nil </span><span class="cov8" title="1">{
                                return response.PaymentOrderResponseDTO{}, adapterErr
                        }</span>

                        <span class="cov8" title="1">repositoryErr := p.repository.Save(ctx, order)

                        if repositoryErr != nil </span><span class="cov8" title="1">{
                                return response.PaymentOrderResponseDTO{}, repositoryErr
                        }</span>

                        <span class="cov8" title="1">return response.PaymentOrderResponseDTO{
                                ReferenceOrderID: order.ID,
                        }, nil</span>
                })
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package use_cases

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/event_store"
        paymentOrderRepository "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
)

type PostProcessingPaymentOrderUseCaseIF interface {
        PostProcessPaymentOrder(ctx context.Context, cmd PostProcessingPaymentOrderCommand) (enums.PaymentFlowEnum, error)
}

type PostProcessingPaymentOrderUseCase struct {
        orderRepository             event_store.OrderEventRepository
        orderReadRepository         repository.OrderReadRepositoryIF
        orderWriteRepository        repository.OrderWriteRepositoryIF
        paymentOrderWriteRepository paymentOrderRepository.PaymentOrderRepositoryIF
        paymentOrderReadRepository  paymentOrderRepository.GetPaymentOrderByReferenceIF
}

func NewPostProcessingPaymentOrderUseCase(
        orderRepository event_store.OrderEventRepository,
        orderReadRepository repository.OrderReadRepositoryIF,
        orderWriteRepository repository.OrderWriteRepositoryIF,
        paymentOrderWriteRepository paymentOrderRepository.PaymentOrderRepositoryIF,
        paymentOrderReadRepository paymentOrderRepository.GetPaymentOrderByReferenceIF,
) PostProcessingPaymentOrderUseCaseIF <span class="cov8" title="1">{
        return &amp;PostProcessingPaymentOrderUseCase{
                orderRepository:             orderRepository,
                orderReadRepository:         orderReadRepository,
                orderWriteRepository:        orderWriteRepository,
                paymentOrderWriteRepository: paymentOrderWriteRepository,
                paymentOrderReadRepository:  paymentOrderReadRepository,
        }
}</span>

type CardData struct {
        CardBrand string
        CardLast4 string
        CardType  string
}
type PostProcessingPaymentOrderCommand struct {
        ReferenceOrderID  string
        PaymentID         string
        Status            enums.PaymentStatus
        AuthorizationCode string
        OrderStatusString string
        PaymentReason     string
        PaymentCard       CardData
}

func (c *PostProcessingPaymentOrderUseCase) PostProcessPaymentOrder(ctx context.Context,
        cmd PostProcessingPaymentOrderCommand) (enums.PaymentFlowEnum, error) <span class="cov8" title="1">{
        order := new(aggregate.Order)
        err := c.orderRepository.Get(ctx, cmd.ReferenceOrderID, order)

        if err != nil </span><span class="cov8" title="1">{
                return enums.Autocapture, err
        }</span>

        <span class="cov8" title="1">if cmd.Status.IsFailure() </span><span class="cov8" title="1">{
                order.OrderPaymentFailed(command.NewCreatePaymentOrderFailCommand(
                        cmd.ReferenceOrderID,
                        cmd.PaymentID,
                        cmd.PaymentReason,
                        cmd.Status.String(),
                ))
        }</span> else<span class="cov8" title="1"> if cmd.Status.IsAuthorized() </span><span class="cov8" title="1">{
                order.OrderPaymentAuthorized(command.NewCreatePaymentOrderAuthorizedCommand(
                        cmd.ReferenceOrderID,
                        cmd.PaymentID,
                        cmd.AuthorizationCode,
                        cmd.Status.String(),
                        command.CardData{
                                CardBrand: cmd.PaymentCard.CardBrand,
                                CardLast4: cmd.PaymentCard.CardLast4,
                                CardType:  cmd.PaymentCard.CardType,
                        },
                ))
        }</span> else<span class="cov8" title="1"> {
                order.OrderPaymentProcessed(command.NewCreatePaymentOrderProcessedCommand(
                        cmd.ReferenceOrderID,
                        cmd.PaymentID,
                        cmd.AuthorizationCode,
                        cmd.Status.String(),
                        command.CardData{
                                CardBrand: cmd.PaymentCard.CardBrand,
                                CardLast4: cmd.PaymentCard.CardLast4,
                                CardType:  cmd.PaymentCard.CardType,
                        },
                ))
        }</span>

        <span class="cov8" title="1">paymentOrder, err := c.paymentOrderReadRepository.GetPaymentOrderByReference(ctx, cmd.ReferenceOrderID,
                cmd.PaymentID, order.EnterpriseID)
        if err != nil </span><span class="cov8" title="1">{
                return enums.Autocapture, err
        }</span>

        <span class="cov8" title="1">paymentOrder.SetStatus(enums.PaymentStatus(order.Status.Get()))
        paymentOrder.SetAuthorizationCode(cmd.AuthorizationCode)

        err = c.paymentOrderWriteRepository.UpdatePaymentOrder(ctx, paymentOrder)
        if err != nil </span><span class="cov8" title="1">{
                return enums.Autocapture, err
        }</span>

        <span class="cov8" title="1">orderEntity, err := c.orderReadRepository.GetOrderByReferenceID(ctx, cmd.ReferenceOrderID, order.EnterpriseID)
        if err != nil </span><span class="cov0" title="0">{
                return enums.Autocapture, err
        }</span>

        <span class="cov8" title="1">orderEntity.SetStatus(order.Status.Get())

        err = c.orderWriteRepository.UpdateOrder(ctx, orderEntity)

        if err != nil </span><span class="cov8" title="1">{
                return enums.Autocapture, err
        }</span>

        <span class="cov8" title="1">err = c.orderRepository.Save(ctx, order)

        if err != nil </span><span class="cov8" title="1">{
                return enums.Autocapture, err
        }</span>

        <span class="cov8" title="1">return enums.PaymentFlowEnum(paymentOrder.PaymentFlow), nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package pdf_generator

import (
        "context"
        "io"
        "os"
        "path/filepath"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_receipt/interfaces"
)

const (
        receiptPaymentHtmlPath = "assets/"
        filename               = "receipt-payment.html"
)

type ReceiptPaymentGeneratorImpl struct {
        pdfUtil interfaces.PDFUtilInterface
}

// NewReceiptPaymentGeneratorImpl creates a new ReceiptPaymentGeneratorImpl
func NewReceiptPaymentGeneratorImpl() interfaces.ReceiptPaymentGenerator <span class="cov8" title="1">{
        baseDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                baseDir = "."
        }</span>

        <span class="cov8" title="1">templatePath := filepath.Join(baseDir, receiptPaymentHtmlPath)

        return &amp;ReceiptPaymentGeneratorImpl{
                pdfUtil: NewPDFUtil(templatePath),
        }</span>
}

func (g *ReceiptPaymentGeneratorImpl) GenerateReceiptPaymentPDF(ctx context.Context, receiptData interfaces.ReceiptData) (io.Reader, error) <span class="cov8" title="1">{
        dataMap := receiptData.ToMap()

        return g.pdfUtil.GeneratePDF(ctx, filename, dataMap)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package pdf_generator

import (
        "bytes"
        "context"
        "encoding/base64"
        "html/template"
        "io"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/chromedp/cdproto/page"
        "github.com/chromedp/chromedp"
)

type PDFUtil struct {
        BasePath string
}

// NewPDFUtil creates a new PDFUtil instance.
func NewPDFUtil(basePath string) *PDFUtil <span class="cov8" title="1">{
        return &amp;PDFUtil{BasePath: basePath}
}</span>

// embedImages replaces &lt;img src="…"&gt; references that point to local files
// with data‑URI versions so the HTML is fully self‑contained.
func (p *PDFUtil) embedImages(htmlContent string) (string, error) <span class="cov8" title="1">{
        re := regexp.MustCompile(`&lt;img[^&gt;]+src="([^"]+)"[^&gt;]*&gt;`)
        matches := re.FindAllStringSubmatch(htmlContent, -1)

        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">imgSrc := match[1]

                if strings.HasPrefix(imgSrc, "data:") || strings.HasPrefix(imgSrc, "http") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">imgPath := filepath.Join(p.BasePath, imgSrc)
                imgData, err := os.ReadFile(imgPath)
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>

                <span class="cov8" title="1">mimeType := "image/png"
                switch </span>{
                case strings.HasSuffix(imgSrc, ".jpg"), strings.HasSuffix(imgSrc, ".jpeg"):<span class="cov8" title="1">
                        mimeType = "image/jpeg"</span>
                case strings.HasSuffix(imgSrc, ".gif"):<span class="cov8" title="1">
                        mimeType = "image/gif"</span>
                case strings.HasSuffix(imgSrc, ".svg"):<span class="cov8" title="1">
                        mimeType = "image/svg+xml"</span>
                }

                <span class="cov8" title="1">dataURI := "data:" + mimeType + ";base64," + base64.StdEncoding.EncodeToString(imgData)
                htmlContent = strings.ReplaceAll(htmlContent, `src="`+imgSrc+`"`, `src="`+dataURI+`"`)</span>
        }
        <span class="cov8" title="1">return htmlContent, nil</span>
}

// GeneratePDF renders the given template with the provided data and returns
// an io.Reader that streams the resulting PDF.
func (p *PDFUtil) GeneratePDF(
        ctx context.Context,
        htmlPath string,
        data map[string]string,
) (io.Reader, error) <span class="cov8" title="1">{

        tmpl, err := template.ParseFiles(filepath.Join(p.BasePath, htmlPath))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var htmlBuf bytes.Buffer
        if err = tmpl.Execute(&amp;htmlBuf, data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">htmlContent, err := p.embedImages(htmlBuf.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">timeoutCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        opts := append(chromedp.DefaultExecAllocatorOptions[:],
                chromedp.DisableGPU,
                chromedp.Headless,
                chromedp.NoSandbox,
        )

        allocCtx, cancel := chromedp.NewExecAllocator(timeoutCtx, opts...)
        defer cancel()

        taskCtx, cancel := chromedp.NewContext(allocCtx)
        defer cancel()

        var pdfBuffer []byte

        printParams := page.PrintToPDF().
                WithPrintBackground(true).
                WithPreferCSSPageSize(true).
                WithPaperWidth(4.17). // 400px at 96dpi
                WithPaperHeight(6.5)  // Estimated height based on content

        err = chromedp.Run(taskCtx,
                chromedp.Navigate("data:text/html;charset=utf-8,"+strings.ReplaceAll(htmlContent, "#", "%23")),
                chromedp.Sleep(1*time.Second),
                chromedp.ActionFunc(func(ctx context.Context) error </span><span class="cov8" title="1">{
                        var err error
                        pdfBuffer, _, err = printParams.Do(ctx)
                        return err
                }</span>),
        )

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return bytes.NewReader(pdfBuffer), nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package interfaces

import (
        "context"
        "io"
)

// PDFUtilInterface defines the interface for PDFUtil
type PDFUtilInterface interface {
        GeneratePDF(ctx context.Context, htmlPath string, data map[string]string) (io.Reader, error)
}

// ReceiptData represents the data needed for a payment receipt
type ReceiptData struct {
        ReceiptNumber    string
        TransactionID    string
        AmountPaid       string
        PaymentDate      string
        PaymentMethod    string
        PaymentReference string
}

// ToMap converts ReceiptData to map[string]string
func (r ReceiptData) ToMap() map[string]string <span class="cov8" title="1">{
        return map[string]string{
                "ReceiptNumber":    r.ReceiptNumber,
                "TransactionID":    r.TransactionID,
                "AmountPaid":       r.AmountPaid,
                "PaymentDate":      r.PaymentDate,
                "PaymentMethod":    r.PaymentMethod,
                "PaymentReference": r.PaymentReference,
        }
}</span>

// ReceiptPaymentGenerator defines the interface for generating payment receipts
type ReceiptPaymentGenerator interface {
        GenerateReceiptPaymentPDF(ctx context.Context, receiptData ReceiptData) (io.Reader, error)
}</pre>
		
		<pre class="file" id="file47" style="display: none">package use_case

import (
        "context"
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/common/adapters"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_receipt/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_receipt/interfaces"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/payment_receipt/command"
)

type generateReceiptPaymentUseCase struct {
        paymentReceiptRepository repository.PaymentReceiptRepository
        receiptGenerator         interfaces.ReceiptPaymentGenerator
        storageAdapter           adapters.StorageAdapter
}

func NewGenerateReceiptPaymentUseCase(
        paymentReceiptRepository repository.PaymentReceiptRepository,
        receiptGenerator interfaces.ReceiptPaymentGenerator,
        storageAdapter adapters.StorageAdapter,
) GenerateReceiptPaymentUseCase <span class="cov8" title="1">{
        return &amp;generateReceiptPaymentUseCase{
                paymentReceiptRepository: paymentReceiptRepository,
                receiptGenerator:         receiptGenerator,
                storageAdapter:           storageAdapter,
        }
}</span>

func (g *generateReceiptPaymentUseCase) Generate(oldCtx context.Context, cmd command.CreatePaymentReceiptCommand) (entities.PaymentReceipt, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[entities.PaymentReceipt](
                oldCtx,
                "GenerateReceiptUseCase.Generate",
                func(ctx context.Context, span decorators.Span) (entities.PaymentReceipt, error) </span><span class="cov8" title="1">{
                        existingReceipt, err := g.paymentReceiptRepository.GetByPaymentID(ctx, cmd.PaymentID)
                        if err == nil &amp;&amp; !existingReceipt.IsEmpty() </span><span class="cov8" title="1">{
                                return entities.PaymentReceipt{}, errors.NewPaymentReceiptAlreadyExistError(cmd.PaymentID)
                        }</span>

                        // Generate receipt PDF
                        <span class="cov8" title="1">receiptData := interfaces.ReceiptData{
                                ReceiptNumber:    cmd.PaymentID,
                                TransactionID:    cmd.PaymentID,
                                AmountPaid:       cmd.PaymentAmount.Value.String(),
                                PaymentDate:      cmd.PaymentDate,
                                PaymentMethod:    cmd.PaymentMethod.Type.String(),
                                PaymentReference: cmd.ReferenceOrderID,
                        }

                        pdfReader, err := g.receiptGenerator.GenerateReceiptPaymentPDF(ctx, receiptData)
                        if err != nil </span><span class="cov8" title="1">{
                                return entities.PaymentReceipt{}, err
                        }</span>

                        // Store the PDF
                        <span class="cov8" title="1">filePath := fmt.Sprintf("receipts/%s_%s.pdf", cmd.ReferenceOrderID, cmd.PaymentID)
                        fileURL, err := g.storageAdapter.Store(ctx, filePath, pdfReader)
                        if err != nil </span><span class="cov8" title="1">{
                                return entities.PaymentReceipt{}, err
                        }</span>

                        <span class="cov8" title="1">newReceipt := entities.NewPaymentReceiptEntity(cmd).WithReceiptURL(fileURL)

                        err = g.paymentReceiptRepository.CreatePaymentReceipt(ctx, newReceipt)
                        if err != nil </span><span class="cov8" title="1">{
                                return entities.PaymentReceipt{}, err
                        }</span>

                        <span class="cov8" title="1">return newReceipt, nil</span>
                })
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package models

import "github.com/shopspring/decimal"

type RefundAdapterModel struct {
        Amount    decimal.Decimal
        PaymentID string
        OrderID   string
}

func NewRefundModel(amount decimal.Decimal, paymentID, orderID string) RefundAdapterModel <span class="cov8" title="1">{
        return RefundAdapterModel{
                Amount:    amount,
                PaymentID: paymentID,
                OrderID:   orderID,
        }
}</span>

type RefundsAdapterModel struct {
        Refunds []RefundAdapterModel
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package adapters

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/adapters/models"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"

        repositoryPaymentOrder "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/response"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/refund/entities"
)

type PartialRefundAdapterIF interface {
        PartialRefund(ctx context.Context,
                refund models.RefundAdapterModel,
                refundReason string) (response.RefundResponseDTO, error)
}

type PartialRefundAdapter struct {
        deunaRefundResource  resources.DeunaRefundResourceIF
        writeRepository      repository.RefundWriteRepositoryIF
        deunaOrderRepository repositoryPaymentOrder.DeunaOrderRepository
}

func NewPartialRefundAdapter(
        deunaRefundResource resources.DeunaRefundResourceIF,
        writeRepository repository.RefundWriteRepositoryIF,
        deunaOrderRepo repositoryPaymentOrder.DeunaOrderRepository,
) PartialRefundAdapterIF <span class="cov8" title="1">{
        return &amp;PartialRefundAdapter{
                deunaRefundResource:  deunaRefundResource,
                writeRepository:      writeRepository,
                deunaOrderRepository: deunaOrderRepo,
        }
}</span>

func (a *PartialRefundAdapter) PartialRefund(
        ctx context.Context,
        refund models.RefundAdapterModel,
        refundReason string,
) (response.RefundResponseDTO, error) <span class="cov8" title="1">{
        refundAmount := refund.Amount
        payload := utils.DeunaPartialRefundRequest{
                Amount: utils.NewDeunaAmount(refundAmount),
                Reason: refundReason,
        }

        orderToken, err := a.deunaOrderRepository.GetTokenByOrderAndPaymentID(
                ctx, refund.OrderID, refund.PaymentID,
        )

        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">_, err = a.deunaRefundResource.MakePartialRefund(ctx, payload, orderToken)

        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">refundEntity := entities.NewRefundEntityBuilder().
                WithPaymentID(refund.PaymentID).
                WithOrderID(refund.OrderID).
                WithAmount(refund.Amount).
                WithReason(refundReason).
                WithStatus(enums.PartiallyRefunded.String()).
                Build()

        err = a.writeRepository.Create(ctx, *refundEntity)
        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">return response.RefundResponseDTO{
                ReferenceOrderID: refund.OrderID,
                PaymentOrderID:   refund.PaymentID,
                Amount:           refund.Amount,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package adapters

import (
        "context"
        "fmt"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils"

        "github.com/shopspring/decimal"
        repositoryPaymentOrder "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/response"
        refundEntities "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/refund/entities"
)

type RefundAdapterIF interface {
        RefundPayment(ctx context.Context,
                paymentID string,
                orderID string,
                enterpriseID string,
                reason string,
        ) (response.RefundResponseDTO, error)
}

type RefundAdapter struct {
        deunaRefundResource  resources.DeunaRefundResourceIF
        writeRepository      repository.RefundWriteRepositoryIF
        deunaOrderRepository repositoryPaymentOrder.DeunaOrderRepository
}

func NewRefundAdapter(
        deunaRefundResource resources.DeunaRefundResourceIF,
        writeRepository repository.RefundWriteRepositoryIF,
        deunaOrderRepository repositoryPaymentOrder.DeunaOrderRepository,
) RefundAdapterIF <span class="cov8" title="1">{
        return &amp;RefundAdapter{
                deunaRefundResource:  deunaRefundResource,
                writeRepository:      writeRepository,
                deunaOrderRepository: deunaOrderRepository,
        }
}</span>

func (r *RefundAdapter) RefundPayment(ctx context.Context,
        paymentID string,
        orderID string,
        enterpriseID string,
        reason string,
) (response.RefundResponseDTO, error) <span class="cov8" title="1">{
        orderToken, err := r.deunaOrderRepository.GetTokenByOrderAndPaymentID(
                ctx, orderID, paymentID,
        )

        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">refundResponse, err := r.deunaRefundResource.MakeTotalRefund(
                ctx,
                utils.DeunaTotalRefundRequest{
                        Reason: reason,
                },
                orderToken,
        )

        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">amountRefund, err := decimal.NewFromString(refundResponse.Data.RefundAmount.Amount)

        if err != nil </span><span class="cov0" title="0">{
                return response.RefundResponseDTO{}, fmt.Errorf("failed to parse refund amount: %w", err)
        }</span>

        // save refund in the database
        <span class="cov8" title="1">refundEntity := refundEntities.NewRefundEntityBuilder().
                WithPaymentID(paymentID).
                WithOrderID(orderID).
                WithEnterpriseID(enterpriseID).
                WithReason(reason).
                WithStatus(refundResponse.Data.Status).
                WithAmount(utils.DeunaAmountToAmount(amountRefund.IntPart())).
                Build()

        err = r.writeRepository.Create(ctx, *refundEntity)
        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">return response.RefundResponseDTO{
                ReferenceOrderID: orderID,
                PaymentOrderID:   paymentID,
                Amount:           utils.DeunaAmountToAmount(amountRefund.IntPart()),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package use_cases

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/event_store"
        paymentOrderRepository "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        adapters "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/adapters"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/adapters/models"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/response"
)

type PartialRefundUseCaseIF interface {
        PartialRefund(ctx context.Context, refund command.CreatePartialPaymentRefundCommand, enterpriseID string) (response.RefundResponseDTO, error)
}

type PartialRefundUse struct {
        repository                  event_store.OrderEventRepository
        partialRefundAdapter        adapters.PartialRefundAdapterIF
        paymentOrderReadRepository  paymentOrderRepository.GetPaymentOrderByReferenceIF
        paymentOrderWriteRepository paymentOrderRepository.PaymentOrderRepositoryIF
        orderReadRepository         repository.OrderReadRepositoryIF
        orderWriteRepository        repository.OrderWriteRepositoryIF
}

func NewPartialRefundUse(repository event_store.OrderEventRepository,
        partialRefundAdapter adapters.PartialRefundAdapterIF,
        paymentOrderReadRepository paymentOrderRepository.GetPaymentOrderByReferenceIF,
        paymentOrderWriteRepository paymentOrderRepository.PaymentOrderRepositoryIF,
        orderReadRepository repository.OrderReadRepositoryIF,
        orderWriteRepository repository.OrderWriteRepositoryIF,
) PartialRefundUseCaseIF <span class="cov8" title="1">{
        return &amp;PartialRefundUse{
                repository:                  repository,
                partialRefundAdapter:        partialRefundAdapter,
                paymentOrderReadRepository:  paymentOrderReadRepository,
                paymentOrderWriteRepository: paymentOrderWriteRepository,
                orderReadRepository:         orderReadRepository,
                orderWriteRepository:        orderWriteRepository,
        }
}</span>

func (u *PartialRefundUse) PartialRefund(ctx context.Context, refund command.CreatePartialPaymentRefundCommand, enterpriseID string) (response.RefundResponseDTO, error) <span class="cov8" title="1">{
        order := new(aggregate.Order)

        err := u.repository.Get(ctx, refund.ReferenceOrderID, order)
        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">validationErr := order.RefundPartialPayment(refund.PaymentOrderID, refund.Reason, refund.Amount)

        if validationErr != nil </span><span class="cov0" title="0">{
                return response.RefundResponseDTO{}, validationErr
        }</span>

        <span class="cov8" title="1">refundModel := models.NewRefundModel(refund.Amount, refund.PaymentOrderID, order.ID)

        refundResponse, err := u.partialRefundAdapter.PartialRefund(ctx, refundModel, enterpriseID)

        if err != nil </span><span class="cov0" title="0">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">paymentOrder, err := u.paymentOrderReadRepository.GetPaymentOrderByReference(ctx, refund.ReferenceOrderID,
                refund.PaymentOrderID, enterpriseID)
        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">paymentOrder.SetStatus(enums.PaymentStatus(order.Status.Get()))

        err = u.paymentOrderWriteRepository.UpdatePaymentOrder(ctx, paymentOrder)
        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">orderEntity, err := u.orderReadRepository.GetOrderByReferenceID(ctx, refund.ReferenceOrderID, enterpriseID)
        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">orderEntity.SetStatus(order.Status.Get())

        err = u.orderWriteRepository.UpdateOrder(ctx, orderEntity)

        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">err = u.repository.Save(ctx, order)
        if err != nil </span><span class="cov0" title="0">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">return refundResponse, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package use_cases

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/event_store"
        paymentOrderRepository "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/adapters"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/response"
)

type RefundTotalUseCaseIF interface {
        Refund(ctx context.Context, refund command.RefundTotalCommand, enterpriseID string) (response.RefundResponseDTO, error)
}

type RefundTotalUse struct {
        eventRepository             event_store.OrderEventRepository
        refundAdapter               adapters.RefundAdapterIF
        paymentOrderReadRepository  paymentOrderRepository.GetPaymentOrderByReferenceIF
        paymentOrderWriteRepository paymentOrderRepository.PaymentOrderRepositoryIF
        orderReadRepository         repository.OrderReadRepositoryIF
        orderWriteRepository        repository.OrderWriteRepositoryIF
}

func NewRefundTotalUseCase(
        repository event_store.OrderEventRepository,
        refundAdapter adapters.RefundAdapterIF,
        paymentOrderReadRepository paymentOrderRepository.GetPaymentOrderByReferenceIF,
        paymentOrderWriteRepository paymentOrderRepository.PaymentOrderRepositoryIF,
        orderReadRepository repository.OrderReadRepositoryIF,
        orderWriteRepository repository.OrderWriteRepositoryIF,
) RefundTotalUseCaseIF <span class="cov8" title="1">{
        return &amp;RefundTotalUse{
                eventRepository:             repository,
                refundAdapter:               refundAdapter,
                paymentOrderReadRepository:  paymentOrderReadRepository,
                paymentOrderWriteRepository: paymentOrderWriteRepository,
                orderReadRepository:         orderReadRepository,
                orderWriteRepository:        orderWriteRepository,
        }
}</span>

func (r *RefundTotalUse) Refund(
        ctx context.Context,
        refund command.RefundTotalCommand, enterpriseID string,
) (response.RefundResponseDTO, error) <span class="cov8" title="1">{
        order := new(aggregate.Order)

        err := r.eventRepository.Get(ctx, refund.ReferenceOrderID, order)
        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">_, err = order.RefundPayment(refund.PaymentOrderID, refund.Reason)

        if err != nil </span><span class="cov0" title="0">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">refundResponse, err := r.refundAdapter.RefundPayment(
                ctx, refund.PaymentOrderID, refund.ReferenceOrderID, enterpriseID, refund.Reason,
        )

        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">paymentOrder, err := r.paymentOrderReadRepository.GetPaymentOrderByReference(ctx, refund.ReferenceOrderID,
                refund.PaymentOrderID, enterpriseID)
        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">paymentOrder.SetStatus(enums.PaymentRefunded)

        err = r.paymentOrderWriteRepository.UpdatePaymentOrder(ctx, paymentOrder)
        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">orderEntity, err := r.orderReadRepository.GetOrderByReferenceID(ctx, refund.ReferenceOrderID, enterpriseID)
        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">orderEntity.SetStatus(enums.PaymentRefunded.String())

        err = r.orderWriteRepository.UpdateOrder(ctx, orderEntity)

        if err != nil </span><span class="cov8" title="1">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">err = r.eventRepository.Save(ctx, order)
        if err != nil </span><span class="cov0" title="0">{
                return response.RefundResponseDTO{}, err
        }</span>

        <span class="cov8" title="1">return refundResponse, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package deuna

import (
        "context"
        "errors"

        commonResources "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/common/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources"
        requestDeUna "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/utils"
        errorsBusiness "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/user/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/user/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/user/dto/response"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/user/entities"
)

type CreateUserUseDeunaAdapterIF interface {
        Create(ctx context.Context,
                request request.CreateUserRequest,
                enterpriseId string,
        ) (response.CreatedUserResponse, error)
        GetOrCreateUser(
                ctx context.Context,
                userID string,
                userType string,
                enterpriseID string,
        ) (response.CreatedUserResponse, error)
        GetUser(
                ctx context.Context,
                memberId string,
                enterpriseId string,
        ) (response.CreatedUserResponse, error)
        ValidateUser(
                ctx context.Context,
                request request.CreateUserRequest,
                enterpriseId string,
        ) (response.UserValidatedResponse, error)
}

type CreateUserUseDeunaAdapterImpl struct {
        member              commonResources.MemberAPIResourceIF
        deuna               resources.DeUnaUserResourceIF
        deunaAuth           resources.DeunaAuthResourceIF
        repository          repository.UserReadRepositoryIF
        userWriteRepository repository.UserWriteRepositoryIF
}

func NewCreateUserUseCases(
        member commonResources.MemberAPIResourceIF,
        deuna resources.DeUnaUserResourceIF,
        deunaAuth resources.DeunaAuthResourceIF,
        repository repository.UserReadRepositoryIF,
        userWriteRepository repository.UserWriteRepositoryIF,
) CreateUserUseDeunaAdapterIF <span class="cov8" title="1">{
        return &amp;CreateUserUseDeunaAdapterImpl{
                member:              member,
                deuna:               deuna,
                deunaAuth:           deunaAuth,
                repository:          repository,
                userWriteRepository: userWriteRepository,
        }
}</span>

func (u *CreateUserUseDeunaAdapterImpl) Create(
        ctx context.Context,
        request request.CreateUserRequest,
        enterpriseID string,
) (response.CreatedUserResponse, error) <span class="cov8" title="1">{
        userFound, err := u.member.GetUserProfileInfo(ctx, request.UserID, enterpriseID)
        if err != nil </span><span class="cov8" title="1">{
                return response.CreatedUserResponse{}, errorsBusiness.NewUserNotFoundError(request.UserID, err)
        }</span>

        <span class="cov8" title="1">email, err := utils.GetUserEmail(userFound)
        if err != nil </span><span class="cov8" title="1">{
                return response.CreatedUserResponse{}, errorsBusiness.NewUserEmailNotFoundError(request.UserID, err)
        }</span>

        <span class="cov8" title="1">userExists, err := u.repository.GetUserByEmail(ctx, email, enterpriseID)
        if err != nil </span><span class="cov0" title="0">{
                return response.CreatedUserResponse{}, err
        }</span>

        <span class="cov8" title="1">if !userExists.IsEmpty() </span><span class="cov8" title="1">{
                return response.CreatedUserResponse{},
                        errorsBusiness.NewUserAlreadyExistError(request.UserID, errors.New("user already exists"))
        }</span>

        <span class="cov8" title="1">phoneInfo, err := utils.GetUserPhone(userFound)
        if err != nil </span><span class="cov8" title="1">{
                return response.CreatedUserResponse{}, errorsBusiness.NewUserPhoneNotFoundError(request.UserID, err)
        }</span>

        <span class="cov8" title="1">billingInformation, err := utils.GetUserBillingInformation(userFound)
        if err != nil </span><span class="cov0" title="0">{
                return response.CreatedUserResponse{}, errorsBusiness.NewUserBillingInformationNotFoundError(request.UserID, err)
        }</span>

        <span class="cov8" title="1">emailAlias := requestDeUna.NewUserEmailAlias(request.UserID)

        newMember := requestDeUna.CreateUserRequestDTO{
                Email:     emailAlias,
                FirstName: userFound.FirstName,
                LastName:  userFound.LastName,
                Phone:     phoneInfo.Number,
        }

        memberCreatedDeUna, err := u.deuna.CreateUser(ctx, newMember)
        if err != nil </span><span class="cov8" title="1">{
                return response.CreatedUserResponse{}, errorsBusiness.NewUserFailCreateDeUnaError(request.UserID, err)
        }</span>

        <span class="cov8" title="1">newUser := entities.UserEntity{
                ID:             request.UserID,
                UserType:       request.UserType,
                ExternalUserID: memberCreatedDeUna.UserID,
                Email:          email,
                Address:        billingInformation.AddressLine,
                Zip:            billingInformation.ZipCode,
                City:           billingInformation.City,
                State:          billingInformation.State,
                CountryCode:    phoneInfo.CountryCode,
                Phone:          phoneInfo.Number,
                EnterpriseID:   enterpriseID,
                EmailAlias:     emailAlias,
        }

        user := entities.NewUserEntity(newUser)

        err = u.userWriteRepository.CreateUser(ctx, user)
        if err != nil </span><span class="cov8" title="1">{
                return response.CreatedUserResponse{}, errorsBusiness.NewuserCreateError(err)
        }</span>

        <span class="cov8" title="1">return response.CreatedUserResponse{
                ID:                    user.ID,
                FirstName:             userFound.FirstName,
                LastName:              userFound.LastName,
                Email:                 newUser.Email,
                ExternalUserID:        memberCreatedDeUna.UserID,
                PaymentsExternalEmail: newMember.Email,
        }, nil</span>
}

func (u *CreateUserUseDeunaAdapterImpl) GetOrCreateUser(
        ctx context.Context,
        userID string,
        userType string,
        enterpriseID string,
) (response.CreatedUserResponse, error) <span class="cov8" title="1">{
        user, err := u.repository.GetUserByID(ctx, userID, enterpriseID)
        if err != nil </span><span class="cov8" title="1">{
                return response.CreatedUserResponse{}, errorsBusiness.NewUserGettingDBError(userID, err)
        }</span>

        <span class="cov8" title="1">if !user.IsEmpty() </span><span class="cov8" title="1">{
                return response.CreatedUserResponse{
                        ID:                    user.ID,
                        Email:                 user.Email,
                        ExternalUserID:        user.ExternalUserID,
                        PaymentsExternalEmail: user.EmailAlias,
                }, nil
        }</span>

        <span class="cov8" title="1">newUser := request.CreateUserRequest{
                UserID: userID,
        }

        createdUser, err := u.Create(ctx, newUser, enterpriseID)
        if err != nil </span><span class="cov8" title="1">{
                return response.CreatedUserResponse{}, err
        }</span>

        <span class="cov8" title="1">return createdUser, nil</span>
}

func (u *CreateUserUseDeunaAdapterImpl) GetUser(
        ctx context.Context,
        memberId string,
        enterpriseId string,
) (response.CreatedUserResponse, error) <span class="cov8" title="1">{
        user, err := u.repository.GetUserByID(ctx, memberId, enterpriseId)

        if err != nil </span><span class="cov8" title="1">{
                return response.CreatedUserResponse{}, errorsBusiness.NewUserGettingDBError(memberId, err)
        }</span>

        <span class="cov8" title="1">return response.CreatedUserResponse{
                ID:             user.ID,
                Email:          user.Email,
                ExternalUserID: user.ExternalUserID,
        }, nil</span>
}

func (u *CreateUserUseDeunaAdapterImpl) ValidateUser(
        ctx context.Context,
        request request.CreateUserRequest,
        enterpriseId string,
) (response.UserValidatedResponse, error) <span class="cov8" title="1">{
        user, err := u.GetOrCreateUser(ctx, request.UserID, request.UserType, enterpriseId)

        if err != nil </span><span class="cov8" title="1">{
                return response.UserValidatedResponse{}, err
        }</span>

        <span class="cov8" title="1">externalAuthReq := requestDeUna.DeunaAuthUserRequestDTO{
                Email: user.PaymentsExternalEmail,
        }

        externalAuthResponse, err := u.deunaAuth.AuthUser(
                ctx,
                externalAuthReq,
        )

        if err != nil </span><span class="cov8" title="1">{
                return response.UserValidatedResponse{}, errorsBusiness.NewUserFailCreateDeUnaError(request.UserID, err)
        }</span>

        <span class="cov8" title="1">return response.UserValidatedResponse{
                ID:                user.ID,
                Email:             user.Email,
                ExternalUserID:    user.ExternalUserID,
                ExternalAuthToken: externalAuthResponse.AuthToken,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package adapters

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources/dto/request"
        errorsBusiness "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/user/errors"
)

type DeunaLoginAdapter interface {
        Login(ctx context.Context, userId string) (string, error)
        LoginWitUserID(ctx context.Context, userId, enterpriseID string) (string, error)
}

type DeunaLoginAdapterImpl struct {
        client     resources.DeunaLoginResourceIF
        clientAuth resources.DeunaAuthResourceIF
        repository repository.UserReadRepositoryIF
}

func NewDeunaLoginAdapter(
        client resources.DeunaLoginResourceIF,
        repository repository.UserReadRepositoryIF,
        clientAuth resources.DeunaAuthResourceIF,
) DeunaLoginAdapter <span class="cov0" title="0">{
        return &amp;DeunaLoginAdapterImpl{
                client:     client,
                repository: repository,
                clientAuth: clientAuth,
        }
}</span>

func (u *DeunaLoginAdapterImpl) Login(ctx context.Context, userId string) (string, error) <span class="cov8" title="1">{
        tokenResponse, err := u.client.Login(ctx, request.LoginUserDeUnaRequestDTO{
                UserID: userId,
        })
        if err != nil </span><span class="cov8" title="1">{
                return "", errorsBusiness.NewLoginError(userId, err)
        }</span>

        <span class="cov8" title="1">return tokenResponse.Token, nil</span>
}

func (u *DeunaLoginAdapterImpl) LoginWitUserID(ctx context.Context, userId, enterpriseID string) (string, error) <span class="cov0" title="0">{
        user, err := u.repository.GetUserByID(ctx, userId, enterpriseID)

        if err != nil </span><span class="cov0" title="0">{
                return "", errorsBusiness.NewUserNotFoundError(userId, err)
        }</span>

        <span class="cov0" title="0">tokenResponse, err := u.clientAuth.AuthUser(ctx, request.DeunaAuthUserRequestDTO{
                Email: user.EmailAlias,
        })

        if err != nil </span><span class="cov0" title="0">{
                return "", errorsBusiness.NewLoginError(userId, err)
        }</span>

        <span class="cov0" title="0">return tokenResponse.AuthToken, nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package request

import (
        "fmt"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"
)

type CreateUserRequestDTO struct {
        Email            string `json:"email"`
        FirstName        string `json:"first_name"`
        LastName         string `json:"last_name"`
        Phone            string `json:"phone"`
        IdentityDocument string `json:"identity_document"`
}

func NewUserEmailAlias(userID string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s@%s", userID, config.Config().App.ClubhubMainHost)
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package utils

import (
        "errors"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources/dto/response"
)

func GetMainEmailMember(emails []response.EmailDTO) (string, error) <span class="cov0" title="0">{
        for _, e := range emails </span><span class="cov0" title="0">{
                if e.IsDefault </span><span class="cov0" title="0">{
                        return e.Email, nil
                }</span>
        }

        <span class="cov0" title="0">return "", errors.New("main email not found")</span>
}

func GetMainPhoneMember(phones []response.PhoneDTO) (string, error) <span class="cov0" title="0">{
        for _, p := range phones </span><span class="cov0" title="0">{
                if p.IsDefault </span><span class="cov0" title="0">{
                        return p.Number, nil
                }</span>
        }

        <span class="cov0" title="0">return "", errors.New("main phone not found")</span>
}

func GetBillingInformationMember(billingInformation response.BillingInformationDTO) (response.BillingInformationDTO, error) <span class="cov0" title="0">{

        if billingInformation != (response.BillingInformationDTO{}) </span><span class="cov0" title="0">{
                return billingInformation, nil
        }</span>

        <span class="cov0" title="0">return response.BillingInformationDTO{}, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package utils

import (
        "errors"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources/dto/response"
)

func GetUserEmail(res response.UserProfileInfoDTO) (string, error) <span class="cov8" title="1">{
        if res.Email != "" </span><span class="cov8" title="1">{
                return res.Email, nil
        }</span>

        <span class="cov8" title="1">return "", errors.New("user email not found")</span>
}

func GetUserPhone(res response.UserProfileInfoDTO) (response.PhoneInfo, error) <span class="cov8" title="1">{
        if res.PrimaryPhone.Number != "" </span><span class="cov8" title="1">{
                return res.PrimaryPhone, nil
        }</span>

        <span class="cov8" title="1">if res.SecondaryPhone.Number != "" </span><span class="cov0" title="0">{
                return res.SecondaryPhone, nil
        }</span>

        <span class="cov8" title="1">return response.PhoneInfo{}, errors.New("user phone not found")</span>
}

func GetUserBillingInformation(response response.UserProfileInfoDTO) (response.AddressInfo, error) <span class="cov8" title="1">{
        return response.Address, nil
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package utils

import (
        "fmt"

        "github.com/biter777/countries"
)

func IsValidCountryCode(code string) bool <span class="cov8" title="1">{
        country := countries.ByName(code)
        return country != countries.Unknown &amp;&amp; country != countries.None
}</span>

func GetCountryIso3ByCode(code string) string <span class="cov8" title="1">{
        country := countries.ByName(code)
        return country.Alpha3()
}</span>

func GetCountryIso2ByCode(code string) string <span class="cov0" title="0">{
        country := countries.ByName(code)
        return country.Alpha2()
}</span>

func RemoveDuplicateCurrencies(currencies []string) []string <span class="cov8" title="1">{
        uniqueCurrencies := make(map[string]struct{})
        filteredCurrencies := []string{}

        for _, currency := range currencies </span><span class="cov8" title="1">{
                if _, exists := uniqueCurrencies[currency]; !exists </span><span class="cov8" title="1">{
                        uniqueCurrencies[currency] = struct{}{}
                        filteredCurrencies = append(filteredCurrencies, currency)
                }</span>
        }

        <span class="cov8" title="1">return filteredCurrencies</span>
}

func ValidateCurrencies(currencies []string) error <span class="cov8" title="1">{
        for _, currency := range currencies </span><span class="cov8" title="1">{
                if !IsValidCurrencyCode(currency) </span><span class="cov8" title="1">{
                        return fmt.Errorf("currency %s is not valid", currency)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package utils

import "github.com/biter777/countries"

func IsValidCurrencyCode(code string) bool <span class="cov8" title="1">{
        currencyFound := countries.CurrencyCodeByName(code)
        return currencyFound != countries.CurrencyUnknown
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package enums

import "strings"

type StatusType string

const (
        Default  StatusType = "default"
        Fault    StatusType = "fault"
        Expired  StatusType = "expired"
        Blocked  StatusType = "blocked"
        Active   StatusType = "active"
        Inactive StatusType = "inactive"
)

func (a StatusType) String() string <span class="cov8" title="1">{
        return strings.ToLower(string(a))
}</span>

func (a StatusType) IsValid() bool <span class="cov8" title="1">{
        switch a </span>{
        case Default, Fault, Expired, Blocked, Active, Inactive:<span class="cov8" title="1">
                return true</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package errors

import (
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const createCardError = "CREATE_CARD_ERROR"

func NewCreateCardError(err error) error <span class="cov0" title="0">{
        msg := "error creating card DEUNA service"
        return domain.WrapBusinessError(err, createCardError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package errors

import (
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const createCardDBError = "CREATE_CARD_DB_ERROR"

func NewCreateCardDBError(err error) error <span class="cov8" title="1">{
        msg := "error creating card db"
        return domain.WrapBusinessError(err, createCardDBError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package errors

import (
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
        enums "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card"
)

const deleteCardError = "DELETE_CARD_ERROR"

func NewDeleteCardError(provider enums.Providers, err error) error <span class="cov8" title="1">{
        msg := "error deleting card " + string(provider) + " service"
        return domain.WrapBusinessError(err, deleteCardError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package errors

import (
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const deleteCardDBError = "DELETE_CARD_DB_ERROR"

func NewDeleteCardDBError(err error) error <span class="cov8" title="1">{
        msg := "error deleting card db"
        return domain.WrapBusinessError(err, deleteCardDBError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package errors

import (
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const CardErrorGetDB = "CARD_ERROR_GET_DB"

func NewCardErrorGetDB(err error) error <span class="cov8" title="1">{
        msg := "error getting card from database"
        return domain.WrapBusinessError(err, CardErrorGetDB, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package errors

import (
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const CardAlreadyExists = "CARD_ALREADY_EXISTS"

func NewCardIsAlreadyExists(err error) error <span class="cov0" title="0">{
        return domain.WrapBusinessError(err, CardAlreadyExists, "the card already exists", nil)
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package errors

import (
        "fmt"

        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const cardIsNotFromMember = "Card is not from member %s "
const isNotCode = "CARD_IS_NOT_FROM_MEMBER"

func NewCardIsNotFromMember(memberID string, err error) error <span class="cov8" title="1">{
        msg := fmt.Sprintf(cardIsNotFromMember, memberID)
        return domain.WrapBusinessError(err, isNotCode, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package errors

import (
        "fmt"

        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const CardNotFound = "Card not found [ %s ]"
const CardNotFoundCode = "CARD_NOT_FOUND"

func NewCardNotFoundError(cardID string, err error) error <span class="cov8" title="1">{
        msg := fmt.Sprintf(CardNotFound, cardID)
        return domain.WrapBusinessError(err, CardNotFoundCode, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package errors

import (
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const (
        collectionCenterErrorNotFoundError = "COLLECTION_CENTER_NOT_FOUND"
        invalidCountryCodeError            = "INVALID_COUNTRY_CODE"
        invalidCurrencyCodeError           = "INVALID_CURRENCY_CODE"
        invalidAccountTypeError            = "INVALID_ACCOUNT_TYPE"
        invalidAssociatedOriginsError      = "INVALID_ASSOCIATED_ORIGINS"
        collectionAccountErrorDB           = "COLLECTION_ACCOUNT_ERROR_DB"
        currencyNoMatchError               = "CURRENCY_NO_MATCH"
)

func NewCollectionCenterNotFoundError(err error) error <span class="cov8" title="1">{
        msg := "collection center not found"
        return domain.WrapBusinessError(err, collectionCenterErrorNotFoundError, msg, err)
}</span>

func NewInvalidCountryCodeError(err error) error <span class="cov8" title="1">{
        msg := "invalid country code"
        return domain.WrapBusinessError(err, invalidCountryCodeError, msg, err)
}</span>

func NewInvalidCurrencyCodeError(err error) error <span class="cov8" title="1">{
        msg := "invalid currency code"
        return domain.WrapBusinessError(err, invalidCurrencyCodeError, msg, err)
}</span>

func NewInvalidAccountTypeError(err error) error <span class="cov8" title="1">{
        msg := "invalid account type"
        return domain.WrapBusinessError(err, invalidAccountTypeError, msg, err)
}</span>

func NewInvalidAssociatedOriginsError(err error) error <span class="cov8" title="1">{
        msg := "invalid associated origins"
        return domain.WrapBusinessError(err, invalidAssociatedOriginsError, msg, err)
}</span>

func NewCollectionAccountError(err error) error <span class="cov8" title="1">{
        msg := "error creating collection account"
        return domain.WrapBusinessError(err, collectionAccountErrorDB, msg, err)
}</span>

func NewCollectionAccountAlreadyExistsError(err error) error <span class="cov8" title="1">{
        msg := "collection account number already exists"
        return domain.WrapBusinessError(err, collectionAccountErrorDB, msg, err)
}</span>

func NewCollectionAccountFindByError(err error) error <span class="cov8" title="1">{
        msg := "error finding collection account"
        return domain.WrapBusinessError(err, collectionAccountErrorDB, msg, err)
}</span>

func NewCollectionAccountRouteAlreadyExist(err error) error <span class="cov8" title="1">{
        msg := "collection account route already exists"
        return domain.WrapBusinessError(err, collectionAccountErrorDB, msg, err)
}</span>

func NewCollectionAccountNotFoundError(err error) error <span class="cov8" title="1">{
        msg := "collection account not found"
        return domain.WrapBusinessError(err, collectionAccountErrorDB, msg, err)
}</span>

func NewCollectionAccountRouteCreateError(err error) error <span class="cov8" title="1">{
        msg := "error creating collection account route"
        return domain.WrapBusinessError(err, collectionAccountErrorDB, msg, err)
}</span>

func NewCollectionAccountCurrencyCodeError(err error) error <span class="cov8" title="1">{
        msg := "currency code does not match"
        return domain.WrapBusinessError(err, currencyNoMatchError, msg, err)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package entities

import (
        "time"

        "gitlab.com/clubhub.ai1/gommon/uid"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account_route/dto/request"
        "gorm.io/gorm"
)

type CollectionAccountRouteEntity struct {
        ID                  *uid.UniqueID `gorm:"type:varchar(14);primaryKey"`
        CollectionAccountID string
        CountryCode         string
        CurrencyCode        string
        EnterpriseID        string
        DisabledAt          *time.Time
        AssociatedOrigin    string
        gorm.Model
}

func (c CollectionAccountRouteEntity) IsEmpty() bool <span class="cov8" title="1">{
        return c.ID == nil
}</span>

func (CollectionAccountRouteEntity) TableName() string <span class="cov8" title="1">{
        return "collection_account_route"
}</span>

func NewCollectionAccountRouteEntity(
        request request.CollectionAccountRouteRequest, enterpriseId string,
) CollectionAccountRouteEntity <span class="cov8" title="1">{
        return CollectionAccountRouteEntity{
                ID:                  uid.GenerateID(),
                CollectionAccountID: request.CollectionAccountID,
                CountryCode:         request.CountryCode,
                CurrencyCode:        request.CurrencyCode,
                EnterpriseID:        enterpriseId,
                AssociatedOrigin:    request.AssociatedOrigin.String(),
        }
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package entities

import (
        "github.com/lib/pq"
        "gitlab.com/clubhub.ai1/gommon/uid"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_center/dto/request"
        "gorm.io/gorm"
)

type CollectionCenterEntity struct {
        ID                  *uid.UniqueID `gorm:"type:varchar(14);primaryKey"`
        Name                string
        AvailableCurrencies pq.StringArray `gorm:"type:text[]"` //
        Description         string
        EnterpriseID        string
        gorm.Model
}

func (CollectionCenterEntity) TableName() string <span class="cov8" title="1">{
        return "collection_center"
}</span>

func NewCollectionCenterEntity(
        collectionCenter request.CollectionCenterRequest,
        enterpriseId string,
) CollectionCenterEntity <span class="cov8" title="1">{
        id := uid.GenerateID()

        return CollectionCenterEntity{
                ID:                  id,
                Name:                collectionCenter.Name,
                AvailableCurrencies: collectionCenter.AvailableCurrencies,
                Description:         collectionCenter.Description,
                EnterpriseID:        enterpriseId,
        }
}</span>

func (c CollectionCenterEntity) IsEmpty() bool <span class="cov8" title="1">{
        return c.ID == nil
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package entities

import (
        "gitlab.com/clubhub.ai1/gommon/uid"
)

type CollectionCenterPaymentMethodEntity struct {
        CollectionCenterID *uid.UniqueID `gorm:"column:collection_center_id"`
        PaymentMethodID    *uid.UniqueID `gorm:"column:payment_method_id"`
}

func NewCollectionCenterPaymentMethodEntity(
        collectionCenterId,
        paymentMethodId *uid.UniqueID,
) CollectionCenterPaymentMethodEntity <span class="cov0" title="0">{
        return CollectionCenterPaymentMethodEntity{
                CollectionCenterID: collectionCenterId,
                PaymentMethodID:    paymentMethodId,
        }
}</span>

func (c CollectionCenterPaymentMethodEntity) TableName() string <span class="cov0" title="0">{
        return "collection_center_payment_method"
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package entities

import (
        "reflect"
        "time"

        "gitlab.com/clubhub.ai1/gommon/uid"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_concept/dto/request"
        "gorm.io/gorm"
)

type PaymentConceptEntity struct {
        gorm.Model
        ID           *uid.UniqueID `gorm:"type:varchar(14);primaryKey"`
        Name         string
        Code         string
        Description  string
        EnterpriseID string
}

func (p PaymentConceptEntity) IsEmpty() bool <span class="cov0" title="0">{
        return reflect.DeepEqual(p, PaymentConceptEntity{})
}</span>

func (PaymentConceptEntity) TableName() string <span class="cov0" title="0">{
        return "payment_concept"
}</span>

func NewPaymentConceptEntity(
        request request.PaymentConceptRequest,
        enterpriseId string,
) PaymentConceptEntity <span class="cov8" title="1">{
        return PaymentConceptEntity{
                ID:           uid.GenerateID(),
                Name:         request.Name,
                Code:         request.Code,
                Description:  request.Description,
                EnterpriseID: enterpriseId,
                Model: gorm.Model{
                        CreatedAt: time.Now(),
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package entities

import (
        "gitlab.com/clubhub.ai1/gommon/uid"
        "gorm.io/gorm"
)

type PaymentMethodEntity struct {
        ID           *uid.UniqueID `gorm:"type:varchar(14);primaryKey"`
        Name         string
        Code         string
        Description  string
        EnterpriseID string
        gorm.Model
}

func (p PaymentMethodEntity) TableName() string <span class="cov0" title="0">{
        return "payment_method"
}</span>

func NewPaymentMethodEntity(name, code, description, enterpriseId string) PaymentMethodEntity <span class="cov8" title="1">{
        return PaymentMethodEntity{
                ID:           uid.GenerateID(),
                Name:         name,
                Code:         code,
                Description:  description,
                EnterpriseID: enterpriseId,
        }
}</span>

type PaymentMethod struct {
        Type string `json:"type"` // CCData, TERMINAL, etc
        Card Card   `json:"card"`
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package entities

import (
        "errors"
        "time"

        "github.com/shopspring/decimal"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

type PaymentOrder struct {
        ID                string
        OriginType        value_objects.AssociatedOrigin
        Total             value_objects.CurrencyAmount
        TotalRefunded     value_objects.CurrencyAmount
        Status            enums.PaymentStatus
        Method            value_objects.PaymentMethod
        CreatedAt         time.Time
        UpdatedAt         time.Time
        CollectionAccount CollectionAccount
        AuthorizationCode string
        FailureReason     string
        ReceiptUrl        string
        PaymentFlow       string
        PaymentCard       CardData
}

type CardData struct {
        CardBrand string
        CardLast4 string
        CardType  string
}

func NewPaymentOrder(
        id string,
        originType value_objects.AssociatedOrigin,
        total value_objects.CurrencyAmount,
        method value_objects.PaymentMethod) PaymentOrder <span class="cov8" title="1">{
        return PaymentOrder{
                ID:                id,
                OriginType:        originType,
                Total:             total,
                Status:            enums.PaymentProcessing,
                CreatedAt:         time.Now(),
                UpdatedAt:         time.Now(),
                Method:            method,
                AuthorizationCode: "",
                FailureReason:     "",
                ReceiptUrl:        "",
                PaymentFlow:       enums.Autocapture.String(),
        }
}</span>

func (p PaymentOrder) Validate() error <span class="cov8" title="1">{
        if err := p.OriginType.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := p.Total.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !p.Status.IsValid() </span><span class="cov0" title="0">{
                return errors.New("status is not valid")
        }</span>

        <span class="cov8" title="1">if err := p.Method.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if p.Total.Value.LessThan(decimal.NewFromInt(0)) </span><span class="cov0" title="0">{
                return errors.New("total amount is not valid")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (p PaymentOrder) CanRefund() bool <span class="cov8" title="1">{
        return (p.Status == enums.PartiallyRefunded || p.Status == enums.PaymentProcessed) &amp;&amp;
                p.GetTotalRefundable().GreaterThan(decimal.Zero)
}</span>

func (p *PaymentOrder) GetTotalRefundable() decimal.Decimal <span class="cov8" title="1">{
        return p.Total.Value.Sub(p.TotalRefunded.Value)
}</span>

func (p *PaymentOrder) GetTotalRefunded() decimal.Decimal <span class="cov0" title="0">{
        return p.TotalRefunded.Value
}</span>

func (p *PaymentOrder) CanRefundAmount(amount decimal.Decimal) bool <span class="cov8" title="1">{
        if p.Status == enums.PaymentProcessed </span><span class="cov8" title="1">{
                return !p.TotalRefunded.Value.GreaterThan(p.Total.Value.Sub(amount))
        }</span>

        <span class="cov0" title="0">return true</span>
}

func (p *PaymentOrder) SetPaymentCard(paymentCard CardData) <span class="cov0" title="0">{
        p.PaymentCard = paymentCard
}</span>

func (p *PaymentOrder) SetPaymentStatus(status enums.PaymentStatus) <span class="cov0" title="0">{
        p.Status = status
}</span>

func (p *PaymentOrder) SetReceiptUrl(invoiceUrl string) <span class="cov0" title="0">{
        p.ReceiptUrl = invoiceUrl
}</span>

func (p *PaymentOrder) SetPaymentFlow(paymentFlow string) <span class="cov0" title="0">{
        p.PaymentFlow = paymentFlow
}</span>

func (p PaymentOrder) Equals(other PaymentOrder) bool <span class="cov0" title="0">{
        return p.ID == other.ID
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package entities

import (
        "fmt"
        "github.com/shopspring/decimal"
        "gitlab.com/clubhub.ai1/gommon/uid"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/payment_receipt/command"
        "time"
)

var paymentReceiptIdPrefix = "RCPT"

type PaymentReceipt struct {
        ID                  string
        PaymentReceiptID    string
        UserID              string
        EnterpriseID        string
        Email               string
        ReferenceOrderID    string
        PaymentID           string
        PaymentStatus       string
        PaymentAmount       decimal.Decimal
        PaymentCountryCode  string
        PaymentCurrencyCode string
        PaymentMethod       enums.PaymentMethodEnum
        PaymentDate         string
        FileURL             string
        CreatedAt           time.Time
        UpdatedAt           time.Time
}

func (p PaymentReceipt) IsEmpty() bool <span class="cov8" title="1">{
        return p.ID == ""
}</span>

func NewPaymentReceiptEntity(cmd command.CreatePaymentReceiptCommand) PaymentReceipt <span class="cov8" title="1">{
        id := uid.GenerateID()

        return PaymentReceipt{
                ID:                  fmt.Sprintf("%s-%s", paymentReceiptIdPrefix, id.String()),
                PaymentReceiptID:    fmt.Sprintf("%s-%s", paymentReceiptIdPrefix, id.String()),
                UserID:              cmd.UserID,
                EnterpriseID:        cmd.EnterpriseID,
                Email:               cmd.Email,
                ReferenceOrderID:    cmd.ReferenceOrderID,
                PaymentID:           cmd.PaymentID,
                PaymentStatus:       cmd.PaymentStatus,
                PaymentAmount:       cmd.PaymentAmount.Value,
                PaymentCountryCode:  cmd.PaymentCountry.Code,
                PaymentCurrencyCode: cmd.PaymentAmount.Code.Code,
                PaymentMethod:       cmd.PaymentMethod.Type,
                PaymentDate:         cmd.PaymentDate,
                CreatedAt:           cmd.CreatedAt.UTC(),
                UpdatedAt:           cmd.UpdatedAt.UTC(),
        }
}</span>

func (p PaymentReceipt) WithReceiptURL(url string) PaymentReceipt <span class="cov8" title="1">{
        p.FileURL = url
        return p
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package entities

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

type User struct {
        Type          value_objects.UserType
        ID            string
        userTypeAsStr string
}

func NewUser(userType value_objects.UserType, userID string) User <span class="cov8" title="1">{
        return User{
                Type:          userType,
                ID:            userID,
                userTypeAsStr: userType.String(),
        }
}</span>

func (u User) Equals(other User) bool <span class="cov0" title="0">{
        return u.Type.Equals(other.Type) &amp;&amp; u.ID == other.ID
}</span>

func (u User) Validate() error <span class="cov8" title="1">{
        if u.ID == "" </span><span class="cov8" title="1">{
                return errors.NewInvalidUserIDError(u.ID)
        }</span>

        <span class="cov8" title="1">if !u.Type.IsValid() </span><span class="cov0" title="0">{
                return errors.NewUnsupportedUserTypeError(u.userTypeAsStr)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package enums

import "strings"

type AccountType string

const (
        Concentrators AccountType = "CONCENTRATORS"
        Payers        AccountType = "PAYERS"
        Mixed         AccountType = "MIXED"
)

func (a AccountType) String() string <span class="cov8" title="1">{
        return strings.ToUpper(string(a))
}</span>

func (a AccountType) IsValid() bool <span class="cov8" title="1">{
        switch a </span>{
        case Concentrators, Payers, Mixed:<span class="cov8" title="1">
                return true</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package enums

import (
        "errors"
        "strings"
)

type AssociatedOrigin string

var ErrInvalidAssociatedOrigin = errors.New("invalid associated origin")

const (
        Downpayment AssociatedOrigin = "DOWNPAYMENT"
        Loan        AssociatedOrigin = "LOAN"
        Club        AssociatedOrigin = "CLUB"
        Booking     AssociatedOrigin = "BOOKING"
)

func (a AssociatedOrigin) String() string <span class="cov8" title="1">{
        return strings.ToUpper(string(a))
}</span>

func NewAssociatedOrigin(origin string) (AssociatedOrigin, error) <span class="cov8" title="1">{
        switch strings.ToUpper(origin) </span>{
        case "DOWNPAYMENT":<span class="cov8" title="1">
                return Downpayment, nil</span>
        case "LOAN":<span class="cov8" title="1">
                return Loan, nil</span>
        case "CLUB":<span class="cov8" title="1">
                return Club, nil</span>
        case "BOOKING":<span class="cov8" title="1">
                return Booking, nil</span>
        }

        <span class="cov8" title="1">return "", ErrInvalidAssociatedOrigin</span>
}

func (a AssociatedOrigin) IsValid() bool <span class="cov8" title="1">{
        switch a </span>{
        case Downpayment, Loan, Club, Booking:<span class="cov8" title="1">
                return true</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package enums

import (
        "errors"
        "strings"
)

type PaymentFlowEnum string

var ErrInvalidPaymentFlow = errors.New("invalid payment flow")

const (
        Autocapture PaymentFlowEnum = "AUTOCAPTURE"
        Capture     PaymentFlowEnum = "CAPTURE"
)

const (
        DebitCard  = "DEBIT_CARD"
        CreditCard = "CREDIT_CARD"

        AutoCapture   = "auto-capture"
        Authorization = "authorization"
)

func (p PaymentFlowEnum) String() string <span class="cov8" title="1">{
        return string(p)
}</span>

func NewPaymentFlowEnum(cardType string, allowCapture bool) (PaymentFlowEnum, error) <span class="cov8" title="1">{

        if strings.ToUpper(cardType) == DebitCard </span><span class="cov8" title="1">{
                return Autocapture, nil
        }</span>

        <span class="cov8" title="1">if strings.ToUpper(cardType) == CreditCard &amp;&amp; allowCapture </span><span class="cov8" title="1">{
                return Capture, nil
        }</span>

        <span class="cov8" title="1">if !allowCapture </span><span class="cov8" title="1">{
                return Autocapture, nil
        }</span>

        <span class="cov8" title="1">return "", ErrInvalidPaymentFlow</span>
}

func (p PaymentFlowEnum) IsValid() bool <span class="cov8" title="1">{
        switch p </span>{
        case Autocapture, Capture:<span class="cov8" title="1">
                return true</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (p PaymentFlowEnum) DeunaFlowType() (string, error) <span class="cov8" title="1">{
        switch p </span>{
        case Autocapture:<span class="cov8" title="1">
                return AutoCapture, nil</span>
        case Capture:<span class="cov8" title="1">
                return Authorization, nil</span>
        }

        <span class="cov8" title="1">return "", ErrInvalidPaymentFlow</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package enums

import (
        "errors"
        "strings"
)

type PaymentFlowActionEnum string

var ErrInvalidPaymentFlowAction = errors.New("invalid payment flow action")

const (
        CapturePayment PaymentFlowActionEnum = "CAPTURE"
        ReleasePayment PaymentFlowActionEnum = "RELEASE"
)

func (p PaymentFlowActionEnum) String() string <span class="cov8" title="1">{
        return string(p)
}</span>

func NewPaymentFlowActionEnum(action string) (PaymentFlowActionEnum, error) <span class="cov8" title="1">{
        switch strings.ToUpper(action) </span>{
        case CapturePayment.String():<span class="cov8" title="1">
                return CapturePayment, nil</span>
        case ReleasePayment.String():<span class="cov8" title="1">
                return ReleasePayment, nil</span>
        }

        <span class="cov8" title="1">return "", ErrInvalidPaymentFlowAction</span>
}

func (p PaymentFlowActionEnum) IsValid() bool <span class="cov8" title="1">{
        switch p </span>{
        case CapturePayment, ReleasePayment:<span class="cov8" title="1">
                return true</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (p PaymentFlowActionEnum) IsCapture() bool <span class="cov8" title="1">{
        return p == CapturePayment
}</span>

func (p PaymentFlowActionEnum) IsRelease() bool <span class="cov8" title="1">{
        return p == ReleasePayment
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package enums

import "errors"

type PaymentMethodEnum string

var ErrInvalidPaymentMethod = errors.New("invalid payment method")

const (
        CCMethod      PaymentMethodEnum = "CCData"
        PaymentDevice PaymentMethodEnum = "DEVICE"
        TokenCard     PaymentMethodEnum = "TOKEN_CARD"
)

func (p PaymentMethodEnum) String() string <span class="cov8" title="1">{
        return string(p)
}</span>

func NewPaymentMethodsFromString(status string) (PaymentMethodEnum, error) <span class="cov8" title="1">{
        switch status </span>{
        case CCMethod.String():<span class="cov8" title="1">
                return CCMethod, nil</span>
        case PaymentDevice.String():<span class="cov8" title="1">
                return PaymentDevice, nil</span>
        case TokenCard.String():<span class="cov8" title="1">
                return TokenCard, nil</span>
        }

        <span class="cov8" title="1">return "", ErrInvalidPaymentMethod</span>
}

func (p PaymentMethodEnum) IsValid() bool <span class="cov8" title="1">{
        switch p </span>{
        case CCMethod, PaymentDevice, TokenCard:<span class="cov8" title="1">
                return true</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package enums

import "errors"

type PaymentStatus string

var ErrInvalidPaymentStatus = errors.New("invalid payment status")

const (
        PaymentProcessing   PaymentStatus = "PROCESSING"
        PaymentNotProcessed PaymentStatus = "NOT_PROCESSED"
        PaymentProcessed    PaymentStatus = "PROCESSED"
        PaymentFailed       PaymentStatus = "FAILED"
        PaymentAuthorized   PaymentStatus = "AUTHORIZED"
        PaymentCanceled     PaymentStatus = "CANCELED"
        PaymentRefunded     PaymentStatus = "REFUNDED"
        PartiallyRefunded   PaymentStatus = "PARTIALLY_REFUNDED"
        PaymentVoided       PaymentStatus = "VOIDED"
        PaymentDenied       PaymentStatus = "DENIED"
)

func (p PaymentStatus) String() string <span class="cov8" title="1">{
        return string(p)
}</span>

func NewPaymentStatusFromString(status string) (PaymentStatus, error) <span class="cov8" title="1">{
        switch status </span>{
        case PaymentProcessing.String():<span class="cov8" title="1">
                return PaymentProcessing, nil</span>
        case PaymentProcessed.String():<span class="cov8" title="1">
                return PaymentProcessed, nil</span>
        case PaymentVoided.String():<span class="cov8" title="1">
                return PaymentCanceled, nil</span>
        case PaymentDenied.String():<span class="cov8" title="1">
                return PaymentDenied, nil</span>
        case PaymentRefunded.String():<span class="cov8" title="1">
                return PaymentRefunded, nil</span>
        case PaymentFailed.String():<span class="cov8" title="1">
                return PaymentFailed, nil</span>
        case PaymentNotProcessed.String():<span class="cov8" title="1">
                return PaymentNotProcessed, nil</span>
        case PartiallyRefunded.String():<span class="cov8" title="1">
                return PartiallyRefunded, nil</span>
        case PaymentAuthorized.String():<span class="cov8" title="1">
                return PaymentAuthorized, nil</span>
        case PaymentCanceled.String():<span class="cov0" title="0">
                return PaymentCanceled, nil</span>
        }

        <span class="cov8" title="1">return "", ErrInvalidPaymentStatus</span>
}

func (p PaymentStatus) IsFailure() bool <span class="cov8" title="1">{
        switch p </span>{
        case PaymentFailed, PaymentDenied, PaymentVoided:<span class="cov8" title="1">
                return true</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (p PaymentStatus) IsValid() bool <span class="cov8" title="1">{
        switch p </span>{
        case PaymentProcessing, PaymentProcessed, PaymentRefunded, PaymentAuthorized:<span class="cov8" title="1">
                return true</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (p PaymentStatus) IsProcessing() bool <span class="cov8" title="1">{
        return p == PaymentProcessing
}</span>

func (p PaymentStatus) IsPartiallyRefunded() bool <span class="cov8" title="1">{
        return p == PartiallyRefunded
}</span>

func (p PaymentStatus) IsProcessed() bool <span class="cov8" title="1">{
        return p == PaymentProcessed
}</span>

func (p PaymentStatus) IsAuthorized() bool <span class="cov8" title="1">{
        return p == PaymentAuthorized
}</span>

func (p PaymentStatus) IsCanceled() bool <span class="cov8" title="1">{
        switch p </span>{
        case PaymentCanceled, PaymentVoided:<span class="cov8" title="1">
                return true</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package enums

import "strings"

type StatusRoute string

const (
        Pending StatusRoute = "PENDING"
        Active  StatusRoute = "ACTIVE"
)

func (s StatusRoute) String() string <span class="cov8" title="1">{
        return strings.ToUpper(string(s))
}</span>

func (s StatusRoute) IsValid() bool <span class="cov8" title="1">{
        switch s </span>{
        case Pending, Active:<span class="cov8" title="1">
                return true</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package errors

import (
        "fmt"

        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const collectionAccountNotFoundError = "COLLECTION_ACCOUNT_NOT_FOUND"

func NewCollectionAccountNotFound() error <span class="cov8" title="1">{
        return domain.WrapBusinessError(fmt.Errorf("collection account not found"), collectionAccountNotFoundError, "collection account not found", map[string]interface{}{})
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package errors

import (
        "fmt"

        "github.com/shopspring/decimal"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const invalidAmountErrorCode = "INVALID_AMOUNT"

func NewInvalidAmountError(amount decimal.Decimal) error <span class="cov8" title="1">{
        err := fmt.Errorf("invalid amount: %v", amount)
        return domain.WrapBusinessError(err, invalidAmountErrorCode, err.Error(), map[string]interface{}{})
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">package errors

import (
        "errors"
        "fmt"

        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

var ErrInvalidCountryCode = errors.New("invalid country code")

const invalidCountryCode = "INVALID_COUNTRY_CODE"

func NewInvalidCountryCodeError(code string) error <span class="cov8" title="1">{
        return domain.WrapBusinessError(
                ErrInvalidCountryCode, invalidCountryCode, fmt.Sprintf("Invalid country code %s", code), map[string]interface{}{},
        )
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">package errors

import (
        "errors"
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

var ErrInvalidCurrencyCode = errors.New("invalid currency code")

const invalidCurrencyCode = "INVALID_CURRENCY_CODE"

func NewInvalidCurrencyCodeError(code string) error <span class="cov8" title="1">{
        return domain.WrapBusinessError(
                ErrInvalidCurrencyCode, invalidCurrencyCode, fmt.Sprintf("Invalid currency code %s", code), map[string]interface{}{},
        )
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package errors

import (
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const InvalidUserIDErrorCode = "INVALID_USER_ID"

func NewInvalidUserIDError(id string) error <span class="cov8" title="1">{
        err := fmt.Errorf("invalid user id: %s", id)
        return domain.WrapBusinessError(err, InvalidUserIDErrorCode, err.Error(), map[string]interface{}{})
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package errors

import (
        "fmt"

        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const orderAlreadyExistErrorCode = "ORDER_ALREADY_EXISTS"

func NewOrderAlreadyExistError(orderReferenceID string) error <span class="cov8" title="1">{
        err := fmt.Errorf("order %v already exists", orderReferenceID)
        return domain.WrapBusinessError(err, orderAlreadyExistErrorCode, err.Error(), map[string]interface{}{})
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package errors

import (
        "errors"

        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const orderCreateValidationError = "ORDER_CREATE_VALIDATION_ERROR"

var (
        ErrInvalidOrderID           = errors.New("invalid order ID")
        ErrInvalidOrderTotalAmount  = errors.New("invalid order total amount")
        ErrInvalidOrderPhoneNumber  = errors.New("invalid order phone number")
        ErrInvalidOrderUserType     = errors.New("invalid order user type")
        ErrInvalidOrderEnterpriseID = errors.New("invalid order enterprise ID")
)

func NewOrderCreateValidationError(err error) error <span class="cov8" title="1">{
        return domain.WrapBusinessError(err, orderCreateValidationError, "Order validation error", map[string]interface{}{})
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package errors

import (
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const OrderNotFoundErrorCode = "ORDER_NOT_FOUND"

func NewOrderNotFoundError(orderReferenceID string) error <span class="cov8" title="1">{
        err := fmt.Errorf("order %v not found", orderReferenceID)
        return domain.WrapBusinessError(err, OrderNotFoundErrorCode, err.Error(), nil)
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">package errors

import (
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const orderPaymentNotFoundCodeError = "ORDER_PAYMENT_NOT_FOUND_ERROR"

func NewOrderPaymentNotFoundError(orderID string, paymentID string) error <span class="cov8" title="1">{
        err := fmt.Errorf("no payment found for order ID %s and payment ID %s", orderID, paymentID)

        return domain.WrapBusinessError(err, orderPaymentNotFoundCodeError, err.Error(), map[string]interface{}{})
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package errors

import (
        "errors"

        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const paymentOrderCreateValidationError = "PAYMENT_ORDER_CREATE_VALIDATION_ERROR"

var (
        ErrInvalidPaymentOrderReferenceOrderID  = errors.New("invalid payment order reference order ID")
        ErrInvalidPaymentOrderUserType          = errors.New("invalid payment order user ID")
        ErrInvalidPaymentOrderUserID            = errors.New("invalid payment order user type")
        ErrInvalidPaymentOrderEnterpriseID      = errors.New("invalid payment order enterprise ID")
        ErrInvalidPaymentOrderPaymentMethodType = errors.New("invalid payment order payment method type")
)

func NewPaymentOrderValidationError(err error) error <span class="cov0" title="0">{
        return domain.WrapBusinessError(err, paymentOrderCreateValidationError, "Payment Order validation error", map[string]interface{}{})
}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">package errors

import (
        "fmt"

        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const paymentReceiptAlreadyExistErrorCode = "PAYMENT_RECEIPT_ALREADY_EXIST"

func NewPaymentReceiptAlreadyExistError(paymentID string) error <span class="cov8" title="1">{
        err := fmt.Errorf("payment receipt for payment %v already exists", paymentID)
        return domain.WrapBusinessError(err, paymentReceiptAlreadyExistErrorCode, err.Error(), map[string]interface{}{})
}</pre>
		
		<pre class="file" id="file96" style="display: none">package errors

import "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"

const refundCanNotAppliedCodeError = "REFUND_CAN_NOT_APPLIED_ERROR"

func NewRefundCanNotAppliedDueToPaymentStatusError() error <span class="cov8" title="1">{
        return domain.WrapBusinessError(nil, refundCanNotAppliedCodeError, "Payment status not processed", map[string]interface{}{})
}</span>

func NewRefundAmountIsGreaterThanTotalRefundableError() error <span class="cov8" title="1">{
        return domain.WrapBusinessError(nil, refundCanNotAppliedCodeError, "Refund amount is greater than total refundable", map[string]interface{}{})
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package errors

import (
        "errors"

        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const refundCreateValidationError = "REFUND_CREATE_VALIDATION_ERROR"

var (
        ErrInvalidRefundReferenceOrderID = errors.New("invalid refund reference order ID")
        ErrInvalidRefundPaymentOrderID   = errors.New("invalid refund payment order ID")
        ErrInvalidRefundReason           = errors.New("invalid refund reason")
)

func NewRefundCreateValidationError(err error) error <span class="cov8" title="1">{
        return domain.WrapBusinessError(err, refundCreateValidationError, "PartialRefund validation error", map[string]interface{}{})
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package errors

import (
        "errors"
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

var UnsupportedUserTypeErr = errors.New("unsuported user type")

const unsupportedUserTypeErrorCode = "UNSUPPORTED_USER_TYPE"

func NewUnsupportedUserTypeError(userType string) error <span class="cov0" title="0">{
        return domain.WrapBusinessError(
                UnsupportedUserTypeErr, unsupportedUserTypeErrorCode, fmt.Sprintf("Unsuported user type %s", userType), map[string]interface{}{},
        )
}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">package aggregate

import (
        "time"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events"
)

// Create initializes a new Order aggregate based on the provided CreateOrderCommand.
// It assigns the order a ReferenceID using the WithID method and then generates
// an appropriate event using the FromCreateOrderCommand function. The event is
// tracked using the TrackChange method.
//
// Parameters:
// - cmd: A CreateOrderCommand containing the necessary information to create an order.
//
// Returns:
// - *Order: A pointer to the newly created Order aggregate.
// - error: An error, if the order creation fails at any stage.
func Create(cmd command.CreateOrderCommand) (*Order, error) <span class="cov8" title="1">{
        o := new(Order)

        err := o.WithID(cmd.ReferenceID)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">event := events.NewOrderCreatedEventBuilder().
                SetID(cmd.ReferenceID).
                SetTotalAmount(cmd.TotalAmount).
                SetPhoneNumber(cmd.PhoneNumber).
                SetUser(cmd.User).
                SetCreatedAt(time.Now().UTC()).
                SetCountryCode(cmd.CountryCode).
                SetBillingAddress(cmd.BillingAddress).
                SetEnterpriseID(cmd.EnterpriseID).
                SetEmail(cmd.Email).
                SetMetadata(cmd.Metadata).
                SetWebhookUrl(cmd.WebhookUrl).
                SetAllowCapture(cmd.AllowCapture).
                Build()

        o.TrackChange(o, event)

        return o, nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package aggregate

import (
        "errors"
        "time"

        errors2 "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"

        "github.com/samber/lo"
        "github.com/shopspring/decimal"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"

        "gitlab.com/clubhub.ai1/go-libraries/eventsourcing"
        aggregate "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/common/eventsourcing"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events"
        vo "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

type Order struct {
        aggregate.AggregateRoot
        ID            string
        Currency      vo.CurrencyCode
        TotalAmount   vo.CurrencyAmount
        PhoneNumber   string
        User          entities.User
        Status        vo.OrderStatus
        CountryCode   vo.Country
        CreatedAt     time.Time
        OrderPayments []entities.PaymentOrder
        EnterpriseID  string
        Email         string
        Metadata      map[string]interface{}
        WebhookUrl    vo.WebhookUrl
        AllowCapture  bool
}

func (o *Order) StartProcessingOrderPayment(cmd command.CreatePaymentOrderCommand) error <span class="cov8" title="1">{
        if err := cmd.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !o.CanProcessPayment(cmd.Payment) </span><span class="cov8" title="1">{
                return errors.New("payment order cannot be added")
        }</span>

        <span class="cov8" title="1">event := events.FromProcessOrderCommand(cmd)

        o.TrackChange(o, event)

        return nil</span>
}

func (o *Order) OrderPaymentProcessed(cmd command.CreatePaymentOrderProcessedCommand) error <span class="cov8" title="1">{
        event := events.FromProcessedOrderCommand(cmd)

        o.TrackChange(o, event)

        return nil
}</span>

func (o *Order) OrderPaymentAuthorized(cmd command.CreatePaymentOrderAuthorizedCommand) error <span class="cov8" title="1">{
        _, err := o.FindPaymentByID(cmd.PaymentID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">event := events.FromAuthorizedOrderCommand(cmd)
        o.TrackChange(o, event)

        return nil</span>
}

func (o *Order) OrderPaymentFailed(cmd command.CreatePaymentOrderFailCommand) error <span class="cov8" title="1">{
        event := events.FromFailedOrderCommand(cmd)

        o.TrackChange(o, event)

        return nil
}</span>

func (o *Order) OrderPaymentReleased(cmd command.PaymentOrderReleasedCommand) error <span class="cov8" title="1">{
        _, err := o.FindPaymentByID(cmd.PaymentID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">event := events.FromReleasedOrderCommand(cmd)
        o.TrackChange(o, event)

        return nil</span>
}

func (o *Order) OrderPaymentCaptured(cmd command.PaymentOrderCapturedCommand) error <span class="cov8" title="1">{
        _, err := o.FindPaymentByID(cmd.PaymentID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">event := events.FromCapturedOrderCommand(cmd)
        o.TrackChange(o, event)

        return nil</span>
}

func (o *Order) CanProcessPayment(other entities.PaymentOrder) bool <span class="cov8" title="1">{
        if o.Status != vo.OrderStatusProcessing() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">_, found := lo.Find(o.OrderPayments, func(item entities.PaymentOrder) bool </span><span class="cov0" title="0">{
                return item.ID == other.ID &amp;&amp; item.Status != enums.PaymentFailed
        }</span>)

        <span class="cov8" title="1">if found </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">sum := o.GetTotalEligiblePayments().Value.Add(other.Total.Value)

        return sum.LessThanOrEqual(o.TotalAmount.Value)</span>
}

func (o *Order) RefundPayment(paymentID string, reason string) (entities.PaymentOrder, error) <span class="cov8" title="1">{
        payment, findErr := o.FindPaymentByID(paymentID)

        if findErr != nil </span><span class="cov0" title="0">{
                return payment, findErr
        }</span>

        <span class="cov8" title="1">if !payment.CanRefund() </span><span class="cov0" title="0">{
                return payment, errors2.NewRefundCanNotAppliedDueToPaymentStatusError()
        }</span>

        <span class="cov8" title="1">event := events.FromRefundOrderCommand(paymentID, reason)
        o.TrackChange(o, event)

        return payment, nil</span>
}

func (o *Order) RefundPartialPayment(paymentID string, reason string, amount decimal.Decimal) error <span class="cov8" title="1">{
        payment, findErr := o.FindPaymentByID(paymentID)

        if findErr != nil </span><span class="cov8" title="1">{
                return findErr
        }</span>

        <span class="cov8" title="1">if !payment.CanRefundAmount(amount) </span><span class="cov8" title="1">{
                return errors2.NewRefundCanNotAppliedDueToPaymentStatusError()
        }</span>

        <span class="cov8" title="1">event := events.FromRefundPartialPaymentCommand(paymentID, reason, amount)

        o.TrackChange(o, event)

        return nil</span>
}

func (o *Order) FindPaymentByID(paymentID string) (entities.PaymentOrder, error) <span class="cov8" title="1">{
        for _, payment := range o.OrderPayments </span><span class="cov8" title="1">{
                if payment.ID == paymentID </span><span class="cov8" title="1">{
                        return payment, nil
                }</span>
        }

        <span class="cov8" title="1">return entities.PaymentOrder{}, errors2.NewOrderPaymentNotFoundError(o.ID, paymentID)</span>
}

func (o *Order) GetTotalEligiblePayments() vo.CurrencyAmount <span class="cov8" title="1">{
        var totalPaid decimal.Decimal

        for _, payment := range o.OrderPayments </span><span class="cov8" title="1">{
                if payment.Status.IsProcessing() || payment.Status.IsProcessed() </span><span class="cov8" title="1">{
                        totalPaid = totalPaid.Add(payment.Total.Value)
                }</span>
        }

        <span class="cov8" title="1">totalPaidAmount, _ := vo.NewCurrencyAmount(o.Currency, totalPaid)

        return totalPaidAmount</span>
}

func (o *Order) GetTotalProcessed() vo.CurrencyAmount <span class="cov8" title="1">{
        totalPaid := decimal.Zero

        for _, payment := range o.OrderPayments </span><span class="cov8" title="1">{
                if payment.Status == enums.PaymentProcessed </span><span class="cov8" title="1">{
                        totalPaid = totalPaid.Add(payment.Total.Value)
                }</span>
        }

        <span class="cov8" title="1">totalPaidAmount, _ := vo.NewCurrencyAmount(o.Currency, totalPaid)

        return totalPaidAmount</span>
}

func (o *Order) HasPaymentRefundable() bool <span class="cov8" title="1">{
        for _, payment := range o.OrderPayments </span><span class="cov8" title="1">{
                if payment.Status.IsProcessing() ||
                        payment.Status.IsProcessed() ||
                        payment.Status.IsPartiallyRefunded() </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (o *Order) IsEmpty() bool <span class="cov8" title="1">{
        return o.ID == ""
}</span>

func (o *Order) Register(r eventsourcing.RegisterFunc) <span class="cov0" title="0">{
        r(
                new(events.OrderCreated),
                new(events.PaymentProcessingStarted),
                new(events.OrderPaymentProcessedEvent),
                new(events.OrderPaymentFailedEvent),
                new(events.OrderPaymentTotalRefundedEvent),
                new(events.OrderPaymentPartialRefundedEvent),
                new(events.OrderPaymentAuthorizedEvent),
                new(events.OrderPaymentCapturedEvent),
                new(events.OrderPaymentReleasedEvent),
        )
}</span>

func (o *Order) Transition(event eventsourcing.Event) <span class="cov8" title="1">{
        switch e := event.Data().(type) </span>{
        case *events.OrderCreated:<span class="cov8" title="1">
                WhenOrderCreated(o, *e)</span>
        case *events.PaymentProcessingStarted:<span class="cov8" title="1">
                WhenOrderPaymentProcessingStarted(o, *e)</span>
        case *events.OrderPaymentProcessedEvent:<span class="cov8" title="1">
                WhenOrderPaymentProcessed(o, *e)</span>
        case *events.OrderPaymentFailedEvent:<span class="cov8" title="1">
                WhenOrderPaymentFailed(o, *e)</span>
        case *events.OrderPaymentTotalRefundedEvent:<span class="cov8" title="1">
                WhenPaymentRefunded(o, *e)</span>
        case *events.OrderPaymentPartialRefundedEvent:<span class="cov8" title="1">
                WhenPaymentPartialRefunded(o, *e)</span>
        case *events.OrderPaymentAuthorizedEvent:<span class="cov8" title="1">
                WhenOrderPaymentAuthorized(o, *e)</span>
        case *events.OrderPaymentCapturedEvent:<span class="cov8" title="1">
                WhenPaymentCaptured(o, *e)</span>
        case *events.OrderPaymentReleasedEvent:<span class="cov8" title="1">
                WhenPaymentReleased(o, *e)</span>
        }
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package aggregate

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

func WhenOrderPaymentAuthorized(o *Order, ev events.OrderPaymentAuthorizedEvent) <span class="cov8" title="1">{
        o.Status = value_objects.OrderStatusAuthorized()
        for i := range o.OrderPayments </span><span class="cov8" title="1">{
                if o.OrderPayments[i].ID == ev.PaymentID </span><span class="cov8" title="1">{
                        o.OrderPayments[i].Status = enums.PaymentAuthorized
                        o.OrderPayments[i].AuthorizationCode = ev.AuthorizationCode
                        o.OrderPayments[i].PaymentCard = entities.CardData{
                                CardBrand: ev.PaymentCard.CardBrand,
                                CardLast4: ev.PaymentCard.CardLast4,
                                CardType:  ev.PaymentCard.CardType,
                        }

                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package aggregate

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events"
        vo "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

// WhenOrderCreated applies the OrderCreated to the Order aggregate.
// If the provided Order is nil, a new instance is created and the event data is applied.
//
// Parameters:
//   - o: *Order - The existing Order instance or nil if creating a new one.
//   - ev: events.OrderCreated - The event containing order creation data.
func WhenOrderCreated(o *Order, ev events.OrderCreated) <span class="cov8" title="1">{
        if o == nil </span><span class="cov0" title="0">{
                o = &amp;Order{}
        }</span>

        <span class="cov8" title="1">o.Metadata = ev.Metadata
        o.OrderPayments = make([]entities.PaymentOrder, 0)
        o.ID = ev.ID
        o.TotalAmount = ev.TotalAmount
        o.Currency = ev.TotalAmount.Code
        o.PhoneNumber = ev.PhoneNumber
        o.CountryCode = ev.CountryCode
        o.User = ev.User
        o.CreatedAt = ev.CreatedAt
        o.Status = vo.OrderStatusProcessing()
        o.EnterpriseID = ev.EnterpriseID
        o.Email = ev.Email
        o.WebhookUrl = ev.WebhookUrl
        o.AllowCapture = ev.AllowCapture</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package aggregate

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events"
        vo "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

func WhenOrderPaymentProcessingStarted(o *Order, event events.PaymentProcessingStarted) <span class="cov8" title="1">{
        o.OrderPayments = append(o.OrderPayments, event.PaymentOrder)
        o.Status = vo.OrderStatusProcessing()
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package aggregate

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

func WhenOrderPaymentProcessed(o *Order, ev events.OrderPaymentProcessedEvent) <span class="cov8" title="1">{
        o.Status = value_objects.OrderStatusProcessed()
        for i := range o.OrderPayments </span><span class="cov8" title="1">{
                if o.OrderPayments[i].ID == ev.PaymentID </span><span class="cov8" title="1">{
                        o.OrderPayments[i].Status = enums.PaymentProcessed
                        o.OrderPayments[i].AuthorizationCode = ev.AuthorizationCode
                        o.OrderPayments[i].PaymentCard = entities.CardData{
                                CardBrand: ev.PaymentCard.CardBrand,
                                CardLast4: ev.PaymentCard.CardLast4,
                                CardType:  ev.PaymentCard.CardType,
                        }
                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package aggregate

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

func WhenOrderPaymentFailed(o *Order, ev events.OrderPaymentFailedEvent) <span class="cov8" title="1">{
        o.Status = value_objects.OrderStatusFailed()
        for i := range o.OrderPayments </span><span class="cov8" title="1">{
                if o.OrderPayments[i].ID == ev.PaymentID </span><span class="cov8" title="1">{
                        o.OrderPayments[i].Status = enums.PaymentFailed
                        o.OrderPayments[i].FailureReason = ev.PaymentReason
                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package aggregate

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

func WhenPaymentCaptured(o *Order, ev events.OrderPaymentCapturedEvent) <span class="cov8" title="1">{
        o.Status = value_objects.OrderStatusProcessed()
        for i := range o.OrderPayments </span><span class="cov8" title="1">{
                if o.OrderPayments[i].ID == ev.PaymentID </span><span class="cov8" title="1">{
                        o.OrderPayments[i].Status = enums.PaymentProcessed
                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package aggregate

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

func WhenPaymentPartialRefunded(o *Order, ev events.OrderPaymentPartialRefundedEvent) <span class="cov8" title="1">{
        for i, payment := range o.OrderPayments </span><span class="cov8" title="1">{
                if payment.ID == ev.PaymentID </span><span class="cov8" title="1">{
                        o.OrderPayments[i].TotalRefunded = payment.TotalRefunded.Add(ev.Amount)

                        if o.OrderPayments[i].TotalRefunded.Equals(payment.Total) </span><span class="cov0" title="0">{
                                o.OrderPayments[i].Status = enums.PaymentRefunded
                        }</span> else<span class="cov8" title="1"> {
                                o.OrderPayments[i].Status = enums.PartiallyRefunded
                        }</span>
                }
        }

        <span class="cov8" title="1">if o.HasPaymentRefundable() </span><span class="cov8" title="1">{
                o.Status = value_objects.OrderStatusPartiallyRefunded()
        }</span> else<span class="cov0" title="0"> {
                o.Status = value_objects.OrderStatusRefunded()
        }</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package aggregate

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

func WhenPaymentRefunded(o *Order, ev events.OrderPaymentTotalRefundedEvent) <span class="cov8" title="1">{
        for i := range o.OrderPayments </span><span class="cov8" title="1">{
                if o.OrderPayments[i].ID == ev.PaymentID </span><span class="cov8" title="1">{
                        o.OrderPayments[i].TotalRefunded = o.OrderPayments[i].Total
                        o.OrderPayments[i].Status = enums.PaymentRefunded
                }</span>
        }

        <span class="cov8" title="1">if o.HasPaymentRefundable() </span><span class="cov0" title="0">{
                o.Status = value_objects.OrderStatusPartiallyRefunded()
        }</span> else<span class="cov8" title="1"> {
                o.Status = value_objects.OrderStatusRefunded()
        }</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package aggregate

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/events"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

func WhenPaymentReleased(o *Order, ev events.OrderPaymentReleasedEvent) <span class="cov8" title="1">{
        o.Status = value_objects.OrderStatusCanceled()
        for i := range o.OrderPayments </span><span class="cov8" title="1">{
                if o.OrderPayments[i].ID == ev.PaymentID </span><span class="cov8" title="1">{
                        o.OrderPayments[i].Status = enums.PaymentCanceled
                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package command

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

type CreateOrderCommand struct {
        ReferenceID    string
        TotalAmount    value_objects.CurrencyAmount
        Email          string
        PhoneNumber    string
        User           entities.User
        CountryCode    value_objects.Country
        CurrencyCode   value_objects.CurrencyCode
        BillingAddress value_objects.Address
        EnterpriseID   string
        Metadata       map[string]interface{}
        WebhookUrl     value_objects.WebhookUrl
        AllowCapture   bool
}

func (cmd *CreateOrderCommand) Validate() error <span class="cov8" title="1">{
        if cmd.ReferenceID == "" </span><span class="cov8" title="1">{
                return errors.NewOrderCreateValidationError(errors.ErrInvalidOrderID)
        }</span>

        <span class="cov8" title="1">if err := cmd.TotalAmount.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if cmd.PhoneNumber == "" </span><span class="cov8" title="1">{
                return errors.NewOrderCreateValidationError(errors.ErrInvalidOrderPhoneNumber)

        }</span>

        <span class="cov8" title="1">if err := cmd.User.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if cmd.EnterpriseID == "" </span><span class="cov8" title="1">{
                return errors.NewOrderCreateValidationError(errors.ErrInvalidOrderEnterpriseID)
        }</span>

        <span class="cov8" title="1">if !cmd.WebhookUrl.IsEmpty() </span><span class="cov8" title="1">{
                if err := cmd.WebhookUrl.ValidateUrl(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

type CreateOrderBuilder struct {
        cmd CreateOrderCommand
}

func NewCreateOrderCommandBuilder() *CreateOrderBuilder <span class="cov8" title="1">{
        return &amp;CreateOrderBuilder{}
}</span>

func (b *CreateOrderBuilder) WithReferenceID(referenceID string) *CreateOrderBuilder <span class="cov8" title="1">{
        b.cmd.ReferenceID = referenceID
        return b
}</span>

func (b *CreateOrderBuilder) WithTotalAmount(totalAmount value_objects.CurrencyAmount) *CreateOrderBuilder <span class="cov8" title="1">{
        b.cmd.TotalAmount = totalAmount
        return b
}</span>

func (b *CreateOrderBuilder) WithPhoneNumber(phoneNumber string) *CreateOrderBuilder <span class="cov8" title="1">{
        b.cmd.PhoneNumber = phoneNumber
        return b
}</span>

func (b *CreateOrderBuilder) WithUser(user entities.User) *CreateOrderBuilder <span class="cov8" title="1">{
        b.cmd.User = user
        return b
}</span>

func (b *CreateOrderBuilder) WithCountryCode(countryCode value_objects.Country) *CreateOrderBuilder <span class="cov8" title="1">{
        b.cmd.CountryCode = countryCode
        return b
}</span>

func (b *CreateOrderBuilder) WithBillingAddress(address value_objects.Address) *CreateOrderBuilder <span class="cov8" title="1">{
        b.cmd.BillingAddress = address
        return b
}</span>

func (b *CreateOrderBuilder) WithCurrencyCode(currencyCode value_objects.CurrencyCode) *CreateOrderBuilder <span class="cov8" title="1">{
        b.cmd.CurrencyCode = currencyCode
        return b
}</span>

func (b *CreateOrderBuilder) WithEnterpriseID(enterpriseID string) *CreateOrderBuilder <span class="cov8" title="1">{
        b.cmd.EnterpriseID = enterpriseID
        return b
}</span>

func (b *CreateOrderBuilder) WithEmail(email string) *CreateOrderBuilder <span class="cov8" title="1">{
        b.cmd.Email = email
        return b
}</span>

func (b *CreateOrderBuilder) WithMetadata(metadata map[string]interface{}) *CreateOrderBuilder <span class="cov8" title="1">{
        if metadata == nil </span><span class="cov8" title="1">{
                b.cmd.Metadata = make(map[string]interface{})
                return b
        }</span> else<span class="cov8" title="1"> {
                b.cmd.Metadata = metadata
        }</span>

        <span class="cov8" title="1">return b</span>
}

func (b *CreateOrderBuilder) WithWebhookUrl(webhookUrl value_objects.WebhookUrl) *CreateOrderBuilder <span class="cov8" title="1">{
        b.cmd.WebhookUrl = webhookUrl
        return b
}</span>

func (b *CreateOrderBuilder) WithAllowCapture(allowCapture bool) *CreateOrderBuilder <span class="cov8" title="1">{
        b.cmd.AllowCapture = allowCapture
        return b
}</span>

func (b *CreateOrderBuilder) Build() CreateOrderCommand <span class="cov8" title="1">{
        return b.cmd
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package command

import (
        "errors"

        "github.com/shopspring/decimal"
)

type CreatePartialPaymentRefundCommand struct {
        ReferenceOrderID string
        PaymentOrderID   string
        Amount           decimal.Decimal
        Reason           string
}

func NewCreatePartialPaymentRefundCommand(referenceOrderID, paymentOrderID string, amount decimal.Decimal, reason string) *CreatePartialPaymentRefundCommand <span class="cov8" title="1">{
        return &amp;CreatePartialPaymentRefundCommand{
                ReferenceOrderID: referenceOrderID,
                PaymentOrderID:   paymentOrderID,
                Amount:           amount,
                Reason:           reason,
        }
}</span>

func (cmd *CreatePartialPaymentRefundCommand) Validate() error <span class="cov8" title="1">{
        if cmd.ReferenceOrderID == "" </span><span class="cov8" title="1">{
                return errors.New("reference order id is required")
        }</span>
        <span class="cov8" title="1">if cmd.PaymentOrderID == "" </span><span class="cov8" title="1">{
                return errors.New("payment order id is required")
        }</span>
        <span class="cov8" title="1">if cmd.Amount.IsZero() </span><span class="cov8" title="1">{
                return errors.New("amount is required")
        }</span>
        <span class="cov8" title="1">if cmd.Reason == "" </span><span class="cov8" title="1">{
                return errors.New("reason is required")
        }</span>
        <span class="cov8" title="1">if cmd.Amount.IsNegative() </span><span class="cov8" title="1">{
                return errors.New("amount cannot be negative")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package command

import (
        "github.com/shopspring/decimal"
)

type PaymentOrderCapturedCommand struct {
        OrderID   string
        PaymentID string
        Amount    decimal.Decimal
        Currency  string
}

func NewPaymentOrderCapturedCommand(orderID, paymentID, currency string, amount decimal.Decimal) PaymentOrderCapturedCommand <span class="cov8" title="1">{
        return PaymentOrderCapturedCommand{
                OrderID:   orderID,
                PaymentID: paymentID,
                Amount:    amount,
                Currency:  currency,
        }
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package command

type CreatePaymentOrderAuthorizedCommand struct {
        OrderID           string
        PaymentID         string
        AuthorizationCode string
        OrderStatusString string
        PaymentCard       CardData
}

func NewCreatePaymentOrderAuthorizedCommand(
        orderID string,
        paymentID string,
        authorizationCode string,
        orderStatusString string,
        paymentCard CardData,
) CreatePaymentOrderAuthorizedCommand <span class="cov8" title="1">{
        return CreatePaymentOrderAuthorizedCommand{
                OrderID:           orderID,
                PaymentID:         paymentID,
                AuthorizationCode: authorizationCode,
                OrderStatusString: orderStatusString,
                PaymentCard:       paymentCard,
        }
}</span>
</pre>
		
		<pre class="file" id="file114" style="display: none">package command

import (
        "errors"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

type CreatePaymentOrderCommand struct {
        ReferenceOrderID  string
        ID                string
        Payment           entities.PaymentOrder
        User              entities.User
        AssociatedOrigin  value_objects.AssociatedOrigin
        CurrencyCode      value_objects.CurrencyCode
        CollectionAccount entities.CollectionAccount
        AuthorizationCode string
        Metadata          string
        PaymentFlow       enums.PaymentFlowEnum
        CountryCode       string
}

func (c CreatePaymentOrderCommand) WithCollectionAccount(account entities.CollectionAccount) CreatePaymentOrderCommand <span class="cov8" title="1">{
        newCommand := c

        newCommand.CollectionAccount = account

        return newCommand
}</span>

func (c CreatePaymentOrderCommand) WithAuthorizationCode(authorizationCode string) CreatePaymentOrderCommand <span class="cov8" title="1">{
        newCommand := c

        newCommand.AuthorizationCode = authorizationCode

        return newCommand
}</span>

func (c CreatePaymentOrderCommand) WithPaymentFlow(paymentFlow enums.PaymentFlowEnum) CreatePaymentOrderCommand <span class="cov8" title="1">{
        newCommand := c

        newCommand.PaymentFlow = paymentFlow
        newCommand.Payment.PaymentFlow = paymentFlow.String()

        return newCommand
}</span>

func (c CreatePaymentOrderCommand) WithCardData(cardData entities.Card) CreatePaymentOrderCommand <span class="cov8" title="1">{
        newCommand := c

        newCommand.Payment.PaymentCard = entities.CardData{
                CardBrand: cardData.Brand,
                CardLast4: cardData.LastFour,
                CardType:  cardData.CardType,
        }

        return newCommand
}</span>

func (c CreatePaymentOrderCommand) Validate() error <span class="cov8" title="1">{
        if c.ReferenceOrderID == "" </span><span class="cov8" title="1">{
                return errors.New("ReferenceOrderID is required")
        }</span>

        <span class="cov8" title="1">if err := c.Payment.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.User.Validate(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type CreatePaymentOrderCommandBuilder struct {
        id                string
        referenceOrderID  string
        paymentOrder      entities.PaymentOrder
        user              entities.User
        associatedOrigin  value_objects.AssociatedOrigin
        currencyCode      value_objects.CurrencyCode
        collectionAccount entities.CollectionAccount
        paymentFlow       enums.PaymentFlowEnum
        countryCode       string
}

func NewCreatePaymentOrderCommandBuilder() *CreatePaymentOrderCommandBuilder <span class="cov8" title="1">{
        return &amp;CreatePaymentOrderCommandBuilder{}
}</span>

func (b *CreatePaymentOrderCommandBuilder) WithReferenceOrderID(referenceOrderID string) *CreatePaymentOrderCommandBuilder <span class="cov8" title="1">{
        b.referenceOrderID = referenceOrderID
        return b
}</span>

func (b *CreatePaymentOrderCommandBuilder) WithPayment(paymentOrder entities.PaymentOrder) *CreatePaymentOrderCommandBuilder <span class="cov8" title="1">{
        b.paymentOrder = paymentOrder
        return b
}</span>

func (b *CreatePaymentOrderCommandBuilder) WithUser(user entities.User) *CreatePaymentOrderCommandBuilder <span class="cov8" title="1">{
        b.user = user
        return b
}</span>

func (b *CreatePaymentOrderCommandBuilder) WithPaymentOrderID(id string) *CreatePaymentOrderCommandBuilder <span class="cov8" title="1">{
        b.id = id
        return b
}</span>

func (b *CreatePaymentOrderCommandBuilder) WithAssociatedOrigin(associatedOrigin value_objects.AssociatedOrigin) *CreatePaymentOrderCommandBuilder <span class="cov8" title="1">{
        b.associatedOrigin = associatedOrigin
        return b
}</span>

func (b *CreatePaymentOrderCommandBuilder) WithCurrencyCode(currencyCode value_objects.CurrencyCode) *CreatePaymentOrderCommandBuilder <span class="cov8" title="1">{
        b.currencyCode = currencyCode
        return b
}</span>

func (b *CreatePaymentOrderCommandBuilder) WithCountryCode(countryCode string) *CreatePaymentOrderCommandBuilder <span class="cov8" title="1">{
        b.countryCode = countryCode
        return b
}</span>

func (b *CreatePaymentOrderCommandBuilder) WithCollectionAccount(collectionAccount entities.CollectionAccount) *CreatePaymentOrderCommandBuilder <span class="cov0" title="0">{
        b.collectionAccount = collectionAccount
        return b
}</span>

func (b *CreatePaymentOrderCommandBuilder) WithPaymentFlow(paymentFlow enums.PaymentFlowEnum) *CreatePaymentOrderCommandBuilder <span class="cov0" title="0">{
        b.paymentFlow = paymentFlow
        return b
}</span>

func (b *CreatePaymentOrderCommandBuilder) Build() CreatePaymentOrderCommand <span class="cov8" title="1">{
        return CreatePaymentOrderCommand{
                ReferenceOrderID:  b.referenceOrderID,
                Payment:           b.paymentOrder,
                User:              b.user,
                ID:                b.id,
                AssociatedOrigin:  b.associatedOrigin,
                CurrencyCode:      b.currencyCode,
                CollectionAccount: b.collectionAccount,
                PaymentFlow:       b.paymentFlow,
                CountryCode:       b.countryCode,
        }
}</span>
</pre>
		
		<pre class="file" id="file115" style="display: none">package command

type CreatePaymentOrderFailCommand struct {
        OrderID           string
        PaymentID         string
        PaymentReason     string
        OrderStatusString string
}

func NewCreatePaymentOrderFailCommand(
        orderID string,
        paymentID string,
        paymentReason,
        orderStatusString string,
) CreatePaymentOrderFailCommand <span class="cov8" title="1">{
        return CreatePaymentOrderFailCommand{
                OrderID:           orderID,
                PaymentID:         paymentID,
                PaymentReason:     paymentReason,
                OrderStatusString: orderStatusString,
        }
}</span>
</pre>
		
		<pre class="file" id="file116" style="display: none">package command

type CardData struct {
        CardBrand string
        CardLast4 string
        CardType  string
}

type CreatePaymentOrderProcessedCommand struct {
        OrderID           string
        PaymentID         string
        AuthorizationCode string
        OrderStatusString string
        PaymentCard       CardData
}

func NewCreatePaymentOrderProcessedCommand(
        orderID string,
        paymentID string,
        authorizationCode string,
        orderStatusString string,
        paymentCard CardData,
) CreatePaymentOrderProcessedCommand <span class="cov8" title="1">{
        return CreatePaymentOrderProcessedCommand{
                OrderID:           orderID,
                PaymentID:         paymentID,
                AuthorizationCode: authorizationCode,
                OrderStatusString: orderStatusString,
                PaymentCard:       paymentCard,
        }
}</span>
</pre>
		
		<pre class="file" id="file117" style="display: none">package command

import "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors"

type RefundTotalCommand struct {
        ReferenceOrderID string
        PaymentOrderID   string
        Reason           string
}

func NewRefundTotalCommand(referenceOrderID, paymentOrderID, reason string) *RefundTotalCommand <span class="cov8" title="1">{
        return &amp;RefundTotalCommand{
                ReferenceOrderID: referenceOrderID,
                PaymentOrderID:   paymentOrderID,
                Reason:           reason,
        }
}</span>

func (cmd *RefundTotalCommand) Validate() error <span class="cov8" title="1">{
        if cmd.ReferenceOrderID == "" </span><span class="cov8" title="1">{
                return errors.NewRefundCreateValidationError(errors.ErrInvalidRefundReferenceOrderID)
        }</span>
        <span class="cov8" title="1">if cmd.PaymentOrderID == "" </span><span class="cov8" title="1">{
                return errors.NewRefundCreateValidationError(errors.ErrInvalidRefundPaymentOrderID)
        }</span>
        <span class="cov8" title="1">if cmd.Reason == "" </span><span class="cov8" title="1">{
                return errors.NewRefundCreateValidationError(errors.ErrInvalidRefundReason)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package command

type PaymentOrderReleasedCommand struct {
        OrderID   string
        PaymentID string
        Reason    string
}

func NewPaymentOrderReleasedCommand(orderID, paymentID, reason string) PaymentOrderReleasedCommand <span class="cov8" title="1">{
        return PaymentOrderReleasedCommand{
                OrderID:   orderID,
                PaymentID: paymentID,
                Reason:    reason,
        }
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">package events

import (
        "time"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"

        vo "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

type OrderCreated struct {
        ID              string
        TotalAmount     vo.CurrencyAmount
        PhoneNumber     string
        User            entities.User
        CreatedAt       time.Time
        CountryCode     vo.Country
        BillingAddress  vo.Address
        ShippingAddress vo.Address
        EnterpriseID    string
        Metadata        map[string]interface{}
        Email           string
        WebhookUrl      vo.WebhookUrl
        AllowCapture    bool
}

type OrderCreatedEventBuilder struct {
        event *OrderCreated
}

func NewOrderCreatedEventBuilder() *OrderCreatedEventBuilder <span class="cov8" title="1">{
        return &amp;OrderCreatedEventBuilder{event: &amp;OrderCreated{}}
}</span>

func (b *OrderCreatedEventBuilder) SetID(id string) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.ID = id
        return b
}</span>

func (b *OrderCreatedEventBuilder) SetTotalAmount(totalAmount vo.CurrencyAmount) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.TotalAmount = totalAmount
        return b
}</span>

func (b *OrderCreatedEventBuilder) SetPhoneNumber(phoneNumber string) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.PhoneNumber = phoneNumber
        return b
}</span>

func (b *OrderCreatedEventBuilder) SetUser(user entities.User) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.User = user
        return b
}</span>

func (b *OrderCreatedEventBuilder) SetCreatedAt(createdAt time.Time) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.CreatedAt = createdAt
        return b
}</span>

func (b *OrderCreatedEventBuilder) SetCountryCode(countryCode vo.Country) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.CountryCode = countryCode
        return b
}</span>

func (b *OrderCreatedEventBuilder) SetBillingAddress(billingAddress vo.Address) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.BillingAddress = billingAddress
        return b
}</span>

func (b *OrderCreatedEventBuilder) SetShippingAddress(shippingAddress vo.Address) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.ShippingAddress = shippingAddress
        return b
}</span>

func (b *OrderCreatedEventBuilder) SetEnterpriseID(enterpriseID string) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.EnterpriseID = enterpriseID
        return b
}</span>

func (b *OrderCreatedEventBuilder) SetEmail(email string) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.Email = email
        return b
}</span>

func (b *OrderCreatedEventBuilder) SetWebhookUrl(webhookUrl vo.WebhookUrl) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.WebhookUrl = webhookUrl
        return b
}</span>

func (b *OrderCreatedEventBuilder) SetMetadata(metadata map[string]interface{}) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.Metadata = metadata
        return b
}</span>

func (b *OrderCreatedEventBuilder) SetAllowCapture(allowCapture bool) *OrderCreatedEventBuilder <span class="cov8" title="1">{
        b.event.AllowCapture = allowCapture
        return b
}</span>

func (b *OrderCreatedEventBuilder) Build() *OrderCreated <span class="cov8" title="1">{
        return b.event
}</span>
</pre>
		
		<pre class="file" id="file120" style="display: none">package events

import "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"

type OrderPaymentAuthorizedEvent struct {
        OrderID           string
        PaymentID         string
        AuthorizationCode string
        OrderStatusString string
        PaymentCard       command.CardData
}

func FromAuthorizedOrderCommand(cmd command.CreatePaymentOrderAuthorizedCommand) *OrderPaymentAuthorizedEvent <span class="cov8" title="1">{
        return &amp;OrderPaymentAuthorizedEvent{
                OrderID:           cmd.OrderID,
                PaymentID:         cmd.PaymentID,
                AuthorizationCode: cmd.AuthorizationCode,
                OrderStatusString: cmd.OrderStatusString,
                PaymentCard:       cmd.PaymentCard,
        }
}</span>
</pre>
		
		<pre class="file" id="file121" style="display: none">package events

import (
        "time"

        "github.com/shopspring/decimal"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
)

type OrderPaymentCapturedEvent struct {
        OrderID    string
        PaymentID  string
        Amount     decimal.Decimal
        CapturedAt time.Time
}

func FromCapturedOrderCommand(cmd command.PaymentOrderCapturedCommand) *OrderPaymentCapturedEvent <span class="cov8" title="1">{
        return &amp;OrderPaymentCapturedEvent{
                OrderID:    cmd.OrderID,
                PaymentID:  cmd.PaymentID,
                Amount:     cmd.Amount,
                CapturedAt: time.Now(),
        }
}</span>
</pre>
		
		<pre class="file" id="file122" style="display: none">package events

import "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"

type OrderPaymentFailedEvent struct {
        OrderID           string
        PaymentID         string
        PaymentReason     string
        OrderStatusString string
}

func FromFailedOrderCommand(cmd command.CreatePaymentOrderFailCommand) *OrderPaymentFailedEvent <span class="cov8" title="1">{
        return &amp;OrderPaymentFailedEvent{
                OrderID:           cmd.OrderID,
                PaymentID:         cmd.PaymentID,
                PaymentReason:     cmd.PaymentReason,
                OrderStatusString: cmd.OrderStatusString,
        }
}</span>
</pre>
		
		<pre class="file" id="file123" style="display: none">package events

import (
        "time"

        "github.com/shopspring/decimal"
)

type OrderPaymentPartialRefundedEvent struct {
        PaymentID string
        Reason    string
        Amount    decimal.Decimal
        CreatedAt time.Time
}

func FromRefundPartialPaymentCommand(paymentID string, reason string, amount decimal.Decimal) *OrderPaymentPartialRefundedEvent <span class="cov8" title="1">{
        return &amp;OrderPaymentPartialRefundedEvent{
                PaymentID: paymentID,
                Reason:    reason,
                Amount:    amount,
                CreatedAt: time.Now(),
        }
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">package events

import "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"

type OrderPaymentProcessedEvent struct {
        OrderID           string
        PaymentID         string
        AuthorizationCode string
        OrderStatusString string
        PaymentCard       command.CardData
}

func FromProcessedOrderCommand(cmd command.CreatePaymentOrderProcessedCommand) *OrderPaymentProcessedEvent <span class="cov8" title="1">{
        return &amp;OrderPaymentProcessedEvent{
                OrderID:           cmd.OrderID,
                PaymentID:         cmd.PaymentID,
                AuthorizationCode: cmd.AuthorizationCode,
                OrderStatusString: cmd.OrderStatusString,
                PaymentCard:       cmd.PaymentCard,
        }
}</span>
</pre>
		
		<pre class="file" id="file125" style="display: none">package events

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
)

type PaymentProcessingStarted struct {
        PaymentOrder entities.PaymentOrder
}

type OrderPaymentProcessingStartedEventBuilder struct {
        event *PaymentProcessingStarted
}

func NewPaymentProcessingStartedEvent() *OrderPaymentProcessingStartedEventBuilder <span class="cov8" title="1">{
        return &amp;OrderPaymentProcessingStartedEventBuilder{event: &amp;PaymentProcessingStarted{}}
}</span>

func (b *OrderPaymentProcessingStartedEventBuilder) WithPayment(paymentOrder entities.PaymentOrder) *OrderPaymentProcessingStartedEventBuilder <span class="cov8" title="1">{
        b.event.PaymentOrder = paymentOrder
        return b
}</span>

func (b *OrderPaymentProcessingStartedEventBuilder) WithCollectionAccount(collectionAccount entities.CollectionAccount) *OrderPaymentProcessingStartedEventBuilder <span class="cov8" title="1">{
        b.event.PaymentOrder.CollectionAccount = collectionAccount
        return b
}</span>

func (b *OrderPaymentProcessingStartedEventBuilder) Build() *PaymentProcessingStarted <span class="cov8" title="1">{
        return b.event
}</span>

func FromProcessOrderCommand(cmd command.CreatePaymentOrderCommand) *PaymentProcessingStarted <span class="cov8" title="1">{
        event := NewPaymentProcessingStartedEvent().
                WithPayment(cmd.Payment).
                WithCollectionAccount(cmd.CollectionAccount).
                Build()

        return event
}</span>
</pre>
		
		<pre class="file" id="file126" style="display: none">package events

import (
        "time"
)

type OrderPaymentTotalRefundedEvent struct {
        PaymentID string
        Reason    string
        CreatedAt time.Time
}

func FromRefundOrderCommand(paymentID string, reason string) *OrderPaymentTotalRefundedEvent <span class="cov8" title="1">{
        return &amp;OrderPaymentTotalRefundedEvent{
                PaymentID: paymentID,
                Reason:    reason,
                CreatedAt: time.Now(),
        }
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">package events

import (
        "time"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
)

type OrderPaymentReleasedEvent struct {
        OrderID    string
        PaymentID  string
        Reason     string
        ReleasedAt time.Time
}

func FromReleasedOrderCommand(cmd command.PaymentOrderReleasedCommand) *OrderPaymentReleasedEvent <span class="cov8" title="1">{
        return &amp;OrderPaymentReleasedEvent{
                OrderID:    cmd.OrderID,
                PaymentID:  cmd.PaymentID,
                Reason:     cmd.Reason,
                ReleasedAt: time.Now(),
        }
}</span>
</pre>
		
		<pre class="file" id="file128" style="display: none">package integration_events

import "errors"

var integrationEventParamError = errors.New("integration event param error")

type baseOrderIntegrationEvent struct {
        Type               string                 `json:"type"`
        ReferenceOrderID   string                 `json:"reference_order_id"`
        PaymentStatus      string                 `json:"payment_status"`
        OrderStatus        string                 `json:"order_status"`
        ReferencePaymentID string                 `json:"reference_payment_id"`
        AssociatedPayment  string                 `json:"associated_payment"`
        TotalOrderAmount   float64                `json:"total_order_amount"`
        Currency           string                 `json:"currency"`
        UserID             string                 `json:"user_id"`
        UserType           string                 `json:"user_type"`
        EnterpriseID       string                 `json:"enterprise_id"`
        TotalOrderPaid     float64                `json:"total_order_paid"`
        TotalPaymentAmount float64                `json:"total_payment_amount"`
        CardData           CardData               `json:"card_data"`
        Metadata           map[string]interface{} `json:"metadata"`
        PaymentFlow        string                 `json:"payment_flow"`
        ReceiptUrl         string                 `json:"invoice_url"`
}

type CardData struct {
        CardNumber    string `json:"card_number"`
        CardType      string `json:"card_type"`
        MethodPayment string `json:"method_payment"`
}

type IntegrationEventsParams struct {
        ReferenceOrderID   string
        ReferencePaymentID string
        AssociatedPayment  string
        TotalOrderAmount   float64
        Currency           string
        UserID             string
        UserType           string
        EnterpriseID       string
        TotalOrderPaid     float64
        TotalPaymentAmount float64
        CardData           CardData
        Metadata           map[string]interface{}
        ReceiptUrl         string
        PaymentFlow        string
}

func PaymentOrderIntegrationEventWithStatus(
        params IntegrationEventsParams,
        eventType string,
        paymentStatus string,
        orderStatus string) baseOrderIntegrationEvent <span class="cov8" title="1">{
        if params.Metadata == nil </span><span class="cov8" title="1">{
                params.Metadata = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">return baseOrderIntegrationEvent{
                ReferenceOrderID:   params.ReferenceOrderID,
                PaymentStatus:      paymentStatus,
                OrderStatus:        orderStatus,
                Type:               eventType,
                ReferencePaymentID: params.ReferencePaymentID,
                AssociatedPayment:  params.AssociatedPayment,
                TotalOrderAmount:   params.TotalOrderAmount,
                Currency:           params.Currency,
                UserID:             params.UserID,
                UserType:           params.UserType,
                EnterpriseID:       params.EnterpriseID,
                TotalOrderPaid:     params.TotalOrderPaid,
                TotalPaymentAmount: params.TotalPaymentAmount,
                Metadata:           params.Metadata,
                CardData:           params.CardData,
                ReceiptUrl:         params.ReceiptUrl,
                PaymentFlow:        params.PaymentFlow,
        }</span>
}

func (p baseOrderIntegrationEvent) Validate() error <span class="cov8" title="1">{
        if p.ReferenceOrderID == "" </span><span class="cov8" title="1">{
                return integrationEventParamError
        }</span>
        <span class="cov8" title="1">if p.PaymentStatus == "" </span><span class="cov8" title="1">{
                return integrationEventParamError
        }</span>
        <span class="cov8" title="1">if p.OrderStatus == "" </span><span class="cov8" title="1">{
                return integrationEventParamError
        }</span>
        <span class="cov8" title="1">if p.ReferencePaymentID == "" </span><span class="cov8" title="1">{
                return integrationEventParamError
        }</span>
        <span class="cov8" title="1">if p.AssociatedPayment == "" </span><span class="cov8" title="1">{
                return integrationEventParamError
        }</span>
        <span class="cov8" title="1">if p.Currency == "" </span><span class="cov8" title="1">{
                return integrationEventParamError
        }</span>
        <span class="cov8" title="1">if p.UserID == "" </span><span class="cov8" title="1">{
                return integrationEventParamError
        }</span>
        <span class="cov8" title="1">if p.UserType == "" </span><span class="cov8" title="1">{
                return integrationEventParamError
        }</span>
        <span class="cov8" title="1">if p.EnterpriseID == "" </span><span class="cov8" title="1">{
                return integrationEventParamError
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package integration_events

const (
        failedStatus                = "failed"
        paymentOrderFailedEventType = "order-payment-failed"
)

type OrderFailedPaidIntegrationEvent struct {
        baseOrderIntegrationEvent
        FailureReason string `json:"failure_reason"`
}

func NewOrderFailedIntegrationEvent(
        params IntegrationEventsParams,
        reason string,
        orderStatus string,
) OrderFailedPaidIntegrationEvent <span class="cov8" title="1">{
        return OrderFailedPaidIntegrationEvent{
                baseOrderIntegrationEvent: PaymentOrderIntegrationEventWithStatus(
                        params, paymentOrderFailedEventType, failedStatus, orderStatus,
                ),
                FailureReason: reason,
        }
}</span>
</pre>
		
		<pre class="file" id="file130" style="display: none">package integration_events

type paidIntegrationEventOrderStatus string

const (
        paymentProcessed               paidIntegrationEventOrderStatus = "processed"
        paymentOrderProcessedEventType                                 = "order-payment-processed"
)

type OrderPaymentProcessedIntegrationEvent struct {
        baseOrderIntegrationEvent
        AuthorizationCode string `json:"authorization_code"`
}

func NewOrderPaymentProcessedIntegrationEvent(
        params IntegrationEventsParams,
        authorizationCode string,
        orderStatus string,
) OrderPaymentProcessedIntegrationEvent <span class="cov8" title="1">{
        return OrderPaymentProcessedIntegrationEvent{
                baseOrderIntegrationEvent: PaymentOrderIntegrationEventWithStatus(
                        params, paymentOrderProcessedEventType, string(paymentProcessed), orderStatus,
                ),
                AuthorizationCode: authorizationCode,
        }
}</span>
</pre>
		
		<pre class="file" id="file131" style="display: none">package errors

import (
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const userAlreadyExistError = "USER_ALREADY_EXISTS"

func NewUserAlreadyExistError(memberId string, err error) error <span class="cov8" title="1">{
        msg := fmt.Sprintf("user already exists with memberId: %s", memberId)
        return domain.WrapBusinessError(err, userAlreadyExistError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file132" style="display: none">package errors

import (
        "fmt"

        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const userBillingInformationNotFoundError = "USER_BILLLING_INFORMATION_NOT_FOUND"

func NewUserBillingInformationNotFoundError(memberId string, err error) error <span class="cov0" title="0">{
        msg := fmt.Sprintf("billing Information not found in user: %s", memberId)
        return domain.WrapBusinessError(err, userBillingInformationNotFoundError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">package errors

import (
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const userCreateError = "USER_EMAIL_NOT_FOUND"

func NewuserCreateError(err error) error <span class="cov8" title="1">{
        msg := "error creating user db record"
        return domain.WrapBusinessError(err, userCreateError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file134" style="display: none">package errors

import (
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const userEmailNotFoundError = "USER_EMAIL_NOT_FOUND"

func NewUserEmailNotFoundError(memberId string, err error) error <span class="cov8" title="1">{
        msg := fmt.Sprintf("email main not found in user: %s", memberId)
        return domain.WrapBusinessError(err, userEmailNotFoundError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file135" style="display: none">package errors

import (
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const userFailCreateDeUnaError = "USER_FAIL_CREATE_DEUNA_PROVIDER"

func NewUserFailCreateDeUnaError(memberId string, err error) error <span class="cov8" title="1">{
        msg := fmt.Sprintf("error create user DEUNA provider with id: %s", memberId)
        return domain.WrapBusinessError(err, userFailCreateDeUnaError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file136" style="display: none">package errors

import (
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const userGettingDBError = "USER_GETTING_DB_ERROR"

func NewUserGettingDBError(memberId string, err error) error <span class="cov8" title="1">{
        msg := fmt.Sprintf("error getting user with memberId: %s", memberId)
        return domain.WrapBusinessError(err, userGettingDBError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file137" style="display: none">package errors

import (
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const loginUserError = "LOGIN_USER_DEUNA_ERROR"

func NewLoginError(userId string, err error) error <span class="cov8" title="1">{
        msg := fmt.Sprintf("error login DEUNA with userId: %s", userId)
        return domain.WrapBusinessError(err, loginUserError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file138" style="display: none">package errors

import (
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const userNotFoundError = "USER_NOT_FOUND"

func NewUserNotFoundError(memberId string, err error) error <span class="cov8" title="1">{
        msg := fmt.Sprintf("user not found with memberId: %s", memberId)
        return domain.WrapBusinessError(err, userNotFoundError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file139" style="display: none">package errors

import (
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/domain"
)

const userPhoneNotFoundError = "USER_PHONE_NOT_FOUND"

func NewUserPhoneNotFoundError(memberId string, err error) error <span class="cov8" title="1">{
        msg := fmt.Sprintf("phone main not found in user: %s", memberId)
        return domain.WrapBusinessError(err, userPhoneNotFoundError, msg, nil)
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">package value_objects

type Address struct {
        ZipCode string
        Street  string
        Country Country
        City    string
}

func NewAddress(zipCode, street, city string, country Country) Address <span class="cov8" title="1">{
        return Address{
                ZipCode: zipCode,
                Street:  street,
                Country: country,
                City:    city,
        }
}</span>

func (a Address) Equals(other Address) bool <span class="cov8" title="1">{
        return a.ZipCode == other.ZipCode &amp;&amp;
                a.Street == other.Street &amp;&amp;
                a.Country == other.Country &amp;&amp;
                a.City == other.City
}</span>
</pre>
		
		<pre class="file" id="file141" style="display: none">package value_objects

import (
        "errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
)

type AssociatedOrigin struct {
        Type enums.AssociatedOrigin
}

func NewAssociatedOrigin(associatedOriginType enums.AssociatedOrigin) AssociatedOrigin <span class="cov8" title="1">{
        return AssociatedOrigin{
                Type: associatedOriginType,
        }
}</span>

func NewFromAssociatedOriginString(origin string) (AssociatedOrigin, error) <span class="cov8" title="1">{
        associatedOriginTypeEnum, err := enums.NewAssociatedOrigin(origin)

        if err != nil </span><span class="cov8" title="1">{
                return AssociatedOrigin{}, err
        }</span>

        <span class="cov8" title="1">return NewAssociatedOrigin(associatedOriginTypeEnum), nil</span>
}

func (a AssociatedOrigin) Validate() error <span class="cov8" title="1">{
        if !a.Type.IsValid() </span><span class="cov8" title="1">{
                return errors.New("type is not valid")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package value_objects

import "fmt"

const cvvLength = 3

type CardInfo struct {
        CardID string
        CVV    string
}

func (c CardInfo) Validate() error <span class="cov8" title="1">{
        if c.CardID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("CardID is required for credit card payment")
        }</span>

        <span class="cov8" title="1">if len(c.CVV) != cvvLength </span><span class="cov8" title="1">{
                return fmt.Errorf("CVV must be a 3-digit number for credit card payment")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package value_objects

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        paymentmethodsVo "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/payment_methods"
)

func NewCCPaymentMethod(cardID, cvv string) PaymentMethod <span class="cov8" title="1">{
        return PaymentMethod{
                Type: enums.CCMethod,
                CCData: PaymentMethodData[CardInfo]{
                        Data: CardInfo{
                                CardID: cardID,
                                CVV:    cvv,
                        },
                },
        }
}</span>

func NewTokenCardPaymentMethod(token, cvv, brand, last4, exp, cardType, alias string,
        saveCard bool) PaymentMethod <span class="cov8" title="1">{
        return PaymentMethod{
                Type: enums.TokenCard,
                TokenCard: PaymentMethodData[paymentmethodsVo.TokenCard]{
                        Data: paymentmethodsVo.TokenCard{
                                Token:    token,
                                CVV:      cvv,
                                Brand:    brand,
                                Last4:    last4,
                                Exp:      exp,
                                CardType: cardType,
                                SaveCard: saveCard,
                                Alias:    alias,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file144" style="display: none">package value_objects

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/utils"
        bizErrors "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors"
)

type Country struct {
        Code string
}

func newCountry(code string) Country <span class="cov8" title="1">{
        return Country{Code: code}
}</span>

func NewCountryWithCode(code string) (Country, error) <span class="cov8" title="1">{
        if code == "" </span><span class="cov8" title="1">{
                return Country{}, bizErrors.NewInvalidCountryCodeError(code)
        }</span>

        <span class="cov8" title="1">if !utils.IsValidCountryCode(code) </span><span class="cov8" title="1">{
                return Country{}, bizErrors.NewInvalidCountryCodeError(code)
        }</span>

        <span class="cov8" title="1">return Country{
                Code: utils.GetCountryIso3ByCode(code),
        }, nil</span>
}

func (c Country) Equals(other Country) bool <span class="cov8" title="1">{
        return c.Code == other.Code
}</span>

func (c Country) Iso3() string <span class="cov8" title="1">{
        return c.Code
}</span>

func (c Country) Iso2() string <span class="cov0" title="0">{
        return utils.GetCountryIso2ByCode(c.Code)
}</span>
</pre>
		
		<pre class="file" id="file145" style="display: none">package value_objects

import (
        "github.com/shopspring/decimal"
        bizErrors "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors"
)

type CurrencyAmount struct {
        Code  CurrencyCode
        Value decimal.Decimal
}

func newAmount(currencyCode CurrencyCode, value decimal.Decimal) CurrencyAmount <span class="cov8" title="1">{
        return CurrencyAmount{
                Code:  currencyCode,
                Value: value,
        }
}</span>

// NewCurrencyAmount creates a new instance of CurrencyAmount with the given currency code and value.
// The provided currency code should exist in the predefined `CurrencySymbols` map.
// If the code is invalid, it returns an error of type `bizErrors.InvalidCurrencyCodeError`.
//
// Parameters:
//   - code: A CurrencyCode representing the currency code (e.g., "USD", "EUR").
//   - value: A float64 representing the numeric value of the currency amount.
//
// Returns:
//   - CurrencyAmount: The created CurrencyAmount object.
//   - error: An error of type `bizErrors.InvalidCurrencyCodeError` if the currency code is invalid; otherwise, nil.
func NewCurrencyAmount(code CurrencyCode, value decimal.Decimal) (CurrencyAmount, error) <span class="cov8" title="1">{
        return newAmount(code, value), nil
}</span>

func (c CurrencyAmount) Add(amount decimal.Decimal) CurrencyAmount <span class="cov8" title="1">{
        newAmount := c.Value.Add(amount)
        newCurrencyAmount, _ := NewCurrencyAmount(c.Code, newAmount)

        return newCurrencyAmount
}</span>

func (c CurrencyAmount) Equals(other CurrencyAmount) bool <span class="cov8" title="1">{
        return c.Code.Equals(other.Code) &amp;&amp; c.Value.Equal(other.Value)
}</span>

func (c CurrencyAmount) Validate() error <span class="cov8" title="1">{
        if c.Value.LessThan(decimal.NewFromInt(0)) </span><span class="cov8" title="1">{
                return bizErrors.NewInvalidAmountError(c.Value)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package value_objects

import bizErrors "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/errors"

type CurrencyCode struct {
        Code   string
        Symbol string
}

func NewCurrencyCode(code string) (CurrencyCode, error) <span class="cov8" title="1">{
        symbol, ok := CurrencySymbols[code]
        if !ok </span><span class="cov8" title="1">{
                return CurrencyCode{}, bizErrors.NewInvalidCurrencyCodeError(code)
        }</span>

        <span class="cov8" title="1">return CurrencyCode{Code: code, Symbol: symbol}, nil</span>
}

func (c CurrencyCode) Equals(other CurrencyCode) bool <span class="cov8" title="1">{
        return c.Code == other.Code
}</span>
</pre>
		
		<pre class="file" id="file147" style="display: none">package value_objects

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
)

type PaymentDevice struct {
}

func NewDevicePaymentMethod() PaymentMethod <span class="cov8" title="1">{
        return PaymentMethod{
                Type: enums.PaymentDevice,
        }
}</span>

func (t PaymentDevice) Validate() error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file148" style="display: none">package value_objects

const (
        processing         = "PROCESSING"
        failed             = "FAILED"
        refunded           = "REFUNDED"
        partiallyRefunded  = "PARTIALLY_REFUNDED"
        partiallyProcessed = "PARTIALLY_PROCESSED"
        processed          = "PROCESSED"
        authorized         = "AUTHORIZED"
        canceled           = "CANCELED"
)

type OrderStatus struct {
        status string
}

func OrderStatusFailed() OrderStatus <span class="cov8" title="1">{
        return OrderStatus{status: failed}
}</span>

func OrderStatusProcessing() OrderStatus <span class="cov8" title="1">{
        return OrderStatus{status: processing}
}</span>

func OrderPartialProcessed() OrderStatus <span class="cov8" title="1">{
        return OrderStatus{status: partiallyProcessed}
}</span>

func OrderStatusProcessed() OrderStatus <span class="cov8" title="1">{
        return OrderStatus{status: processed}
}</span>

func OrderStatusAuthorized() OrderStatus <span class="cov8" title="1">{
        return OrderStatus{status: authorized}
}</span>

func OrderStatusCanceled() OrderStatus <span class="cov8" title="1">{
        return OrderStatus{status: canceled}
}</span>

func OrderStatusRefunded() OrderStatus <span class="cov8" title="1">{
        return OrderStatus{status: refunded}
}</span>

func OrderStatusPartiallyRefunded() OrderStatus <span class="cov8" title="1">{
        return OrderStatus{status: partiallyRefunded}
}</span>

func (o OrderStatus) Get() string <span class="cov8" title="1">{
        return o.status
}</span>
</pre>
		
		<pre class="file" id="file149" style="display: none">package value_objects

import (
        "fmt"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        paymentmethodsVo "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects/payment_methods"
)

type SupportedPaymentMethodIF interface {
        Validate() error
}

type SupportedPaymentMethod interface {
        SupportedPaymentMethodIF
        PaymentDevice | CardInfo
}

type PaymentMethodData[T SupportedPaymentMethodIF] struct {
        Data T
}

type PaymentMethod struct {
        Type       enums.PaymentMethodEnum
        CCData     PaymentMethodData[CardInfo]
        DeviceData PaymentMethodData[PaymentDevice]
        TokenCard  PaymentMethodData[paymentmethodsVo.TokenCard]
}

func (p PaymentMethod) GetCC() (CardInfo, error) <span class="cov8" title="1">{
        if p.Type == enums.CCMethod </span><span class="cov8" title="1">{
                return p.CCData.Data, nil
        }</span>

        <span class="cov8" title="1">return CardInfo{}, fmt.Errorf("Data is not a CreditCard")</span>
}

func (p PaymentMethod) GetDevice() (PaymentDevice, error) <span class="cov8" title="1">{
        if p.Type == enums.PaymentDevice </span><span class="cov8" title="1">{
                return PaymentDevice{}, nil
        }</span>

        <span class="cov8" title="1">return PaymentDevice{}, fmt.Errorf("Data is not a PaymentDevice")</span>
}

func (p PaymentMethod) IsDevice() bool <span class="cov8" title="1">{
        return p.Type == enums.PaymentDevice
}</span>

func (p PaymentMethod) IsCC() bool <span class="cov8" title="1">{
        return p.Type.String() == enums.CCMethod.String()
}</span>

func (p PaymentMethod) IsTokenCard() bool <span class="cov8" title="1">{
        return p.Type.String() == enums.TokenCard.String()
}</span>

func (p PaymentMethod) GetTokenCard() (paymentmethodsVo.TokenCard, error) <span class="cov8" title="1">{
        if p.Type == enums.TokenCard </span><span class="cov8" title="1">{
                return p.TokenCard.Data, nil
        }</span>

        <span class="cov8" title="1">return paymentmethodsVo.TokenCard{}, fmt.Errorf("Data is not a TokenCard")</span>
}

func (p PaymentMethod) Validate() error <span class="cov8" title="1">{
        if p.IsCC() </span><span class="cov8" title="1">{
                if err := p.CCData.Data.Validate(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if p.IsDevice() </span><span class="cov8" title="1">{
                if err := p.DeviceData.Data.Validate(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if p.IsTokenCard() </span><span class="cov8" title="1">{
                if err := p.TokenCard.Data.Validate(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("not supported payment method")</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">package paymentmethods

import (
        "fmt"
        "strconv"
        "time"
)

type TokenCard struct {
        Token    string
        CVV      string
        Brand    string
        Last4    string
        Exp      string
        CardType string
        SaveCard bool
        Alias    string
}

const (
        CardTypeCredit = "credit"
        CardTypeDebit  = "debit"

        AmexCard     = "amex"
        VisaCard     = "visa"
        MasterCard   = "mastercard"
        DinersCard   = "diners"
        DiscoverCard = "discover"

        lengthCVV     = 3
        lengthAmexCVV = 4
        lengthLast4   = 4
)

func (t TokenCard) Validate() error <span class="cov8" title="1">{
        if t.Token == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("token is required for credit card payment")
        }</span>

        <span class="cov8" title="1">if t.Brand == AmexCard </span><span class="cov8" title="1">{
                if len(t.CVV) != lengthAmexCVV </span><span class="cov8" title="1">{
                        return fmt.Errorf("CVV must be a 4-digit number for American Express")
                }</span>
        } else<span class="cov8" title="1"> if len(t.CVV) != lengthCVV </span><span class="cov8" title="1">{
                return fmt.Errorf("CVV must be a 3-digit number for credit card payment")
        }</span>

        <span class="cov8" title="1">if t.Exp == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("expiration date is required for credit card payment")
        }</span>

        // Obtiene el año actual y lo convierte a 2 dígitos (ej: 2024 -&gt; 24)
        <span class="cov8" title="1">currentYear := time.Now().Year() % 100

        // Extrae los últimos 2 dígitos del año de expiración de la tarjeta
        // y los convierte de string a int
        expYear, err := strconv.Atoi(t.Exp[2:])
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid expiration year format")
        }</span>

        // Compara el año de expiración con el año actual
        // Si el año de expiración es menor, la tarjeta está vencida
        <span class="cov8" title="1">if expYear &lt; currentYear </span><span class="cov8" title="1">{
                return fmt.Errorf("card is expired")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">package value_objects

type UserType int

const (
        memberType   = "member"
        employeeType = "employee"
        invalidType  = "invalid"
)

const (
        Member UserType = iota
        Employee
        Invalid
)

func NewUserType(userType UserType) UserType <span class="cov8" title="1">{
        return userType
}</span>

func NewUserTypeFromString(userType string) UserType <span class="cov8" title="1">{
        switch userType </span>{
        case memberType:<span class="cov8" title="1">
                return Member</span>
        case employeeType:<span class="cov8" title="1">
                return Employee</span>
        default:<span class="cov8" title="1">
                return Invalid</span>
        }
}

func (s UserType) String() string <span class="cov8" title="1">{
        return [...]string{memberType, employeeType, invalidType}[s]
}</span>

func (s UserType) IsValid() bool <span class="cov8" title="1">{
        return s != Invalid
}</span>

func (s UserType) Equals(other UserType) bool <span class="cov8" title="1">{
        return s == other
}</span>
</pre>
		
		<pre class="file" id="file152" style="display: none">package value_objects

import (
        "errors"
        "net/url"
        "strings"
)

var (
        ErrInvalidWebhookUrl = errors.New("invalid webhook URL")
        ErrEmptyWebhookUrl   = errors.New("webhook URL cannot be empty")
)

type WebhookUrl struct {
        Url string
}

func NewWebhookUrl(url string) WebhookUrl <span class="cov8" title="1">{
        return WebhookUrl{Url: url}
}</span>

func (w WebhookUrl) IsEmpty() bool <span class="cov8" title="1">{
        return len(w.Url) == 0
}</span>

func (w WebhookUrl) ValidateUrl() error <span class="cov8" title="1">{
        if w.Url == "" </span><span class="cov8" title="1">{
                return ErrEmptyWebhookUrl
        }</span>

        // Verificar si la URL contiene espacios o caracteres especiales no permitidos
        <span class="cov8" title="1">if strings.ContainsAny(w.Url, " \t\n\r") </span><span class="cov8" title="1">{
                return ErrInvalidWebhookUrl
        }</span>

        <span class="cov8" title="1">parsedUrl, err := url.Parse(w.Url)
        if err != nil </span><span class="cov0" title="0">{
                return ErrInvalidWebhookUrl
        }</span>

        <span class="cov8" title="1">if parsedUrl.Scheme != "http" &amp;&amp; parsedUrl.Scheme != "https" </span><span class="cov8" title="1">{
                return ErrInvalidWebhookUrl
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (w WebhookUrl) String() string <span class="cov8" title="1">{
        return w.Url
}</span>
</pre>
		
		<pre class="file" id="file153" style="display: none">package capture_flow

import (
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "gitlab.com/clubhub.ai1/gommon/router/middleware/auth"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/capture_flow/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/capture_flow/dto/response"
)

type CaptureFlowHandlerIF interface {
        PaymentCapture(context echo.Context) error
        PaymentRelease(context echo.Context) error
}

type CaptureFlowHandler struct {
        workflow worfkflows.PaymentOrderWorkflow
}

func NewCaptureFlowHandler(workflow worfkflows.PaymentOrderWorkflow) CaptureFlowHandlerIF <span class="cov8" title="1">{
        return &amp;CaptureFlowHandler{
                workflow: workflow,
        }
}</span>

func (h *CaptureFlowHandler) PaymentCapture(context echo.Context) error <span class="cov8" title="1">{
        var body request.CaptureRequest

        authParams := auth.GetParamsFromEchoContext(context)

        fmt.Println("authParams", authParams)

        if err := context.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">if validationErr := body.Validate(); validationErr != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, validationErr.Error())
        }</span>

        <span class="cov8" title="1">err := h.sendFlowSignal(context, body.ReferenceOrderID, body.PaymentID, enums.CapturePayment, "")

        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return context.JSON(http.StatusCreated, response.NewCaptureResponse(body.ReferenceOrderID, body.PaymentID, "CAPTURED"))</span>
}

func (h *CaptureFlowHandler) PaymentRelease(context echo.Context) error <span class="cov8" title="1">{
        var body request.ReleaseRequest

        if err := context.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">if validationErr := body.Validate(); validationErr != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, validationErr.Error())
        }</span>

        <span class="cov8" title="1">err := h.sendFlowSignal(context, body.ReferenceOrderID, body.PaymentID, enums.ReleasePayment, body.Reason)

        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return context.JSON(http.StatusCreated, response.NewReleaseResponse(body.ReferenceOrderID, body.PaymentID, "RELEASED"))</span>
}

func (h *CaptureFlowHandler) sendFlowSignal(context echo.Context,
        ReferenceOrderID string,
        PaymentID string,
        action enums.PaymentFlowActionEnum,
        reason string) error <span class="cov8" title="1">{
        paymentOrderID := utils.NewDeunaOrderID(ReferenceOrderID, PaymentID).GetID()

        err := h.workflow.SendCaptureFlowSignal(context.Request().Context(),
                paymentOrderID, worfkflows.CompleteCaptureFlowSignal{
                        OrderReferecenId: ReferenceOrderID,
                        PaymentID:        PaymentID,
                        Action:           action,
                        Reason:           reason,
                })

        return err
}</span>
</pre>
		
		<pre class="file" id="file154" style="display: none">package request

import "fmt"

type CaptureRequest struct {
        ReferenceOrderID string `json:"reference_order_id" validate:"required"`
        PaymentID        string `json:"payment_id" validate:"required"`
}

func (r *CaptureRequest) Validate() error <span class="cov8" title="1">{
        if r.ReferenceOrderID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("reference_order_id is required")
        }</span>

        <span class="cov8" title="1">if r.PaymentID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("payment_id is required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">package request

import "fmt"

type ReleaseRequest struct {
        ReferenceOrderID string `json:"reference_order_id" validate:"required"`
        PaymentID        string `json:"payment_id" validate:"required"`
        Reason           string `json:"reason"`
}

func (r *ReleaseRequest) Validate() error <span class="cov8" title="1">{
        if r.ReferenceOrderID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("reference_order_id is required")
        }</span>

        <span class="cov8" title="1">if r.PaymentID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("payment_id is required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">package response

type CaptureResponse struct {
        ReferenceOrderID string `json:"reference_order_id"`
        PaymentID        string `json:"payment_id"`
        PaymentStatus    string `json:"payment_status"`
}

func NewCaptureResponse(referenceOrderID string, paymentID string, paymentStatus string) *CaptureResponse <span class="cov8" title="1">{
        return &amp;CaptureResponse{
                ReferenceOrderID: referenceOrderID,
                PaymentID:        paymentID,
                PaymentStatus:    paymentStatus,
        }
}</span>
</pre>
		
		<pre class="file" id="file157" style="display: none">package response

type ReleaseResponse struct {
        ReferenceOrderID string `json:"reference_order_id"`
        PaymentID        string `json:"payment_id"`
        PaymentStatus    string `json:"payment_status"`
}

func NewReleaseResponse(referenceOrderID string, paymentID string, paymentStatus string) *ReleaseResponse <span class="cov8" title="1">{
        return &amp;ReleaseResponse{
                ReferenceOrderID: referenceOrderID,
                PaymentID:        paymentID,
                PaymentStatus:    paymentStatus,
        }
}</span>
</pre>
		
		<pre class="file" id="file158" style="display: none">package card

import (
        "context"
        "net/http"
        "strings"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"

        "github.com/labstack/echo/v4"
        "gitlab.com/clubhub.ai1/gommon/router/middleware/auth"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/usecases"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/usecases/queries"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/card/dto/request"
)

type CardHandlerIF interface {
        CreateCard(context echo.Context) error
        GetCardsByUserID(context echo.Context) error
        TriggerExpiringSoonNotifications(context echo.Context) error
}

type CardHandler struct {
        usecase      usecases.CardUsecaseIF
        getCredicard queries.GetCardUsecaseIF
}

func NewCardHandler(usecase usecases.CardUsecaseIF, getCredicard queries.GetCardUsecaseIF) CardHandlerIF <span class="cov8" title="1">{
        return &amp;CardHandler{
                usecase:      usecase,
                getCredicard: getCredicard,
        }
}</span>

func (p *CardHandler) CreateCard(context echo.Context) error <span class="cov8" title="1">{
        var body request.CardRequest

        ctx := context.Request().Context()

        authParams := auth.GetParamsFromEchoContext(context)
        enterpriseID := authParams.EnterpriseID
        preferredLanguage := context.Request().Header.Get("x-user-language")

        if err := context.Bind(&amp;body); err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">if validationErr := body.Validate(); validationErr != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, validationErr.Error())
        }</span>

        <span class="cov8" title="1">response, err := p.usecase.CreateCard(ctx, body, enterpriseID, preferredLanguage)

        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return context.JSON(http.StatusCreated, response)</span>
}

func (p *CardHandler) GetCardsByUserID(reqContext echo.Context) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(reqContext.Request().Context(), "CardHandler.GetCardsByUserId",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        userID := reqContext.Param("user_id")

                        userID = strings.TrimSpace(userID)

                        authParams := auth.GetParamsFromEchoContext(reqContext)
                        enterpriseID := authParams.EnterpriseID

                        response, err := p.getCredicard.GetCardsByUserID(ctx, userID, enterpriseID)

                        if err != nil </span><span class="cov8" title="1">{
                                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                        }</span>

                        <span class="cov8" title="1">return reqContext.JSON(http.StatusOK, response)</span>
                },
        )
}

func (p *CardHandler) TriggerExpiringSoonNotifications(context echo.Context) error <span class="cov8" title="1">{
        var body request.NotificationCardExpiringSoonRequestDTO

        ctx := context.Request().Context()

        if err := context.Bind(&amp;body); err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">if validationErr := body.Validate(); validationErr != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, validationErr.Error())
        }</span>

        <span class="cov8" title="1">response, err := p.usecase.TriggerCardExpiringSoonNotifications(ctx, body)

        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return context.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file159" style="display: none">package card

import (
        "net/http"

        "github.com/labstack/echo/v4"
        "gitlab.com/clubhub.ai1/gommon/router/middleware/auth"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/usecases"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/card/dto/request"
)

type DeleteCardHandlerIF interface {
        DeleteCard(context echo.Context) error
}

type DeleteCardHandler struct {
        usecase usecases.DeleteCardUseCaseIF
}

func NewDeleteCardHandler(usecase usecases.DeleteCardUseCaseIF) DeleteCardHandlerIF <span class="cov8" title="1">{
        return &amp;DeleteCardHandler{
                usecase: usecase,
        }
}</span>

func (p *DeleteCardHandler) DeleteCard(context echo.Context) error <span class="cov8" title="1">{
        var body request.DeleteCardRequest

        ctx := context.Request().Context()

        authParams := auth.GetParamsFromEchoContext(context)
        enterpriseID := authParams.EnterpriseID
        userLanguage := context.Request().Header.Get("x-user-language")

        if err := context.Bind(&amp;body); err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">if validationErr := body.Validate(); validationErr != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, validationErr.Error())
        }</span>

        <span class="cov8" title="1">response, err := p.usecase.DeleteCard(ctx, body, enterpriseID, userLanguage)

        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov8" title="1">return context.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">package request

import (
        "errors"
        "fmt"
        "strings"

        "github.com/go-playground/validator/v10"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/notification/constants"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/enums"
)

type CardRequest struct {
        UserID         string `json:"user_id" validate:"required,lte=36"`
        CardId         string `json:"card_token_id" validate:"required,lte=50"`
        Alias          string `json:"alias" validate:"omitempty,lte=50"`
        Status         string `json:"status" validate:"required,lte=30,status"`
        CardType       string `json:"card_type" validate:"required"`
        CardBrand      string `json:"company" validate:"required"`
        LastFour       string `json:"last_four" validate:"required"`
        FirstSix       string `json:"first_six" validate:"required"`
        ExpirationDate string `json:"expiration_date" validate:"required"`
        IsDefault      bool   `json:"is_default"`
        IsRecurrent    bool   `json:"is_recurrent"`
}

type DeleteCardRequest struct {
        CardID string `json:"card_id" validate:"required,lte=50"`
        UserID string `json:"user_id" validate:"required,lte=50"`
}

type NotificationCardExpiringSoonRequestDTO struct {
        NotificationChannels []constants.NotificationChannel `json:"notification_channels" validate:"required"`
}

var validate *validator.Validate

func statusValidation(fl validator.FieldLevel) bool <span class="cov8" title="1">{
        status := strings.TrimSpace(fl.Field().String())
        return strings.ToLower(status) == strings.ToLower(enums.Active.String()) || status == ""
}</span>

func (c *CardRequest) Validate() error <span class="cov8" title="1">{
        validate = validator.New()

        validate.RegisterValidation("status", statusValidation)

        err := validate.Struct(c)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">c.Status = strings.TrimSpace(c.Status)
        if c.Status == "" </span><span class="cov0" title="0">{
                c.Status = strings.ToLower(enums.Active.String())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *DeleteCardRequest) Validate() error <span class="cov8" title="1">{
        err := validator.New().Struct(c)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (ncesrdto *NotificationCardExpiringSoonRequestDTO) Validate() error <span class="cov8" title="1">{
        err := validator.New().Struct(ncesrdto)

        if err != nil || len(ncesrdto.NotificationChannels) == 0 </span><span class="cov8" title="1">{
                return errors.New("notification_channels is required")
        }</span>

        <span class="cov8" title="1">for _, channel := range ncesrdto.NotificationChannels </span><span class="cov8" title="1">{
                if !constants.AllowedNotificationChannels[channel] </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid notification channel: %s", channel)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">package collection_account

import (
        "net/http"

        "github.com/labstack/echo/v4"
        "gitlab.com/clubhub.ai1/gommon/router/middleware/auth"
        use_cases "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/collection_account/use_cases"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account/dto/request"
)

type CollectionAccountHandlerIF interface {
        Create(context echo.Context) error
}

type CollectionAccountHandler struct {
        collectionAccountUsecase use_cases.CollectionAccountUsecaseIF
}

func NewCollectionAccountHandler(
        collectionAccountUsecase use_cases.CollectionAccountUsecaseIF,
) CollectionAccountHandlerIF <span class="cov0" title="0">{
        return &amp;CollectionAccountHandler{
                collectionAccountUsecase: collectionAccountUsecase,
        }
}</span>

func (p *CollectionAccountHandler) Create(context echo.Context) error <span class="cov0" title="0">{
        var request request.CollectionAccountRequest

        authParams := auth.GetParamsFromEchoContext(context)
        ctx := context.Request().Context()
        enterpriseID := authParams.EnterpriseID

        if err := context.Bind(&amp;request); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">if validationErr := request.Validate(); validationErr != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, validationErr.Error())
        }</span>

        <span class="cov0" title="0">response, err := p.collectionAccountUsecase.Create(ctx, request, enterpriseID)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return context.JSON(http.StatusCreated, response)</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">package request

import (
        "github.com/go-playground/validator/v10"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
)

type CollectionAccountRequest struct {
        AccountType            enums.AccountType `json:"account_type" validate:"required"`
        CollectionCenterID     string            `json:"collection_center_id" validate:"required"`
        CurrencyCode           string            `json:"currency_code" validate:"required"`
        AccountNumber          string            `json:"account_number" validate:"required,numeric,min=8,max=20"`
        InterbankAccountNumber string            `json:"interbank_account_number"`
        BankName               string            `json:"bank_name"`
        BranchCode             string            `json:"branch_code"`
}

func (p *CollectionAccountRequest) Validate() error <span class="cov0" title="0">{
        err := validator.New().Struct(p)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">package response

import "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_account/entities"

type CollectionAccountResponse struct {
        ID                 string `json:"id"`
        AccountType        string `json:"account_type"`
        CollectionCenterID string `json:"collection_center_id"`
        Currency           string `json:"currency_code"`
        AccountNumber      string `json:"account_number"`
        BankName           string `json:"bank_name"`
}

func NewCollectionAccountResponse(entity entities.CollectionAccountEntity) CollectionAccountResponse <span class="cov8" title="1">{
        return CollectionAccountResponse{
                ID:                 entity.ID.String(),
                AccountType:        entity.AccountType,
                CollectionCenterID: entity.CollectionCenterID,
                Currency:           entity.CurrencyCode,
                AccountNumber:      entity.AccountNumber,
                BankName:           entity.BankName,
        }
}</span>
</pre>
		
		<pre class="file" id="file164" style="display: none">package collection_account_route

import (
        "net/http"

        "github.com/labstack/echo/v4"
        "gitlab.com/clubhub.ai1/gommon/router/middleware/auth"
        usecases "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/collection_account_route/use_cases"
        request "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account_route/dto/request"
)

type CollectionAccountRouteHandlerIF interface {
        Create(context echo.Context) error
        Disable(context echo.Context) error
}

type CollectionAccountRouteRoutes struct {
        usecase usecases.CollectionAccountRouteUsecaseIF
}

func NewCollectionAccountRouteHandler(
        usecase usecases.CollectionAccountRouteUsecaseIF,
) CollectionAccountRouteHandlerIF <span class="cov0" title="0">{
        return &amp;CollectionAccountRouteRoutes{
                usecase: usecase,
        }
}</span>

func (p *CollectionAccountRouteRoutes) Create(context echo.Context) error <span class="cov0" title="0">{
        var request request.CollectionAccountRouteRequest

        auth := auth.GetParamsFromEchoContext(context)
        ctx := context.Request().Context()
        enterpriseId := auth.EnterpriseID

        if err := context.Bind(&amp;request); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">if validationErr := request.Validate(); validationErr != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, validationErr.Error())
        }</span>

        <span class="cov0" title="0">response, err := p.usecase.Create(ctx, request, enterpriseId)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusConflict, err.Error())
        }</span>

        <span class="cov0" title="0">return context.JSON(http.StatusCreated, response)</span>
}

func (p *CollectionAccountRouteRoutes) Disable(context echo.Context) error <span class="cov0" title="0">{
        id := context.Param("id")

        auth := auth.GetParamsFromEchoContext(context)
        ctx := context.Request().Context()
        enterpriseId := auth.EnterpriseID

        response, err := p.usecase.Disable(ctx, id, enterpriseId)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusConflict, err.Error())
        }</span>

        <span class="cov0" title="0">return context.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file165" style="display: none">package request

import (
        "github.com/go-playground/validator/v10"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
)

type CollectionAccountRouteRequest struct {
        CollectionAccountID string                 `json:"collection_account_id" validate:"required"`
        CountryCode         string                 `json:"country_code" validate:"required"`
        CurrencyCode        string                 `json:"currency_code" validate:"required"`
        AssociatedOrigin    enums.AssociatedOrigin `json:"associated_origin" validate:"required"`
}

func (c *CollectionAccountRouteRequest) Validate() error <span class="cov0" title="0">{
        err := validator.New().Struct(c)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file166" style="display: none">package response

import "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"

type CollectionAccountRouteResponse struct {
        ID                  string `json:"id"`
        CollectionAccountID string `json:"collection_account_id"`
        CountryCode         string `json:"country_code"`
        CurrencyCode        string `json:"currency_code"`
}

func NewCollectionAccountRouteResponse(
        entity entities.CollectionAccountRouteEntity,
) CollectionAccountRouteResponse <span class="cov8" title="1">{
        return CollectionAccountRouteResponse{
                ID:                  entity.ID.String(),
                CollectionAccountID: entity.CollectionAccountID,
                CountryCode:         entity.CountryCode,
                CurrencyCode:        entity.CurrencyCode,
                
        }
}</span>

type CollectionAccountRouteDisableResponse struct {
        ID         string `json:"id"`
        Status     string `json:"status"`
        DisabledAt string `json:"disabled_at"`
}
</pre>
		
		<pre class="file" id="file167" style="display: none">package collection_center

import (
        "net/http"

        "github.com/labstack/echo/v4"
        "gitlab.com/clubhub.ai1/gommon/router/middleware/auth"
        use_cases "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/collection_center/use_cases"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_center/dto/request"
)

type CollectionCenterHandlerIF interface {
        Create(context echo.Context) error
}

type CollectionCenterHandler struct {
        collectionCenterUsecase use_cases.CollectionCenterUsecaseIF
}

func NewCollectionCenterHandler(collectionCenterUsecase use_cases.CollectionCenterUsecaseIF) CollectionCenterHandlerIF <span class="cov0" title="0">{
        return &amp;CollectionCenterHandler{
                collectionCenterUsecase: collectionCenterUsecase,
        }
}</span>

func (c *CollectionCenterHandler) Create(context echo.Context) error <span class="cov0" title="0">{
        var request request.CollectionCenterRequest

        authParams := auth.GetParamsFromEchoContext(context)
        ctx := context.Request().Context()
        enterpriseID := authParams.EnterpriseID

        if err := context.Bind(&amp;request); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">if validationErr := request.Validate(); validationErr != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, validationErr.Error())
        }</span>

        <span class="cov0" title="0">response, err := c.collectionCenterUsecase.Create(ctx, request, enterpriseID)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return context.JSON(http.StatusCreated, response)</span>
}
</pre>
		
		<pre class="file" id="file168" style="display: none">package request

import "github.com/go-playground/validator/v10"

type CollectionCenterRequest struct {
        Name                string   `json:"name" validate:"required"`
        Description         string   `json:"description" validate:"required"`
        AvailableCurrencies []string `json:"available_currencies" validate:"required"`
}

func (c *CollectionCenterRequest) Validate() error <span class="cov0" title="0">{
        err := validator.New().Struct(c)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">package response

import "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"

type CollectionCenterResponse struct {
        ID                  string   `json:"id"`
        Name                string   `json:"name"`
        AvailableCurrencies []string `json:"available_currencies"`
        Description         string   `json:"description"`
}

func NewCollectionCenterResponse(entity entities.CollectionCenterEntity) CollectionCenterResponse <span class="cov8" title="1">{
        return CollectionCenterResponse{
                ID:                  entity.ID.String(),
                Name:                entity.Name,
                Description:         entity.Description,
                AvailableCurrencies: entity.AvailableCurrencies,
        }
}</span>
</pre>
		
		<pre class="file" id="file170" style="display: none">package dto

import (
        "errors"

        "github.com/go-playground/validator/v10"
        "github.com/shopspring/decimal"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        vo "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
)

type CreateOrderRequestDTO struct {
        ReferenceOrderID string                 `json:"reference_order_id" validate:"required"`
        CurrencyCode     string                 `json:"currency_code" validate:"required"`
        CountryCode      string                 `json:"country_code" validate:"required"`
        UserType         string                 `json:"user_type" validate:"required"`    // member, employee, etc
        UserID           string                 `json:"user_id" validate:"required"`      // user id
        TotalAmount      decimal.Decimal        `json:"total_amount" validate:"required"` // cambiar a decimal.Decimal
        PhoneNumber      string                 `json:"phone_number"`
        Email            string                 `json:"email" validate:"required"`
        BillingAddress   Address                `json:"billing_address" validate:"required"`
        Metadata         map[string]interface{} `json:"metadata"`
        WebhookUrl       string                 `json:"webhook_url" validate:"required"`
        ClientOrigin     string                 `json:"client_origin"`
        AllowCapture     bool                   `json:"allow_capture"`
}

type Address struct {
        ZipCode     string `json:"zip_code" validate:"required"`
        Street      string `json:"street" validate:"required"`
        CountryCode string `json:"country" validate:"required"`
        City        string `json:"city" validate:"required"`
}

func (c *CreateOrderRequestDTO) Validate() error <span class="cov8" title="1">{
        err := validator.New().Struct(c)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if c.TotalAmount.Sign() &lt;= 0 </span><span class="cov8" title="1">{
                return errors.New("total amount must be greater than 0")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *CreateOrderRequestDTO) ToCommand(enterpriseID string) (command.CreateOrderCommand, error) <span class="cov8" title="1">{
        country, err := vo.NewCountryWithCode(c.CountryCode)

        if err != nil </span><span class="cov8" title="1">{
                return command.CreateOrderCommand{}, err
        }</span>

        <span class="cov8" title="1">currencyCode, err := vo.NewCurrencyCode(c.CurrencyCode)

        if err != nil </span><span class="cov8" title="1">{
                return command.CreateOrderCommand{}, err
        }</span>

        <span class="cov8" title="1">currencyAmount, err := vo.NewCurrencyAmount(currencyCode, c.TotalAmount)

        if err != nil </span><span class="cov0" title="0">{
                return command.CreateOrderCommand{}, err
        }</span>

        <span class="cov8" title="1">userType := vo.NewUserTypeFromString(c.UserType)

        user := entities.NewUser(userType, c.UserID)

        webhookUrl := vo.NewWebhookUrl(c.WebhookUrl)

        return command.NewCreateOrderCommandBuilder().
                WithReferenceID(c.ReferenceOrderID).
                WithTotalAmount(currencyAmount).
                WithPhoneNumber(c.PhoneNumber).
                WithEnterpriseID(enterpriseID).
                WithEmail(c.Email).
                WithUser(user).
                WithCountryCode(country).
                WithBillingAddress(
                        vo.NewAddress(
                                c.BillingAddress.ZipCode,
                                c.BillingAddress.Street,
                                c.BillingAddress.City,
                                country,
                        ),
                ).
                WithCurrencyCode(currencyCode).
                WithCountryCode(country).
                WithMetadata(c.Metadata).
                WithWebhookUrl(webhookUrl).
                WithAllowCapture(c.AllowCapture).
                Build(), nil</span>
}
</pre>
		
		<pre class="file" id="file171" style="display: none">package dto

import (
        "github.com/samber/lo"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
)

type OrderWithPaymentsDTO struct {
        ReferenceOrderID string                   `json:"reference_order_id" validate:"required"`
        CurrencyCode     string                   `json:"currency_code" validate:"required"`
        CountryCode      string                   `json:"country_code" validate:"required"`
        UserType         string                   `json:"user_type" validate:"required"`
        UserID           string                   `json:"user_id" validate:"required"`
        Payments         []PaymentOrderRequestDTO `json:"payments"`
}

func (dto OrderWithPaymentsDTO) ToWorkflowInput() (worfkflows.PaymentWorkflowInput, error) <span class="cov0" title="0">{
        paymentOrderCommandDTO := lo.Map(dto.Payments, func(payment PaymentOrderRequestDTO, _ int) CreatePaymentOrderRequestDTO </span><span class="cov0" title="0">{
                return CreatePaymentOrderRequestDTO{
                        OrderID:                dto.ReferenceOrderID,
                        UserID:                 dto.UserID,
                        UserType:               dto.UserType,
                        PaymentOrderRequestDTO: payment,
                        CurrencyCode:           dto.CurrencyCode,
                        CountryCode:            dto.CountryCode,
                }
        }</span>)

        <span class="cov0" title="0">paymentCommands := make([]command.CreatePaymentOrderCommand, 0)

        for _, payment := range paymentOrderCommandDTO </span><span class="cov0" title="0">{
                if err := payment.Validate(); err != nil </span><span class="cov0" title="0">{
                        return worfkflows.PaymentWorkflowInput{}, err
                }</span>

                <span class="cov0" title="0">paymentCommand, err := payment.Command()

                if err != nil </span><span class="cov0" title="0">{
                        return worfkflows.PaymentWorkflowInput{}, err
                }</span>

                <span class="cov0" title="0">if err := paymentCommand.Validate(); err != nil </span><span class="cov0" title="0">{
                        return worfkflows.PaymentWorkflowInput{}, err
                }</span>

                <span class="cov0" title="0">paymentCommands = append(paymentCommands, paymentCommand)</span>

        }

        <span class="cov0" title="0">return worfkflows.NewPaymentWorkflowInput(dto.ReferenceOrderID, paymentCommands), nil</span>
}
</pre>
		
		<pre class="file" id="file172" style="display: none">package paymentmethods

import "errors"

type CreditCard struct {
        ID  string `json:"id"`
        CVV string `json:"cvv"`
}

func (c *CreditCard) Validate() error <span class="cov8" title="1">{
        if c.ID == "" || c.CVV == "" </span><span class="cov8" title="1">{
                return errors.New("id and cvv are required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file173" style="display: none">package dto

import (
        "errors"

        vo "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
        paymentmethodsDto "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/request/payment_methods"

        "github.com/go-playground/validator/v10"
        "github.com/shopspring/decimal"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/constants"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
)

type CreatePaymentOrderRequestDTO struct {
        OrderID      string `json:"reference_order_id" validate:"required"` // reference to the order
        UserID       string `json:"user_id" validate:"required"`
        UserType     string `json:"user_type" validate:"required"`
        CurrencyCode string `json:"currency_code" validate:"required"`
        CountryCode  string `json:"country_code" validate:"required"`
        PaymentOrderRequestDTO
}

type PaymentOrderRequestDTO struct {
        PaymentOrderID   string           `json:"payment_order_id" validate:"required"`
        AssociatedOrigin string           `json:"associated_origin" validate:"required"`
        PaymentMethod    PaymentMethodDTO `json:"payment_method" validate:"required"`
        Amount           decimal.Decimal  `json:"amount" validate:"required"`
}

type PaymentMethodDTO struct {
        Type       string                         `json:"type" validate:"required"` // CCData, TERMINAL, etc
        CreditCard paymentmethodsDto.CreditCard   `json:"credit_card"`
        TokenCard  paymentmethodsDto.TokenCardDTO `json:"token_card"`
}

func (c *CreatePaymentOrderRequestDTO) Validate() error <span class="cov8" title="1">{
        err := validator.New().Struct(c)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if c.Amount.Sign() &lt;= 0 </span><span class="cov8" title="1">{
                return errors.New("amount must be greater than 0")
        }</span>

        <span class="cov8" title="1">userType := vo.NewUserTypeFromString(c.UserType)
        if !userType.IsValid() </span><span class="cov8" title="1">{
                return errors.New("unsupported user type")
        }</span>

        <span class="cov8" title="1">_, err = vo.NewFromAssociatedOriginString(c.AssociatedOrigin)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if c.PaymentMethod.Type == constants.PaymentMethodCreditCard </span><span class="cov8" title="1">{
                if c.PaymentMethod.CreditCard.ID == "" || c.PaymentMethod.CreditCard.CVV == "" </span><span class="cov8" title="1">{
                        return errors.New("credit card id and cvv are required")
                }</span>
        }

        <span class="cov8" title="1">if c.PaymentMethod.Type == constants.PaymentMethodTokenCard </span><span class="cov8" title="1">{
                if c.PaymentMethod.TokenCard.Token == "" || c.PaymentMethod.TokenCard.CVV == "" </span><span class="cov8" title="1">{
                        return errors.New("token card token and cvv are required")
                }</span>

                <span class="cov8" title="1">if c.PaymentMethod.TokenCard.SaveCard &amp;&amp; c.PaymentMethod.TokenCard.Card.Alias == "" </span><span class="cov8" title="1">{
                        return errors.New("to save card, alias is required")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *CreatePaymentOrderRequestDTO) Command() (command.CreatePaymentOrderCommand, error) <span class="cov8" title="1">{
        userType := vo.NewUserTypeFromString(c.UserType)

        if !userType.IsValid() </span><span class="cov8" title="1">{
                return command.CreatePaymentOrderCommand{}, errors.New("unsupported user type")
        }</span>

        <span class="cov8" title="1">user := entities.NewUser(userType, c.UserID)

        associatedOrigin, err := vo.NewFromAssociatedOriginString(c.AssociatedOrigin)
        if err != nil </span><span class="cov0" title="0">{
                return command.CreatePaymentOrderCommand{}, err
        }</span>

        <span class="cov8" title="1">currencyCode, err := vo.NewCurrencyCode(c.CurrencyCode)
        if err != nil </span><span class="cov8" title="1">{
                return command.CreatePaymentOrderCommand{}, err
        }</span>

        <span class="cov8" title="1">country, err := vo.NewCountryWithCode(c.CountryCode)
        if err != nil </span><span class="cov8" title="1">{
                return command.CreatePaymentOrderCommand{}, err
        }</span>

        <span class="cov8" title="1">currencyAmount, err := vo.NewCurrencyAmount(currencyCode, c.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return command.CreatePaymentOrderCommand{}, err
        }</span>

        <span class="cov8" title="1">builder := command.NewCreatePaymentOrderCommandBuilder().
                WithReferenceOrderID(c.OrderID).
                WithPaymentOrderID(c.PaymentOrderID).
                WithAssociatedOrigin(associatedOrigin).
                WithCurrencyCode(currencyCode).
                WithCountryCode(country.Code).
                WithUser(user)

        switch c.PaymentMethod.Type </span>{
        case constants.PaymentMethodCreditCard:<span class="cov8" title="1">
                if c.PaymentMethod.CreditCard.ID == "" || c.PaymentMethod.CreditCard.CVV == "" </span><span class="cov0" title="0">{
                        return command.CreatePaymentOrderCommand{}, errors.New("credit card id and cvv are required")
                }</span>
                <span class="cov8" title="1">paymentMethod := vo.NewCCPaymentMethod(c.PaymentMethod.CreditCard.ID, c.PaymentMethod.CreditCard.CVV)
                payment := entities.NewPaymentOrder(c.PaymentOrderID, associatedOrigin, currencyAmount, paymentMethod)

                return builder.WithPayment(payment).Build(), nil</span>
        case constants.PaymentMethodTokenCard:<span class="cov8" title="1">
                if c.PaymentMethod.TokenCard.Token == "" || c.PaymentMethod.TokenCard.CVV == "" </span><span class="cov8" title="1">{
                        return command.CreatePaymentOrderCommand{}, errors.New("token card token and cvv are required")
                }</span>

                <span class="cov8" title="1">paymentMethod := vo.NewTokenCardPaymentMethod(c.PaymentMethod.TokenCard.Token,
                        c.PaymentMethod.TokenCard.CVV,
                        c.PaymentMethod.TokenCard.Card.Brand,
                        c.PaymentMethod.TokenCard.Card.Last4,
                        c.PaymentMethod.TokenCard.Card.Exp,
                        c.PaymentMethod.TokenCard.Card.CardType,
                        c.PaymentMethod.TokenCard.Card.Alias,
                        c.PaymentMethod.TokenCard.SaveCard,
                )

                payment := entities.NewPaymentOrder(c.PaymentOrderID, associatedOrigin, currencyAmount, paymentMethod)

                return builder.WithPayment(payment).Build(), nil</span>
        case constants.TerminalPaymentMethod:<span class="cov8" title="1">
                paymentMethod := vo.NewDevicePaymentMethod()
                payment := entities.NewPaymentOrder(c.PaymentOrderID, associatedOrigin, currencyAmount, paymentMethod)

                return builder.WithPayment(payment).Build(), nil</span>
        default:<span class="cov8" title="1">
                return command.CreatePaymentOrderCommand{}, errors.New("unsupported payment method")</span>
        }
}
</pre>
		
		<pre class="file" id="file174" style="display: none">package dto

import (
        "errors"

        "github.com/go-playground/validator/v10"
        "github.com/shopspring/decimal"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/command"
)

type RefundDTO struct {
        ReferenceOrderID string          `json:"reference_order_id" validate:"required"`
        PaymentOrderID   string          `json:"payment_order_id" validate:"required"`
        Reason           string          `json:"reason" validate:"required"`
        Amount           decimal.Decimal `json:"amount"`
        IsTotal          bool            `json:"is_total"`
}

func (r *RefundDTO) Validate() error <span class="cov8" title="1">{
        err := validator.New().Struct(r)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := r.ValidateAmount(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *RefundDTO) ValidateAmount() error <span class="cov8" title="1">{
        if !r.IsTotal </span><span class="cov8" title="1">{
                if r.Amount.IsZero() </span><span class="cov8" title="1">{
                        return errors.New("amount cannot be zero")
                }</span>

                <span class="cov8" title="1">if r.Amount.IsNegative() </span><span class="cov8" title="1">{
                        return errors.New("amount cannot be negative")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *RefundDTO) Command() (command.RefundTotalCommand, error) <span class="cov8" title="1">{
        cmd := command.NewRefundTotalCommand(r.ReferenceOrderID, r.PaymentOrderID, r.Reason)
        return *cmd, nil
}</span>

func (r *RefundDTO) CommandPartial() (command.CreatePartialPaymentRefundCommand, error) <span class="cov8" title="1">{
        cmd := command.NewCreatePartialPaymentRefundCommand(r.ReferenceOrderID, r.PaymentOrderID, r.Amount, r.Reason)
        if err := cmd.Validate(); err != nil </span><span class="cov8" title="1">{
                return command.CreatePartialPaymentRefundCommand{}, err
        }</span>
        <span class="cov8" title="1">return *cmd, nil</span>
}
</pre>
		
		<pre class="file" id="file175" style="display: none">package order

import (
        "net/http"

        "github.com/labstack/echo/v4"
        "gitlab.com/clubhub.ai1/gommon/router/middleware/auth"
        usecases "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/use_cases/create"
        queries "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/use_cases/queries"
        usecasesPaymentOrder "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/use_cases/create"
        dto "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/request"
)

type OrderHandlerIF interface {
        Create(context echo.Context) error
        CreatePaymentOrder(context echo.Context) error
        GetOrder(context echo.Context) error
        GetOrderPayments(context echo.Context) error
}

type OrderHandler struct {
        usecase             usecases.CreateOrderUseCaseIF
        usecaesPaymentOrder usecasesPaymentOrder.CreatePaymentOrderUseCaseIF
        queries             queries.QueriesOrderUseCaseIF
}

func NewOrderHandler(
        usecase usecases.CreateOrderUseCaseIF,
        usecaesPaymentOrder usecasesPaymentOrder.CreatePaymentOrderUseCaseIF,
        queries queries.QueriesOrderUseCaseIF,
) OrderHandlerIF <span class="cov8" title="1">{
        return &amp;OrderHandler{
                usecase:             usecase,
                usecaesPaymentOrder: usecaesPaymentOrder,
                queries:             queries,
        }
}</span>

func (p *OrderHandler) Create(context echo.Context) error <span class="cov8" title="1">{
        var request dto.CreateOrderRequestDTO
        ctx := context.Request().Context()

        authParams := auth.GetParamsFromEchoContext(context)
        enterpriseID := authParams.EnterpriseID

        if err := context.Bind(&amp;request); err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">if err := request.Validate(); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">cmd, err := request.ToCommand(enterpriseID)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">response, err := p.usecase.Create(ctx, cmd)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">return context.JSON(http.StatusCreated, response)</span>
}

func (p *OrderHandler) GetOrder(context echo.Context) error <span class="cov0" title="0">{
        ctx := context.Request().Context()

        orderID := context.Param("order_reference_id")

        authParams := auth.GetParamsFromEchoContext(context)
        enterpriseID := authParams.EnterpriseID

        response, err := p.queries.GetOrderDetail(ctx, orderID, enterpriseID)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">return context.JSON(http.StatusOK, response)</span>
}

func (p *OrderHandler) GetOrderPayments(context echo.Context) error <span class="cov8" title="1">{
        ctx := context.Request().Context()

        authParams := auth.GetParamsFromEchoContext(context)
        enterpriseID := authParams.EnterpriseID

        orderID := context.Param("order_reference_id")

        response, err := p.queries.GetOrderPayments(ctx, orderID, enterpriseID)

        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">return context.JSON(http.StatusOK, response)</span>
}
</pre>
		
		<pre class="file" id="file176" style="display: none">package order

import (
        "github.com/labstack/echo/v4"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows"
        dto "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/request"
        "net/http"
)

type OrderPaymentsHandlerIF interface {
        Pay(context echo.Context) error
}

type OrderPaymentsHandler struct {
        workflow worfkflows.PaymentOrderWorkflow
}

func NewOrderPaymentsHandler(
        workflow worfkflows.PaymentOrderWorkflow,
) OrderPaymentsHandlerIF <span class="cov0" title="0">{
        return &amp;OrderPaymentsHandler{
                workflow: workflow,
        }
}</span>

func (p *OrderPaymentsHandler) Pay(context echo.Context) error <span class="cov0" title="0">{
        var request dto.OrderWithPaymentsDTO
        ctx := context.Request().Context()

        if err := context.Bind(&amp;request); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">cmd, err := request.ToWorkflowInput()

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">wfFuture, err := p.workflow.Call(ctx, cmd.OrderID, cmd)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">var response *worfkflows.PaymentOrderWorkflowOut

        getErr := wfFuture.Get(ctx, &amp;response)

        if getErr != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, getErr.Error())
        }</span>

        <span class="cov0" title="0">return context.JSON(http.StatusCreated, response)</span>
}
</pre>
		
		<pre class="file" id="file177" style="display: none">package order

import (
        "net/http"

        "github.com/labstack/echo/v4"
        dto "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/request"
)

func (p *OrderHandler) CreatePaymentOrder(context echo.Context) error <span class="cov8" title="1">{
        var requestBody dto.CreatePaymentOrderRequestDTO

        ctx := context.Request().Context()

        if err := context.Bind(&amp;requestBody); err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">if err := requestBody.Validate(); err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">cmd, err := requestBody.Command()
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">response, err := p.usecaesPaymentOrder.CreatePaymentOrder(ctx, cmd)

        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">return context.JSON(http.StatusCreated, response)</span>
}
</pre>
		
		<pre class="file" id="file178" style="display: none">package order

import (
        "net/http"

        "github.com/labstack/echo/v4"
        errorx "gitlab.com/clubhub.ai1/go-libraries/observability/errorx/pkg/interfaces/web"
        "gitlab.com/clubhub.ai1/gommon/router/middleware/auth"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/use_cases"
        dto "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/order/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/pkg/common"
)

const (
        schemaValidationError = "SCHEMA_VALIDATION_ERROR"
)

type PaymentRefundHandlerIF interface {
        Refund(context echo.Context) error
}

type PaymentRefundHandler struct {
        totalRefundUseCase   use_cases.RefundTotalUseCaseIF
        partialRefundUseCase use_cases.PartialRefundUseCaseIF
}

func NewPaymentRefundHandler(
        totalRefundUseCase use_cases.RefundTotalUseCaseIF,
        partialRefundUseCase use_cases.PartialRefundUseCaseIF,
) PaymentRefundHandlerIF <span class="cov8" title="1">{
        return &amp;PaymentRefundHandler{
                totalRefundUseCase:   totalRefundUseCase,
                partialRefundUseCase: partialRefundUseCase,
        }
}</span>

func (p *PaymentRefundHandler) Refund(context echo.Context) error <span class="cov8" title="1">{
        var body dto.RefundDTO
        ctx := context.Request().Context()

        authParams := auth.GetParamsFromEchoContext(context)
        enterpriseID := authParams.EnterpriseID

        if err := context.Bind(&amp;body); err != nil </span><span class="cov8" title="1">{
                return context.JSON(http.StatusBadRequest, common.MessageError{
                        Code:    schemaValidationError,
                        Message: err.Error(),
                })
        }</span>

        <span class="cov8" title="1">if err := body.Validate(); err != nil </span><span class="cov8" title="1">{
                return context.JSON(http.StatusBadRequest, common.MessageError{
                        Code:    schemaValidationError,
                        Message: err.Error(),
                })
        }</span>

        <span class="cov8" title="1">if body.IsTotal </span><span class="cov8" title="1">{
                cmd, _ := body.Command()
                response, err := p.totalRefundUseCase.Refund(ctx, cmd, enterpriseID)

                if err != nil </span><span class="cov8" title="1">{
                        return context.JSON(http.StatusBadRequest, errorx.HandleErrorEcho(err))
                }</span>

                <span class="cov8" title="1">return context.JSON(http.StatusOK, response)</span>
        } else<span class="cov8" title="1"> {
                cmd, err := body.CommandPartial()
                if err != nil </span><span class="cov0" title="0">{
                        return context.JSON(http.StatusBadRequest, common.MessageError{Code: schemaValidationError, Message: err.Error()})
                }</span>

                <span class="cov8" title="1">response, err := p.partialRefundUseCase.PartialRefund(ctx, cmd, enterpriseID)
                if err != nil </span><span class="cov8" title="1">{
                        return errorx.HandleErrorEcho(err)
                }</span>

                <span class="cov8" title="1">return context.JSON(http.StatusOK, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file179" style="display: none">package request

import "github.com/go-playground/validator/v10"

type PaymentConceptRequest struct {
        Name        string `json:"name" validate:"required"`
        Code        string `json:"code" validate:"required"`
        Description string `json:"description" validate:"required"`
}

func (p *PaymentConceptRequest) Validate() error <span class="cov0" title="0">{
        err := validator.New().Struct(p)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file180" style="display: none">package response

type PaymentConceptResponse struct {
        ID          string `json:"id"`
        Name        string `json:"name"`
        Code        string `json:"code"`
        Description string `json:"description"`
        CreatedAt   string `json:"created_at"`
}

func NewPaymentConceptResponse(id, name, code, description, createdAt string) PaymentConceptResponse <span class="cov8" title="1">{
        return PaymentConceptResponse{
                ID:          id,
                Name:        name,
                Code:        code,
                Description: description,
                CreatedAt:   createdAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file181" style="display: none">package payment_concept

import (
        "net/http"

        "github.com/labstack/echo/v4"
        "gitlab.com/clubhub.ai1/gommon/router/middleware/auth"
        use_cases "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_concept/use_cases"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_concept/dto/request"
)

type PaymentConceptHandlerIF interface {
        Create(context echo.Context) error
}

type PaymentConceptHandler struct {
        paymentConceptUsecase use_cases.PaymentConceptUsecaseIF
}

func NewPaymentConceptHandler(paymentConceptUsecase use_cases.PaymentConceptUsecaseIF) PaymentConceptHandlerIF <span class="cov0" title="0">{
        return &amp;PaymentConceptHandler{
                paymentConceptUsecase: paymentConceptUsecase,
        }
}</span>

func (p *PaymentConceptHandler) Create(context echo.Context) error <span class="cov0" title="0">{
        var request request.PaymentConceptRequest

        authParams := auth.GetParamsFromEchoContext(context)
        ctx := context.Request().Context()
        enterpriseID := authParams.EnterpriseID

        if err := context.Bind(&amp;request); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">if validationErr := request.Validate(); validationErr != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, validationErr.Error())
        }</span>

        <span class="cov0" title="0">response, err := p.paymentConceptUsecase.Create(ctx, request, enterpriseID)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusConflict, err.Error())
        }</span>

        <span class="cov0" title="0">return context.JSON(http.StatusCreated, response)</span>
}
</pre>
		
		<pre class="file" id="file182" style="display: none">package request

import "github.com/go-playground/validator/v10"

type PaymentMethodRequest struct {
        Name        string `json:"name" validate:"required"`
        Code        string `json:"code" validate:"required"`
        Description string `json:"description" validate:"required"`
}

func (p *PaymentMethodRequest) Validate() error <span class="cov0" title="0">{
        err := validator.New().Struct(p)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file183" style="display: none">package response

type PaymentMethodResponse struct {
        ID        string `json:"id"`
        Name      string `json:"name"`
        Code      string `json:"code"`
        CreatedAt string `json:"created_at"`
}

func NewPaymentMethodResponse(id, name, code, createdAt string) PaymentMethodResponse <span class="cov8" title="1">{
        return PaymentMethodResponse{
                ID:        id,
                Name:      name,
                Code:      code,
                CreatedAt: createdAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file184" style="display: none">package payment_method

import (
        "net/http"

        "github.com/labstack/echo/v4"
        "gitlab.com/clubhub.ai1/gommon/router/middleware/auth"
        usecases "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_method/use_cases"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/payment_method/dto/request"
)

type PaymentMethodHandlerIF interface {
        Create(context echo.Context) error
}

type PaymentMethodHandler struct {
        paymentMethodUsecase usecases.PaymentMethodUseCasesIF
}

func NewPaymentMethodHandler(paymentMethodUsecase usecases.PaymentMethodUseCasesIF) PaymentMethodHandlerIF <span class="cov0" title="0">{
        return &amp;PaymentMethodHandler{
                paymentMethodUsecase: paymentMethodUsecase,
        }
}</span>

func (p *PaymentMethodHandler) Create(context echo.Context) error <span class="cov0" title="0">{
        var request request.PaymentMethodRequest

        authParams := auth.GetParamsFromEchoContext(context)
        ctx := context.Request().Context()
        enterpriseID := authParams.EnterpriseID

        if err := context.Bind(&amp;request); err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov0" title="0">if validationErr := request.Validate(); validationErr != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, validationErr.Error())
        }</span>

        <span class="cov0" title="0">creation, err := p.paymentMethodUsecase.Create(ctx, request, enterpriseID)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">return context.JSON(http.StatusCreated, creation)</span>
}
</pre>
		
		<pre class="file" id="file185" style="display: none">package user

import (
        "context"
        "net/http"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        usecases "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/deuna"

        "github.com/labstack/echo/v4"
        "gitlab.com/clubhub.ai1/gommon/router/middleware/auth"
        commons "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/common"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/user/dto/request"
)

type UserHandlerIF interface {
        Create(context echo.Context) error
        ValidateUser(echoCtx echo.Context) error
}

type UserHandler struct {
        usecase usecases.CreateUserUseDeunaAdapterIF
}

func NewUserHandler(usecase usecases.CreateUserUseDeunaAdapterIF) UserHandlerIF <span class="cov0" title="0">{
        return &amp;UserHandler{
                usecase: usecase,
        }
}</span>

func (u *UserHandler) Create(echoCtx echo.Context) error <span class="cov0" title="0">{
        return decorators.TraceDecoratorNoReturn(echoCtx.Request().Context(), "UserHandler.Create", func(ctx context.Context, span decorators.Span) error </span><span class="cov0" title="0">{
                var body request.CreateUserRequest

                authParams := auth.GetParamsFromEchoContext(echoCtx)
                enterpriseId := authParams.EnterpriseID

                newCtx := commons.SetEnterpriseID(ctx, enterpriseId)

                if err := echoCtx.Bind(&amp;body); err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)

                        return echo.NewHTTPError(http.StatusBadRequest, err.Error())
                }</span>

                <span class="cov0" title="0">response, err := u.usecase.Create(newCtx, body, enterpriseId)

                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)

                        return echo.NewHTTPError(http.StatusConflict, err.Error())
                }</span>

                <span class="cov0" title="0">return echoCtx.JSON(http.StatusCreated, response)</span>
        })
}

func (u *UserHandler) ValidateUser(echoCtx echo.Context) error <span class="cov0" title="0">{
        return decorators.TraceDecoratorNoReturn(echoCtx.Request().Context(), "UserHandler.ValidateUser", func(ctx context.Context, span decorators.Span) error </span><span class="cov0" title="0">{
                authParams := auth.GetParamsFromEchoContext(echoCtx)
                enterpriseId := authParams.EnterpriseID

                request := request.CreateUserRequest{
                        UserID:   authParams.UserID,
                        UserType: authParams.UserType,
                }

                newCtx := commons.SetEnterpriseID(ctx, enterpriseId)

                response, err := u.usecase.ValidateUser(newCtx, request, enterpriseId)

                if err != nil </span><span class="cov0" title="0">{
                        span.RecordError(err)

                        return echo.NewHTTPError(http.StatusConflict, err.Error())
                }</span>

                <span class="cov0" title="0">return echoCtx.JSON(http.StatusCreated, response)</span>
        })
}
</pre>
		
		<pre class="file" id="file186" style="display: none">package webhooks

import (
        "fmt"
        "net/http"
        "strings"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils"

        "github.com/labstack/echo/v4"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/worfkflows"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        dto "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/webhooks/dto/request"
)

type WebhooksHandlerIF interface {
        DeunaWebhookNotifyOrder(context echo.Context) error
}

type WebhookHandler struct {
        workflow worfkflows.PaymentOrderWorkflow
}

func NewWebhookHandler(workflow worfkflows.PaymentOrderWorkflow) WebhooksHandlerIF <span class="cov0" title="0">{
        return &amp;WebhookHandler{
                workflow: workflow,
        }
}</span>

func (p *WebhookHandler) DeunaWebhookNotifyOrder(context echo.Context) error <span class="cov8" title="1">{
        var orderWebhookRequest dto.WebhookOrderDTO

        if err := context.Bind(&amp;orderWebhookRequest); err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">paymentStatus, err := enums.NewPaymentStatusFromString(strings.ToUpper(orderWebhookRequest.Order.Payment.Data.Status))

        if err != nil </span><span class="cov8" title="1">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">deunaOrderID, err := utils.ExtractFromDeunaOrderID(orderWebhookRequest.Order.OrderID)

        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, err.Error())
        }</span>

        <span class="cov8" title="1">fmt.Println("orderWebhookRequest: ", orderWebhookRequest)

        signalRequest := worfkflows.PaymentProcessedSignal{
                AuthorizationCode:   orderWebhookRequest.Order.Payment.Data.AuthorizationCode,
                Status:              paymentStatus,
                OrderStatusString:   orderWebhookRequest.Order.Status,
                OrderID:             deunaOrderID.GetOrderID(),
                PaymentID:           deunaOrderID.GetPaymentID(),
                PaymentStatusString: orderWebhookRequest.Order.Payment.Data.Status,
                PaymentReason:       orderWebhookRequest.Order.Payment.Data.Reason,
                PaymentCard: worfkflows.CardData{
                        CardBrand: orderWebhookRequest.Order.Payment.Data.FromCard.CardBrand,
                        CardLast4: orderWebhookRequest.Order.Payment.Data.FromCard.LastFour,
                        CardType:  orderWebhookRequest.Order.PaymentMethod,
                },
        }

        return p.workflow.SendProcessedSignal(context.Request().Context(), orderWebhookRequest.Order.OrderID, signalRequest)</span>
}
</pre>
		
		<pre class="file" id="file187" style="display: none">package aws

import (
        "context"
        "fmt"
        "log"
        "os"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"

        "gitlab.com/clubhub.ai1/gommon/logger"

        "github.com/aws/aws-sdk-go-v2/aws"
        awsconfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        awsDynamodb "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "gitlab.com/clubhub.ai1/gommon/nosql/dynamodb"
)

func GetLocalConfig() (aws.Config, error) <span class="cov0" title="0">{
        awsConfig := config.Config().Aws
        customResolver := aws.EndpointResolverWithOptionsFunc(
                func(service, region string, options ...interface{}) (aws.Endpoint, error) </span><span class="cov0" title="0">{
                        if service == awsDynamodb.ServiceID &amp;&amp; region == awsConfig.Region </span><span class="cov0" title="0">{
                                return aws.Endpoint{
                                        PartitionID:       "aws",
                                        URL:               awsConfig.EndpointURL,
                                        SigningRegion:     awsConfig.Region,
                                        HostnameImmutable: true,
                                }, nil
                        }</span>

                        <span class="cov0" title="0">return aws.Endpoint{}, fmt.Errorf("unknown endpoint requested")</span>
                })
        <span class="cov0" title="0">awsCfg, err := awsconfig.LoadDefaultConfig(context.TODO(),
                awsconfig.WithRegion(awsConfig.Region),
                awsconfig.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(
                        awsConfig.AccessKeyID,
                        awsConfig.SecretAccessKey,
                        "")),
                awsconfig.WithEndpointResolverWithOptions(customResolver),
        )

        if err != nil </span><span class="cov0" title="0">{
                return awsCfg, fmt.Errorf("failed to load LOCAL configuration, %w", err)
        }</span>

        <span class="cov0" title="0">return awsCfg, nil</span>
}

func NewDynamoClient(cfg config.Configuration, logger logger.LoggerInterface) *dynamodb.Client <span class="cov0" title="0">{
        awsCfg, err := awsconfig.LoadDefaultConfig(context.TODO(), awsconfig.WithRegion(cfg.Aws.Region))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to load configuration, %v", err)
        }</span>

        <span class="cov0" title="0">if e := os.Getenv("ENVIRONMENT"); e == "local" </span><span class="cov0" title="0">{
                awsCfg, err = GetLocalConfig()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal(err)
                }</span>
        }

        <span class="cov0" title="0">awsDynamoClient := awsDynamodb.NewFromConfig(awsCfg)

        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span>

        <span class="cov0" title="0">dynamodbClient, err := dynamodb.New(awsDynamoClient)

        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span>

        <span class="cov0" title="0">return dynamodbClient</span>
}
</pre>
		
		<pre class="file" id="file188" style="display: none">package aws

import (
        "context"
        "fmt"
        "github.com/aws/aws-sdk-go-v2/aws"
        awsconfig "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"
)

type S3ClientImpl struct {
        client *s3.Client
}

func NewS3WithClient(client *s3.Client) S3Client <span class="cov8" title="1">{
        return &amp;S3ClientImpl{client: client}
}</span>

func NewS3Client() (S3Client, error) <span class="cov0" title="0">{
        if config.IsLocal() </span><span class="cov0" title="0">{
                // Return a mock implementation for local development
                return &amp;S3ClientImpl{}, nil
        }</span>

        <span class="cov0" title="0">s3Client, err := newS3Client(config.Config())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create S3 client: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;S3ClientImpl{
                client: s3Client,
        }, nil</span>
}

func (s *S3ClientImpl) PutObject(ctx context.Context, params *s3.PutObjectInput) (*s3.PutObjectOutput, error) <span class="cov8" title="1">{
        return s.client.PutObject(ctx, params)
}</span>

func newS3Client(cfg config.Configuration) (*s3.Client, error) <span class="cov0" title="0">{
        awsCfg, err := awsConf(cfg.Aws)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load AWS configuration: %w", err)
        }</span>

        <span class="cov0" title="0">s3Client := s3.NewFromConfig(awsCfg)
        return s3Client, nil</span>
}

func awsConf(awsConfig config.Aws) (aws.Config, error) <span class="cov0" title="0">{
        ctx := context.Background()

        baseCfg, err := awsconfig.LoadDefaultConfig(ctx,
                awsconfig.WithRegion(awsConfig.Region),
        )

        if err != nil </span><span class="cov0" title="0">{
                return aws.Config{}, fmt.Errorf("failed to load AWS configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return baseCfg, nil</span>
}
</pre>
		
		<pre class="file" id="file189" style="display: none">package db

import (
        "gitlab.com/clubhub.ai1/gommon/sql/common"
        "gitlab.com/clubhub.ai1/gommon/sql/gorm"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"
        gOrm "gorm.io/gorm"
)

const (
        maxIdle  = 1
        logQuery = true
        singular = true
)

func NewPostgresConnection() *gOrm.DB <span class="cov0" title="0">{
        postgresCfg := config.Config().Db

        return gorm.CreateDataBaseConnection(common.Connection{
                User:        postgresCfg.User,
                Password:    postgresCfg.Password,
                Host:        postgresCfg.Host,
                Port:        postgresCfg.Port,
                DBName:      postgresCfg.DB,
                DBProvider:  common.Postgresql,
                PoolSize:    postgresCfg.PoolSize,
                MaxIdleTime: maxIdle,
        }, common.AdditionalConfig{
                LogQuery:      logQuery,
                SingularTable: singular,
        })
}</span>
</pre>
		
		<pre class="file" id="file190" style="display: none">package config

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"
)

const DeunaApiKeyHeader = "x-api-key"

type DeUnaApiConfig struct {
        URL          string
        ApiKey       string
        PublicKeyPEM string
}

func DeunaHttpConfig() *DeUnaApiConfig <span class="cov0" title="0">{

        return &amp;DeUnaApiConfig{
                URL:          config.Config().DeUnaApi.URL,
                ApiKey:       config.Config().DeUnaApi.ApiKey,
                PublicKeyPEM: config.Config().DeUnaApi.PublicKeyPEM,
        }
}</span>
</pre>
		
		<pre class="file" id="file191" style="display: none">package config

import (
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm"
        "gitlab.com/clubhub.ai1/go-libraries/observability/clients/http/instrument"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"
        "time"
)

const (
        MailServiceTimeout        = 10 * time.Second
        broadcastNotificationPath = "/api/v1/notifications/broadcast"
)

type MailClientHTTPIF interface {
        instrument.Client
}

type MailHTTPClientImpl struct {
        instrument.Client
}

func NewMailHTTPClient(tracer apm.Tracer) MailClientHTTPIF <span class="cov0" title="0">{
        if config.Config().MailService.URL == "" </span><span class="cov0" title="0">{
                panic("mail service url is empty")</span>
        }

        <span class="cov0" title="0">return &amp;MailHTTPClientImpl{
                instrument.NewInstrumentedClient(
                        instrument.WithTraceOptions(tracer.GetTracer(), instrument.TraceRequest, instrument.TraceResponse),
                        instrument.WithBaseUrl(config.Config().MailService.URL),
                        instrument.WithRequestTimeout(MailServiceTimeout),
                ),
        }</span>
}
</pre>
		
		<pre class="file" id="file192" style="display: none">package http

import (
        "context"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "encoding/base64"
        "encoding/pem"
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm"
        "net/http"

        "gitlab.com/clubhub.ai1/go-libraries/observability/clients/http/instrument"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources/dto/response"
        deunaConfig "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/config"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/utils"
)

type DeUnaAuthHTTPClient struct {
        Config deunaConfig.DeUnaApiConfig
        instrument.Client
}

func NewDeUnaAuthHTTPClient(config *deunaConfig.DeUnaApiConfig, tracer apm.Tracer) resources.DeunaAuthResourceIF <span class="cov8" title="1">{
        headerApiKey := deunaConfig.DeunaApiKeyHeader
        return &amp;DeUnaAuthHTTPClient{
                Config: *config,
                Client: instrument.NewInstrumentedClient(
                        instrument.WithTraceOptions(tracer.GetTracer(), instrument.TraceRequest, instrument.TraceResponse),
                        instrument.WithBaseUrl(config.URL),
                        instrument.WithRequestTimeout(deUnaTimeout),
                        instrument.WithHeaders(map[string]string{
                                headerApiKey:   config.ApiKey,
                                "Content-Type": "application/json",
                        }),
                ),
        }
}</span>

// para integrar auth user
func (d DeUnaAuthHTTPClient) AuthUser(
        ctx context.Context,
        request request.DeunaAuthUserRequestDTO,
) (response.DeunaAuthResponseDTO, error) <span class="cov8" title="1">{
        publicKeyPEM := utils.Base64Decode(d.Config.PublicKeyPEM)
        authMessage, err := generateAuthMessage(request.Email, publicKeyPEM)

        if err != nil </span><span class="cov8" title="1">{
                return response.DeunaAuthResponseDTO{}, fmt.Errorf("error generating auth message: %w", err)
        }</span>

        <span class="cov8" title="1">var res response.DeunaAuthResponseDTO

        httpResponse, err := d.Client.NewRequestWithOptions(
                instrument.WithHeadersLogConfig(true, deunaConfig.DeunaApiKeyHeader),
        ).
                SetResult(&amp;res).
                SetBody(request).
                SetContext(ctx).
                SetHeader("X-Auth-Message", authMessage).
                SetQueryParam("load_profile_data", "true").
                Post("/users/external-authorize")

        if err != nil </span><span class="cov8" title="1">{
                return response.DeunaAuthResponseDTO{}, fmt.Errorf("failed to authenticate user: %w", err)
        }</span>

        <span class="cov8" title="1">if httpResponse.StatusCode() == http.StatusNotFound </span><span class="cov8" title="1">{
                return response.DeunaAuthResponseDTO{}, fmt.Errorf("user not found with status: %d", httpResponse.StatusCode())
        }</span>

        <span class="cov8" title="1">if httpResponse.IsError() || httpResponse.StatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                return response.DeunaAuthResponseDTO{}, fmt.Errorf("authenticate user failed with status: %d", httpResponse.StatusCode())
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}

func generateAuthMessage(email, publicKeyPEM string) (string, error) <span class="cov8" title="1">{
        block, _ := pem.Decode([]byte(publicKeyPEM))
        if block == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to parse PEM block containing the public key")
        }</span>

        <span class="cov8" title="1">pub, err := x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse DER encoded public key: %w", err)
        }</span>

        <span class="cov8" title="1">rsaPub, ok := pub.(*rsa.PublicKey)
        if !ok </span><span class="cov8" title="1">{
                return "", fmt.Errorf("key type is not RSA")
        }</span>

        <span class="cov8" title="1">data := []byte(fmt.Sprintf(`{"email": "%s"}`, email))
        encryptedData, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, rsaPub, data, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encrypt data: %w", err)
        }</span>

        <span class="cov8" title="1">return base64.StdEncoding.EncodeToString(encryptedData), nil</span>
}
</pre>
		
		<pre class="file" id="file193" style="display: none">package http

import (
        "context"
        "fmt"
        "net/http"

        "github.com/go-resty/resty/v2"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/go-libraries/observability/clients/http/instrument"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/resources/dto/request"
        deunaConfig "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/config"
)

type DeUnaCaptureFlowHTTPClient struct {
        instrument.Client
}

const (
        captureFlowError = "%s request failed with status: %d"
)

func NewDeUnaCaptureFlowHTTPClient(config *deunaConfig.DeUnaApiConfig) resources.DeunaCaptureFlowResourceIF <span class="cov8" title="1">{
        apiKeyheader := deunaConfig.DeunaApiKeyHeader
        return &amp;DeUnaCaptureFlowHTTPClient{
                instrument.NewInstrumentedClient(
                        instrument.WithBaseUrl(config.URL),
                        instrument.WithRequestTimeout(deUnaTimeout),
                        instrument.WithHeaders(map[string]string{
                                apiKeyheader:   config.ApiKey,
                                "Content-Type": "application/json",
                        }),
                ),
        }
}</span>

// handleDeUnaResponse maneja la lógica común de respuesta HTTP para los métodos de DeUna
func (d DeUnaCaptureFlowHTTPClient) handleDeUnaResponse(
        httpResponse *resty.Response,
        operation string,
) (bool, error) <span class="cov8" title="1">{
        if httpResponse.IsError() </span><span class="cov8" title="1">{
                return false, fmt.Errorf(captureFlowError, operation, httpResponse.StatusCode())
        }</span>

        <span class="cov8" title="1">if httpResponse.StatusCode() == http.StatusConflict </span><span class="cov0" title="0">{
                return false, fmt.Errorf(captureFlowError, operation, httpResponse.StatusCode())
        }</span>

        <span class="cov8" title="1">if httpResponse.StatusCode() == http.StatusOK || httpResponse.StatusCode() == http.StatusNoContent </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov0" title="0">return false, nil</span>
}

// Void
func (d DeUnaCaptureFlowHTTPClient) Release(
        oldCtx context.Context,
        orderToken string,
        reason string,
) (bool, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[bool](
                oldCtx,
                "DeUnaCaptureFlowHTTPClient.Release",
                func(ctx context.Context, span decorators.Span) (bool, error) </span><span class="cov8" title="1">{
                        body := request.ReleaseRequestDTO{
                                Reason: reason,
                        }

                        httpResponse, err := d.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true, deunaConfig.DeunaApiKeyHeader),
                        ).
                                SetBody(body).
                                SetContext(ctx).
                                Post(fmt.Sprintf("/merchants/orders/%s/void", orderToken))

                        if err != nil </span><span class="cov0" title="0">{
                                return false, fmt.Errorf(captureFlowError, "Release", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">return d.handleDeUnaResponse(httpResponse, "Release")</span>
                },
        )
}

func (d DeUnaCaptureFlowHTTPClient) Capture(
        oldCtx context.Context,
        orderToken string,
        amount int64,
) (bool, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[bool](
                oldCtx,
                "DeUnaCaptureFlowHTTPClient.Capture",
                func(ctx context.Context, span decorators.Span) (bool, error) </span><span class="cov8" title="1">{
                        body := request.CaptureRequestDTO{
                                Amount: amount,
                        }

                        httpResponse, err := d.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true, deunaConfig.DeunaApiKeyHeader),
                        ).
                                SetBody(body).
                                SetContext(ctx).
                                Post(fmt.Sprintf("/merchants/orders/%s/capture", orderToken))

                        if err != nil </span><span class="cov0" title="0">{
                                return false, fmt.Errorf(captureFlowError, "Capture", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">return d.handleDeUnaResponse(httpResponse, "Capture")</span>
                },
        )
}
</pre>
		
		<pre class="file" id="file194" style="display: none">package http

import (
        "context"
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm"
        "net/http"

        deunaConfig "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/config"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/go-libraries/observability/clients/http/instrument"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/resources/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/resources/dto/response"
)

var DeunaEmptyBody = fmt.Errorf("empty body")

type DeUnaCardHTTPClient struct {
        instrument.Client
}

func NewDeUnaCardHTTPClient(config *deunaConfig.DeUnaApiConfig, tracer apm.Tracer) resources.DeunaCardResourceIF <span class="cov8" title="1">{
        apiKeyHeader := deunaConfig.DeunaApiKeyHeader
        return &amp;DeUnaCardHTTPClient{
                instrument.NewInstrumentedClient(
                        instrument.WithTraceOptions(tracer.GetTracer(), instrument.TraceRequest, instrument.TraceResponse),
                        instrument.WithBaseUrl(config.URL),
                        instrument.WithRequestTimeout(deUnaTimeout),
                        instrument.WithHeaders(map[string]string{
                                apiKeyHeader:   config.ApiKey,
                                "Content-Type": "application/json",
                        }),
                ),
        }
}</span>

func (d DeUnaCardHTTPClient) CreateCard(
        oldCtx context.Context,
        body request.CreateCardRequestDTO,
        userId string,
        token string,
) (response.CardResponseDataDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[response.CardResponseDataDTO](
                oldCtx,
                "DeUnaCardHTTPClient.CreateCard",
                func(ctx context.Context, span decorators.Span) (response.CardResponseDataDTO, error) </span><span class="cov8" title="1">{
                        httpResponse, err := d.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true, deunaConfig.DeunaApiKeyHeader),
                        ).
                                SetHeader("Authorization", fmt.Sprintf("Bearer %s", token)).
                                SetResult(new(response.CardResponseDTO)).
                                SetBody(body).
                                SetContext(ctx).
                                Post(fmt.Sprintf("/users/%s/cards", userId))

                        if err != nil </span><span class="cov8" title="1">{
                                return response.CardResponseDataDTO{}, fmt.Errorf("failed to create card request: %w", err)
                        }</span>

                        <span class="cov8" title="1">if httpResponse.StatusCode() == http.StatusConflict </span><span class="cov8" title="1">{
                                return response.CardResponseDataDTO{}, fmt.Errorf("the card already exist with status: %d", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">if httpResponse.StatusCode() == http.StatusUnprocessableEntity </span><span class="cov8" title="1">{
                                return response.CardResponseDataDTO{}, fmt.Errorf("operation denied by anti fraud rules: %d", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">if httpResponse.IsError() || httpResponse.StatusCode() != http.StatusCreated </span><span class="cov8" title="1">{
                                return response.CardResponseDataDTO{}, fmt.Errorf("create card request failed with status: %d", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">responseDTO, ok := httpResponse.Result().(*response.CardResponseDTO)
                        if !ok || responseDTO == nil </span><span class="cov0" title="0">{
                                return response.CardResponseDataDTO{}, fmt.Errorf("failed to cast or parse response")
                        }</span>

                        <span class="cov8" title="1">if responseDTO.IsEmpty() </span><span class="cov8" title="1">{
                                return response.CardResponseDataDTO{}, DeunaEmptyBody
                        }</span>

                        <span class="cov8" title="1">return responseDTO.Data, nil</span>
                },
        )
}

func (d DeUnaCardHTTPClient) DeleteCard(
        oldCtx context.Context,
        body request.DeleteCardRequestDTO,
        token string,
) (response.DeleteCardResponseDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[response.DeleteCardResponseDTO](
                oldCtx,
                "DeUnaCardHTTPClient.DeleteCard",
                func(ctx context.Context, span decorators.Span) (response.DeleteCardResponseDTO, error) </span><span class="cov8" title="1">{
                        httpResponse, err := d.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true, deunaConfig.DeunaApiKeyHeader),
                        ).
                                SetHeaders(map[string]string{
                                        "Authorization": fmt.Sprintf("Bearer %s", token),
                                }).
                                SetResult(new(response.DeleteCardResponseDTO)).
                                SetContext(ctx).
                                Delete(fmt.Sprintf("/users/%s/cards/%s", body.UserId, body.CardId))

                        if err != nil </span><span class="cov8" title="1">{
                                return response.DeleteCardResponseDTO{}, err
                        }</span>

                        <span class="cov8" title="1">if httpResponse.IsError() </span><span class="cov8" title="1">{
                                return response.DeleteCardResponseDTO{}, fmt.Errorf("error deleting card DEUNA")
                        }</span>

                        <span class="cov8" title="1">result, ok := httpResponse.Result().(*response.DeleteCardResponseDTO)

                        if !ok || result == nil </span><span class="cov0" title="0">{
                                return response.DeleteCardResponseDTO{}, fmt.Errorf("error parsing response")
                        }</span>

                        <span class="cov8" title="1">if httpResponse.StatusCode() != http.StatusNoContent </span><span class="cov8" title="1">{
                                return response.DeleteCardResponseDTO{}, fmt.Errorf("Error deleting card DEUNA")
                        }</span>

                        <span class="cov8" title="1">return *result, nil</span>
                },
        )
}
</pre>
		
		<pre class="file" id="file195" style="display: none">package http

import (
        "context"
        "errors"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm"
        deunaConfig "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/config"
        "net/http"

        "gitlab.com/clubhub.ai1/go-libraries/observability/clients/http/instrument"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources/dto/response"
)

type DeUnaLoginHTTPClient struct {
        instrument.Client
}

func NewDeUnaLoginHTTPClient(tracer apm.Tracer) resources.DeunaLoginResourceIF <span class="cov0" title="0">{
        apiKeyHeader := deunaConfig.DeunaApiKeyHeader
        return &amp;DeUnaLoginHTTPClient{
                instrument.NewInstrumentedClient(
                        instrument.WithBaseUrl(config.Config().DeUnaApi.URL),
                        instrument.WithTraceOptions(tracer.GetTracer(), instrument.TraceRequest, instrument.TraceResponse),
                        instrument.WithRequestTimeout(deUnaTimeout),
                        instrument.WithHeaders(map[string]string{
                                apiKeyHeader:   config.Config().DeUnaApi.ApiKey,
                                "Content-Type": "application/json",
                        }),
                ),
        }
}</span>

func (d DeUnaLoginHTTPClient) Login(
        ctx context.Context,
        request request.LoginUserDeUnaRequestDTO,
) (response.LoginResponseDTO, error) <span class="cov0" title="0">{
        var responseBody response.LoginResponseDTO

        record, err := d.Client.NewRequestWithOptions(
                instrument.WithHeadersLogConfig(true, deunaConfig.DeunaApiKeyHeader),
        ).
                SetResult(&amp;responseBody).
                SetBody(request).
                SetContext(ctx).
                Post("/users/login?type=guest")

        if err != nil </span><span class="cov0" title="0">{
                return response.LoginResponseDTO{}, err
        }</span>

        <span class="cov0" title="0">if record.StatusCode() != http.StatusOK </span><span class="cov0" title="0">{
                return response.LoginResponseDTO{}, errors.New("error login user")
        }</span>

        <span class="cov0" title="0">return responseBody, nil</span>
}
</pre>
		
		<pre class="file" id="file196" style="display: none">package http

import (
        "context"
        "fmt"
        "net/http"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/go-libraries/observability/clients/http/instrument"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/resources/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/resources/dto/response"
        deunaConfig "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/config"
)

const authorizationHeaderFormat = "Bearer %s"

type DeUnaOrderHTTPClient struct {
        instrument.Client
}

func NewDeUnaOrderHTTPClient(config *deunaConfig.DeUnaApiConfig) resources.DeunaOrderResourceIF <span class="cov8" title="1">{
        apiKeyheader := deunaConfig.DeunaApiKeyHeader
        return &amp;DeUnaOrderHTTPClient{
                instrument.NewInstrumentedClient(
                        instrument.WithBaseUrl(config.URL),
                        instrument.WithRequestTimeout(deUnaTimeout),
                        instrument.WithHeaders(map[string]string{
                                apiKeyheader:   config.ApiKey,
                                "Content-Type": "application/json",
                        }),
                ),
        }
}</span>

func (d DeUnaOrderHTTPClient) CreateOrder(
        oldCtx context.Context,
        body request.CreateDeunaOrderRequestDTO,
) (response.DeunaOrderResponseDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[response.DeunaOrderResponseDTO](
                oldCtx,
                "DeUnaOrderHTTPClient.CreateOrder",
                func(ctx context.Context, span decorators.Span) (response.DeunaOrderResponseDTO, error) </span><span class="cov8" title="1">{
                        var res response.DeunaOrderResponseDTO

                        httpResponse, err := d.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true, deunaConfig.DeunaApiKeyHeader),
                        ).
                                SetResult(&amp;res).
                                SetBody(body).
                                SetContext(ctx).
                                Post("/merchants/orders")

                        if err != nil </span><span class="cov0" title="0">{
                                return response.DeunaOrderResponseDTO{}, fmt.Errorf("failed to create order request: %w", err)
                        }</span>

                        <span class="cov8" title="1">if httpResponse.StatusCode() == http.StatusConflict </span><span class="cov8" title="1">{
                                return response.DeunaOrderResponseDTO{}, fmt.Errorf("invalid payment method with status: %d", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">if httpResponse.IsError() || httpResponse.StatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                                return response.DeunaOrderResponseDTO{}, fmt.Errorf("create order request failed with status: %d", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">return res, nil</span>
                },
        )
}

func (d DeUnaOrderHTTPClient) GetOrder(
        oldCtx context.Context,
        orderToken string,
) (response.DeunaOrderResponseDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[response.DeunaOrderResponseDTO](
                oldCtx,
                "DeUnaOrderHTTPClient.GetOrder",
                func(ctx context.Context, span decorators.Span) (response.DeunaOrderResponseDTO, error) </span><span class="cov8" title="1">{
                        var res response.DeunaOrderResponseDTO

                        httpResponse, err := d.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true, deunaConfig.DeunaApiKeyHeader),
                        ).
                                SetResult(&amp;res).
                                SetContext(ctx).
                                Get(fmt.Sprintf("/merchants/orders/%s", orderToken))

                        if err != nil </span><span class="cov0" title="0">{
                                return response.DeunaOrderResponseDTO{}, fmt.Errorf("failed to get order: %w", err)
                        }</span>

                        <span class="cov8" title="1">if httpResponse.IsError() || httpResponse.StatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                                return response.DeunaOrderResponseDTO{}, fmt.Errorf("get order failed with status: %d", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">return res, nil</span>
                },
        )
}

func (d DeUnaOrderHTTPClient) ExpireOrder(
        oldCtx context.Context,
        orderToken string,
) error <span class="cov8" title="1">{

        return decorators.TraceDecoratorNoReturn(
                oldCtx,
                "DeUnaOrderHTTPClient.ExpireOrder",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        httpResponse, err := d.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true, deunaConfig.DeunaApiKeyHeader),
                        ).
                                SetContext(ctx).
                                Delete(fmt.Sprintf("/merchants/orders/%s/expire", orderToken))

                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to expire order request: %w", err)
                        }</span>

                        <span class="cov8" title="1">if httpResponse.IsError() || httpResponse.StatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                                return fmt.Errorf("expire order request failed with status: %d", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                },
        )
}
</pre>
		
		<pre class="file" id="file197" style="display: none">package http

import (
        "context"
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils"
        "net/http"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/go-libraries/observability/clients/http/instrument"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/resources/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/resources/dto/response"
        deunaConfig "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/config"
)

const (
        failedPaymentRefund string = "failed to refund payment"
)

type DeUnaPaymentHTTPClient struct {
        instrument.Client
}

func NewDeUnaPaymentHTTPClient(config *deunaConfig.DeUnaApiConfig, tracer apm.Tracer) resources.DeunaPaymentResourceIF <span class="cov8" title="1">{
        apiKeyHeader := deunaConfig.DeunaApiKeyHeader

        return &amp;DeUnaPaymentHTTPClient{
                instrument.NewInstrumentedClient(
                        instrument.WithBaseUrl(config.URL),
                        instrument.WithTraceOptions(tracer.GetTracer(), instrument.TraceRequest, instrument.TraceResponse),
                        instrument.WithRequestTimeout(deUnaTimeout),
                        instrument.WithHeaders(map[string]string{
                                apiKeyHeader:   config.ApiKey,
                                "Content-Type": "application/json",
                        }),
                ),
        }
}</span>

func handleError(err error) error <span class="cov8" title="1">{
        return fmt.Errorf("%s: %w", failedPaymentRefund, err)
}</span>

func (d DeUnaPaymentHTTPClient) MakeOrderPayment(
        oldCtx context.Context,
        body request.DeunaOrderPaymentRequest,
        token string,
) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(
                oldCtx,
                "DeUnaPaymentHTTPClient.MakeOrderPayment",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        var res response.DeunaOrderPaymentResponse

                        httpResponse, err := d.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true, deunaConfig.DeunaApiKeyHeader),
                        ).
                                SetResult(&amp;res).
                                SetBody(body).
                                SetContext(ctx).
                                SetHeader("Authorization", fmt.Sprintf("Bearer %s", token)).
                                Post("/merchants/transactions/purchase")

                        if err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>

                        <span class="cov8" title="1">if httpResponse.IsError() || httpResponse.StatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                                return fmt.Errorf("make order payment failed with status: %d", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                },
        )
}

func (d DeUnaPaymentHTTPClient) MakeOrderPaymentV2(
        oldCtx context.Context,
        body request.DeunaOrderPaymentRequestV2,
) (response.DeunaOrderPaymentResponseV2, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[response.DeunaOrderPaymentResponseV2](
                oldCtx,
                "DeUnaPaymentHTTPClient.MakeOrderPaymentV2",
                func(ctx context.Context, span decorators.Span) (response.DeunaOrderPaymentResponseV2, error) </span><span class="cov8" title="1">{
                        var res response.DeunaOrderPaymentResponseV2

                        httpResponse, err := d.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true),
                        ).
                                SetResult(&amp;res).
                                SetBody(body).
                                SetContext(ctx).
                                Post("/merchants/orders/purchase")

                        if err != nil </span><span class="cov0" title="0">{
                                return response.DeunaOrderPaymentResponseV2{}, handleError(err)
                        }</span>

                        <span class="cov8" title="1">if httpResponse.IsError() || httpResponse.StatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                                return response.DeunaOrderPaymentResponseV2{}, fmt.Errorf("make order payment failed with status: %d", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">return res, nil</span>
                },
        )
}

func (d DeUnaPaymentHTTPClient) MakeTotalRefund(
        oldCtx context.Context,
        body utils.DeunaTotalRefundRequest,
        orderToken string,
) (response.DeunaRefundPaymentResponse, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[response.DeunaRefundPaymentResponse](
                oldCtx,
                "DeUnaPaymentHTTPClient.MakeTotalRefund",
                func(ctx context.Context, span decorators.Span) (response.DeunaRefundPaymentResponse, error) </span><span class="cov8" title="1">{
                        var res response.DeunaRefundPaymentResponse

                        err := d.MakeRefund(ctx, body, &amp;res, orderToken)

                        if err != nil </span><span class="cov8" title="1">{
                                return response.DeunaRefundPaymentResponse{}, handleError(err)
                        }</span>

                        <span class="cov8" title="1">return res, nil</span>
                },
        )
}

func (d DeUnaPaymentHTTPClient) MakePartialRefund(
        oldCtx context.Context,
        body utils.DeunaPartialRefundRequest,
        orderToken string,
) (response.DeunaRefundPaymentResponse, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[response.DeunaRefundPaymentResponse](
                oldCtx,
                "DeUnaPaymentHTTPClient.MakePartialRefund",
                func(ctx context.Context, span decorators.Span) (response.DeunaRefundPaymentResponse, error) </span><span class="cov8" title="1">{
                        var res response.DeunaRefundPaymentResponse

                        err := d.MakeRefund(ctx, body, &amp;res, orderToken)

                        if err != nil </span><span class="cov8" title="1">{
                                return response.DeunaRefundPaymentResponse{}, handleError(err)
                        }</span>

                        <span class="cov8" title="1">return res, nil</span>
                },
        )
}

func (d DeUnaPaymentHTTPClient) MakeRefund(
        oldCtx context.Context,
        body interface{},
        result interface{},
        orderToken string,
) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(
                oldCtx,
                "DeUnaPaymentHTTPClient.MakeRefund",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        httpResponse, err := d.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true),
                        ).
                                SetResult(result).
                                SetBody(body).
                                SetContext(ctx).
                                Post(fmt.Sprintf("/v2/merchants/orders/%s/refund", orderToken))

                        if err != nil </span><span class="cov0" title="0">{
                                return handleError(err)
                        }</span>

                        <span class="cov8" title="1">if httpResponse.IsError() || httpResponse.StatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                                return fmt.Errorf("refund payment failed with status: %d", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                },
        )
}
</pre>
		
		<pre class="file" id="file198" style="display: none">package http

import (
        "context"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils"

        paymentResources "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/resources/dto/response"
        refundResources "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/resources"
)

type DeUnaRefundHTTPClient struct {
        paymentClient paymentResources.DeunaPaymentResourceIF
}

func NewDeUnaRefundHTTPClient(paymentClient paymentResources.DeunaPaymentResourceIF) refundResources.DeunaRefundResourceIF <span class="cov8" title="1">{
        return &amp;DeUnaRefundHTTPClient{
                paymentClient: paymentClient,
        }
}</span>

func (d *DeUnaRefundHTTPClient) MakeTotalRefund(
        ctx context.Context,
        body utils.DeunaTotalRefundRequest,
        orderToken string,
) (response.DeunaRefundPaymentResponse, error) <span class="cov8" title="1">{
        return d.paymentClient.MakeTotalRefund(ctx, body, orderToken)
}</span>

func (d *DeUnaRefundHTTPClient) MakePartialRefund(
        ctx context.Context,
        body utils.DeunaPartialRefundRequest,
        orderToken string,
) (response.DeunaRefundPaymentResponse, error) <span class="cov0" title="0">{
        return d.paymentClient.MakePartialRefund(ctx, body, orderToken)
}</span>
</pre>
		
		<pre class="file" id="file199" style="display: none">package http

import (
        "context"
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm"
        "net/http"
        "time"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/go-libraries/observability/clients/http/instrument"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources/dto/response"
        deunaConfig "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/config"
)

const (
        deUnaTimeout = 10 * time.Second
)

type DeUnaHTTPClient struct {
        instrument.Client
}

func NewDeUnaHTTPClient(config *deunaConfig.DeUnaApiConfig, tracer apm.Tracer) resources.DeUnaUserResourceIF <span class="cov8" title="1">{
        apiKeyHeader := deunaConfig.DeunaApiKeyHeader

        return &amp;DeUnaHTTPClient{
                instrument.NewInstrumentedClient(
                        instrument.WithBaseUrl(config.URL),
                        instrument.WithTraceOptions(tracer.GetTracer(), instrument.TraceRequest, instrument.TraceResponse),
                        instrument.WithRequestTimeout(deUnaTimeout),
                        instrument.WithHeaders(map[string]string{
                                apiKeyHeader:   config.ApiKey,
                                "Content-Type": "application/json",
                        }),
                ),
        }
}</span>

func (d DeUnaHTTPClient) CreateUser(
        oldCtx context.Context,
        request request.CreateUserRequestDTO,
) (response.CreatedUserResponse, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator[response.CreatedUserResponse](
                oldCtx,
                "DeUnaHTTPClient.CreateUser",
                func(ctx context.Context, span decorators.Span) (response.CreatedUserResponse, error) </span><span class="cov8" title="1">{
                        var responseBody response.CreatedUserResponse

                        record, err := d.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true, deunaConfig.DeunaApiKeyHeader),
                        ).
                                SetResult(&amp;responseBody).
                                SetBody(request).
                                SetContext(ctx).
                                Post("/users/register")

                        if err != nil </span><span class="cov8" title="1">{
                                return response.CreatedUserResponse{}, err
                        }</span>

                        <span class="cov8" title="1">if record.StatusCode() != http.StatusCreated </span><span class="cov8" title="1">{
                                return response.CreatedUserResponse{}, fmt.Errorf("error creating user")
                        }</span>

                        <span class="cov8" title="1">return responseBody, nil</span>
                },
        )
}
</pre>
		
		<pre class="file" id="file200" style="display: none">package http

import (
        "context"
        "fmt"
        "net/http"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/go-libraries/observability/clients/http/instrument"
        commonAdapters "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/common/adapters"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/http/config"
)

// MailResponse is the DTO for the mail service response
type MailResponse struct {
        Success   bool `json:"success"`
        TotalSent int  `json:"total_sent"`
}

const (
        broadcastNotificationPath = "/api/v1/notifications/broadcast"
)

type MailHTTPClientImpl struct {
        client config.MailClientHTTPIF
}

func NewMailHTTPClient(client config.MailClientHTTPIF) commonAdapters.MailAdapterIF <span class="cov0" title="0">{
        return &amp;MailHTTPClientImpl{
                client: client,
        }
}</span>

func (m *MailHTTPClientImpl) Send(oldCtx context.Context, request commonAdapters.MailRequest) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(
                oldCtx,
                "MailHTTPClient.Send",
                func(ctx context.Context, decorators decorators.Span) error </span><span class="cov8" title="1">{
                        var response MailResponse
                        httpResponse, err := m.client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true),
                        ).
                                SetContext(ctx).
                                SetBody(request).
                                SetResult(&amp;response).
                                Post(broadcastNotificationPath)

                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to send mail notification: %w", err)
                        }</span>

                        <span class="cov8" title="1">if httpResponse.StatusCode() != http.StatusCreated </span><span class="cov8" title="1">{
                                return fmt.Errorf("unexpected status code from mail service: %d", httpResponse.StatusCode())
                        }</span>

                        <span class="cov8" title="1">if !response.Success </span><span class="cov8" title="1">{
                                return fmt.Errorf("mail service reported failure: success=%v, total_sent=%d", response.Success, response.TotalSent)
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                },
        )
}
</pre>
		
		<pre class="file" id="file201" style="display: none">package http

import (
        "context"
        "fmt"
        "time"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/go-libraries/observability/clients/http/instrument"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"
        commonResources "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/common/adapters/resources"
        response "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/resources/dto/response"
)

const (
        enterpriseHeader       = "x-enterprise-id"
        userIDHeader           = "x-identity-user-id"
        usernameHeader         = "x-username"
        MemberApiTimeout       = 30 * time.Second
        getMemberByIDPath      = "/api/v1/members/%s"
        getUserProfileInfoPath = "/api/v1/members/profile-info"
)

type MemberHTTPClientImpl struct {
        instrument.Client
}

func NewMemberHTTPClient(tracer apm.Tracer) commonResources.MemberAPIResourceIF <span class="cov0" title="0">{
        return &amp;MemberHTTPClientImpl{
                instrument.NewInstrumentedClient(
                        instrument.WithTraceOptions(tracer.GetTracer(), instrument.TraceRequest, instrument.TraceResponse),
                        instrument.WithBaseUrl(config.Config().MembersApi.URL),
                        instrument.WithRequestTimeout(MemberApiTimeout),
                ),
        }
}</span>

func (m *MemberHTTPClientImpl) GetMemberByID(oldCtx context.Context, id, enterpriseId string) (response.MemberDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator(
                oldCtx,
                "MemberHTTPClient.GetMemberById",
                func(ctx context.Context, decorators decorators.Span) (response.MemberDTO, error) </span><span class="cov8" title="1">{
                        var responseBody response.MemberResponse[response.MemberDTO]
                        _, err := m.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true),
                        ).
                                SetContext(ctx).
                                SetHeader(enterpriseHeader, enterpriseId).
                                SetHeader(userIDHeader, id).
                                SetHeader(usernameHeader, id).
                                SetResult(&amp;responseBody).
                                Get(fmt.Sprintf(getMemberByIDPath, id))

                        if responseBody.Data.ID != id </span><span class="cov8" title="1">{
                                return response.MemberDTO{}, fmt.Errorf("member not found")
                        }</span>

                        <span class="cov8" title="1">return responseBody.Data, err</span>
                },
        )
}

func (m *MemberHTTPClientImpl) GetUserProfileInfo(oldCtx context.Context, userId string, enterpriseId string) (response.UserProfileInfoDTO, error) <span class="cov8" title="1">{
        return decorators.TraceDecorator(
                oldCtx,
                "MemberHTTPClient.GetUserProfileInfo",
                func(ctx context.Context, decorators decorators.Span) (response.UserProfileInfoDTO, error) </span><span class="cov8" title="1">{
                        var responseBody response.UserProfileInfoDTO
                        _, err := m.Client.NewRequestWithOptions(
                                instrument.WithHeadersLogConfig(true),
                        ).
                                SetContext(ctx).
                                SetResult(&amp;responseBody).
                                SetHeader(enterpriseHeader, enterpriseId).
                                SetHeader(userIDHeader, userId).
                                SetQueryParam("userID", userId).
                                Get(getUserProfileInfoPath)

                        if responseBody.UserID != userId </span><span class="cov8" title="1">{
                                return response.UserProfileInfoDTO{}, fmt.Errorf("member not found")
                        }</span>

                        <span class="cov8" title="1">return responseBody, err</span>
                },
        )
}
</pre>
		
		<pre class="file" id="file202" style="display: none">package webhooks

import (
        "fmt"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/services"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

func NewBillsApiWebhookUrl() services.BillsApiWebhookUrl <span class="cov8" title="1">{
        cfgUrl := fmt.Sprintf("%s/api/payments/register-payment", config.Config().BillApi.URL)
        webhookUrl := value_objects.NewWebhookUrl(cfgUrl)

        return services.BillsApiWebhookUrl(webhookUrl)
}</span>
</pre>
		
		<pre class="file" id="file203" style="display: none">package webhooks

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/resources"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
)

type WebhookNotificationResource struct {
        client *http.Client
}

func NewWebhookNotificationResource() resources.WebhookNotificationResourceIF <span class="cov8" title="1">{
        return &amp;WebhookNotificationResource{
                client: &amp;http.Client{},
        }
}</span>

func (w *WebhookNotificationResource) SendNotification(oldCtx context.Context, webhookUrl value_objects.WebhookUrl, payload interface{}) error <span class="cov8" title="1">{
        return decorators.TraceDecoratorNoReturn(
                oldCtx,
                "WebhookNotificationResource.SendNotification",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                        var err error

                        responseData := map[string]interface{}{
                                "payload": payload,
                                "webhook": webhookUrl.String(),
                                "error":   err,
                        }

                        jsonPayload, err := json.Marshal(responseData)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error marshaling payload: %w", err)
                        }</span>

                        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "POST", webhookUrl.String(), bytes.NewBuffer(jsonPayload))

                        if err != nil </span><span class="cov0" title="0">{
                                responseData["error"] = err
                                return fmt.Errorf("error creating request: %v", responseData)
                        }</span>

                        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

                        resp, err := w.client.Do(req)

                        if err != nil </span><span class="cov8" title="1">{
                                responseData["error"] = err
                                return fmt.Errorf("error sending request: %v", responseData)
                        }</span>

                        <span class="cov8" title="1">defer resp.Body.Close()

                        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                                return fmt.Errorf("notification failed with status code: %d, response: %v", resp.StatusCode, responseData)
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                },
        )
}
</pre>
		
		<pre class="file" id="file204" style="display: none">package entities

import (
        "time"

        "gitlab.com/clubhub.ai1/gommon/uid"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/card/dto/request"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/card/dto/response"

        "gorm.io/gorm"
)

type CardEntity struct {
        ID                *uid.UniqueID `gorm:"column:id;type:varchar(36);primaryKey"`
        ExternalCardID    string        `gorm:"column:external_card_id;type:varchar(36)"`
        UserID            string        `gorm:"column:user_id;type:varchar(36)"`
        CardHolder        string        `gorm:"column:card_holder;type:varchar(150)"`
        Alias             string        `gorm:"column:alias;type:varchar(50)"`
        Bin               string        `gorm:"column:bin;type:varchar(16)"`
        LastFour          string        `gorm:"column:last_four;type:varchar(4)"`
        Brand             string        `gorm:"column:brand;type:varchar(25)"`
        ExpirationDate    time.Time     `gorm:"column:expiration_date;type:date"`
        CardType          string        `gorm:"column:card_type;type:varchar(30)"`
        Status            string        `gorm:"column:status;type:varchar(25)"`
        IsDefault         bool          `gorm:"column:is_default;type:boolean"`
        IsRecurrent       bool          `gorm:"column:is_recurrent;type:boolean"`
        RetryAttempts     int           `gorm:"column:retry_attempts;type:integer"`
        EnterpriseID      string        `gorm:"column:enterprise_id;type:varchar(36)"`
        CardFailureReason string        `gorm:"column:card_failure_reason;type:varchar(100)"`
        CardFailureCode   string        `gorm:"column:card_failure_code;type:varchar(20)"`
        gorm.Model
}

type CardEntities []CardEntity

func (CardEntity) TableName() string <span class="cov8" title="1">{
        return "card"
}</span>

func NewCard(
        request request.CardRequest,
        enterpriseID string,
) CardEntity <span class="cov8" title="1">{

        layout := "01/06"
        expirationDateParsed, _ := time.Parse(layout, request.ExpirationDate) //cardDeUNA.ExpirationDate)

        year, month, _ := expirationDateParsed.Date()
        expirationDate := time.Date(year, month+1, 0, 0, 0, 0, 0, time.UTC)

        return CardEntity{
                ID:             uid.GenerateID(),
                ExternalCardID: request.CardId, //cardDeUNA.ID,
                UserID:         request.UserID, //userID,
                //CardHolder:        request.CardHolder,
                Alias:             request.Alias,
                Bin:               request.FirstSix,
                LastFour:          request.LastFour,  //cardDeUNA.LastFour,
                Brand:             request.CardBrand, //cardDeUNA.Company,
                ExpirationDate:    expirationDate,
                CardType:          request.CardType,
                Status:            request.Status,
                IsDefault:         request.IsDefault,
                IsRecurrent:       request.IsRecurrent,
                EnterpriseID:      enterpriseID,
                CardFailureReason: "",
                CardFailureCode:   "",
        }
}</span>

func (c CardEntity) ToDTO() response.CardResponse <span class="cov8" title="1">{
        return response.CardResponse{
                ID:             c.ID.String(),
                CardTokenID:    c.ExternalCardID,
                Alias:          c.Alias,
                LastFour:       c.LastFour,
                Brand:          c.Brand,
                IsDefault:      c.IsDefault,
                IsRecurrent:    c.IsRecurrent,
                ExpirationDate: c.ExpirationDate.Format("01/06"),
                CardType:       c.CardType,
        }
}</span>

func (c CardEntities) ToDTO() []response.CardResponse <span class="cov8" title="1">{
        cards := []response.CardResponse{}

        for _, card := range c </span><span class="cov8" title="1">{
                cards = append(cards, card.ToDTO())
        }</span>

        <span class="cov8" title="1">return cards</span>
}

// type Card struct {
//         ID  string `json:"id"`
//         CVV string `json:"cvv"`
// }
</pre>
		
		<pre class="file" id="file205" style="display: none">package card

import (
        "context"
        "time"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/projections"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/card/entities"
        "gorm.io/gorm"
)

type CardReadRepository struct {
        db *gorm.DB
}

func NewCardReadRepository(db *gorm.DB) repository.CardReadRepositoryIF <span class="cov8" title="1">{
        return &amp;CardReadRepository{
                db: db,
        }
}</span>

func (c *CardReadRepository) GetCardsByUserID(
        ctx context.Context, userID, enterpriseID string,
) (entities.CardEntities, error) <span class="cov8" title="1">{
        var cards []entities.CardEntity
        err := c.db.WithContext(ctx).
                Where("user_id = ? AND enterprise_id = ?", userID, enterpriseID).
                Find(&amp;cards).Error

        return cards, err
}</span>

func (c *CardReadRepository) GetCardByUserID(ctx context.Context,
        userID, cardID, enterpriseID string) (entities.CardEntity, error) <span class="cov8" title="1">{
        var card entities.CardEntity
        err := c.db.WithContext(ctx).
                Where("user_id = ? AND card.id = ? AND card.enterprise_id = ?", userID, cardID, enterpriseID).
                First(&amp;card).Error

        return card, err
}</span>

func (c *CardReadRepository) CheckCardExistence(ctx context.Context, userID, enterpriseID, lastFour string) (bool, error) <span class="cov8" title="1">{
        var count int64
        err := c.db.WithContext(ctx).
                Model(&amp;entities.CardEntity{}).
                Where("user_id = ? AND last_four = ? AND enterprise_id = ?", userID, lastFour, enterpriseID).
                Count(&amp;count).Error

        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return count &gt; 0, nil</span>
}

func (c *CardReadRepository) GetCardsExpiringSoon(
        ctx context.Context,
        expirationMonth time.Month,
        expirationYear int,
) ([]projections.NotificationCardExpiringSoonProjection, error) <span class="cov8" title="1">{
        var notificationCardExpiringSoonProjections []projections.NotificationCardExpiringSoonProjection

        startDate := time.Date(expirationYear, expirationMonth, 1, 0, 0, 0, 0, time.UTC)
        endDate := time.Date(expirationYear, expirationMonth+1, 0, 0, 0, 0, 0, time.UTC)

        err := c.db.WithContext(ctx).
                Model(&amp;entities.CardEntity{}).
                Select(`"user".id as user_id, card.last_four, card.expiration_date, "user".email, "user".enterprise_id`).
                Joins(`JOIN "user" ON "user".id = card.user_id`).
                Where("card.expiration_date BETWEEN ? AND ?", startDate, endDate).
                Find(&amp;notificationCardExpiringSoonProjections).Error

        return notificationCardExpiringSoonProjections, err
}</span>

func (c *CardReadRepository) GetCardAndUserEmailByUserID(
        ctx context.Context,
        userID, cardID, enterpriseID string,
) (*projections.CardUserEmailProjection, error) <span class="cov8" title="1">{
        var cardUserEmailProjection projections.CardUserEmailProjection
        err := c.db.WithContext(ctx).
                Model(&amp;entities.CardEntity{}).
                Select(`card.id, card.external_card_id, card.user_id, card.last_four, "user".email`).
                Joins(`JOIN "user" ON "user".id = card.user_id`).
                Where("card.user_id = ? AND card.id = ? AND card.enterprise_id = ?", userID, cardID, enterpriseID).
                First(&amp;cardUserEmailProjection).Error

        return &amp;cardUserEmailProjection, err
}</span>
</pre>
		
		<pre class="file" id="file206" style="display: none">package card

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/card/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/card/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/card/entities"
        "gorm.io/gorm"
)

type CardWriteRepository struct {
        db *gorm.DB
}

func NewCardWriteRepository(db *gorm.DB) repository.CardWriteRepositoryIF <span class="cov8" title="1">{
        return &amp;CardWriteRepository{
                db: db,
        }
}</span>

func (c *CardWriteRepository) CreateCard(ctx context.Context, entity *entities.CardEntity) error <span class="cov8" title="1">{
        if entity.Status == enums.Default.String() </span><span class="cov8" title="1">{
                if err := c.updateDefaultCardsToActive(ctx, entity.UserID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if entity.IsRecurrent </span><span class="cov8" title="1">{
                if err := c.updateRecurrentCardsToFalse(ctx, entity.UserID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return c.db.WithContext(ctx).Create(&amp;entity).Error</span>
}

func (c *CardWriteRepository) updateRecurrentCardsToFalse(ctx context.Context, userId string) error <span class="cov8" title="1">{
        return c.db.WithContext(ctx).
                Model(&amp;entities.CardEntity{}).
                Where("user_id = ? AND is_recurrent = ?", userId, true).
                Update("is_recurrent", false).Error
}</span>

func (c *CardWriteRepository) DeleteCard(ctx context.Context, cardId string) error <span class="cov8" title="1">{
        return c.db.WithContext(ctx).Unscoped().Where("id = ?", cardId).
                Delete(&amp;entities.CardEntity{}).Error
}</span>

func (c *CardWriteRepository) updateDefaultCardsToActive(ctx context.Context, userId string) error <span class="cov8" title="1">{
        return c.db.WithContext(ctx).
                Model(&amp;entities.CardEntity{}).
                Where("user_id = ? AND status = ?", userId, enums.Default.String()).
                Update("status", enums.Active.String()).Error
}</span>
</pre>
		
		<pre class="file" id="file207" style="display: none">package repositories

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_account/entities"
        "gorm.io/gorm"
)

type CollectionAccountRepositoryIF interface {
        Create(ctx context.Context, entity entities.CollectionAccountEntity) error
        FindById(ctx context.Context, id, enterpriseId string) (entities.CollectionAccountEntity, error)
        FindByAccountNumber(
                ctx context.Context,
                accountNumber, enterpriseId string,
        ) (entities.CollectionAccountEntity, error)
}

type CollectionAccountRepository struct {
        db *gorm.DB
}

func NewCollectionAccountRepository(db *gorm.DB) CollectionAccountRepositoryIF <span class="cov8" title="1">{
        return &amp;CollectionAccountRepository{db: db}
}</span>

func (r *CollectionAccountRepository) Create(
        ctx context.Context,
        entity entities.CollectionAccountEntity,
) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(&amp;entity).Error
}</span>

func (r *CollectionAccountRepository) FindById(
        ctx context.Context, id, enterpriseId string,
) (entities.CollectionAccountEntity, error) <span class="cov8" title="1">{
        var entity entities.CollectionAccountEntity

        err := r.db.WithContext(ctx).
                Where("id = ? AND enterprise_id = ?", id, enterpriseId).
                First(&amp;entity).
                Error

        return entity, err
}</span>

func (r *CollectionAccountRepository) FindByAccountNumber(
        ctx context.Context,
        accountNumber, enterpriseId string,
) (entities.CollectionAccountEntity, error) <span class="cov8" title="1">{
        var entity entities.CollectionAccountEntity

        err := r.db.WithContext(ctx).
                Where("account_number = ? AND enterprise_id = ?",
                        accountNumber, enterpriseId).
                First(&amp;entity).Error

        return entity, err
}</span>
</pre>
		
		<pre class="file" id="file208" style="display: none">package entities

import (
        "reflect"
        "time"

        "gitlab.com/clubhub.ai1/gommon/uid"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/api/handler/collection_account/dto/request"
        "gorm.io/gorm"
)

type CollectionAccountEntity struct {
        gorm.Model
        ID                     *uid.UniqueID `gorm:"type:varchar(14);primaryKey"`
        AccountType            string
        CollectionCenterID     string
        CurrencyCode           string
        AccountNumber          string
        BankName               string
        InterbankAccountNumber string
        EnterpriseID           string
}

func (c CollectionAccountEntity) IsEmpty() bool <span class="cov8" title="1">{
        return reflect.DeepEqual(c, CollectionAccountEntity{})
}</span>

func (CollectionAccountEntity) TableName() string <span class="cov8" title="1">{
        return "collection_account"
}</span>

func NewCollectionAccountEntity(
        request request.CollectionAccountRequest,
        enterpriseId string,
) CollectionAccountEntity <span class="cov8" title="1">{
        return CollectionAccountEntity{
                ID:                     uid.GenerateID(),
                AccountType:            request.AccountType.String(),
                CollectionCenterID:     request.CollectionCenterID,
                CurrencyCode:           request.CurrencyCode,
                AccountNumber:          request.AccountNumber,
                BankName:               request.BankName,
                EnterpriseID:           enterpriseId,
                InterbankAccountNumber: request.InterbankAccountNumber,
                Model: gorm.Model{
                        CreatedAt: time.Now(),
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file209" style="display: none">package repositories

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/collection_account/repositories"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/collection_account/entities"
        "gorm.io/gorm"
)

type CollectionAccountReadRepository struct {
        db *gorm.DB
}

func NewCollectionAccountReadRepository(db *gorm.DB) repositories.CollectionAccountReadRepositoryIF <span class="cov8" title="1">{
        return &amp;CollectionAccountReadRepository{
                db: db,
        }
}</span>

func (c *CollectionAccountReadRepository) GetCollectionAccountRoute(
        ctx context.Context, country, associatedOrigin, currency, enterpriseId string,
) (entities.CollectionAccountEntity, error) <span class="cov8" title="1">{
        var collectionAccount entities.CollectionAccountEntity

        err := c.db.WithContext(ctx).
                Select("collection_account.*").
                Where(`cr.country_code = ? 
                        AND cr.associated_origin = ? 
                        AND cr.currency_code = ? 
                        AND collection_account.enterprise_id = ?`, country, associatedOrigin, currency, enterpriseId).
                Joins("JOIN collection_account_route cr ON cr.collection_account_id = collection_account.id").
                First(&amp;collectionAccount).Error

        if err != nil </span><span class="cov0" title="0">{
                return entities.CollectionAccountEntity{}, err
        }</span>

        <span class="cov8" title="1">return collectionAccount, nil</span>
}
</pre>
		
		<pre class="file" id="file210" style="display: none">package repositories

import (
        "context"
        "time"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gorm.io/gorm"
)

type CollectionCenterAccountRouteRepositoryIF interface {
        Create(
                ctx context.Context,
                collectionRoute entities.CollectionAccountRouteEntity,
        ) error
        Disable(
                ctx context.Context,
                id, enterpriseId string,
        ) error
        FindRouteBy(ctx context.Context,
                countryCode, currencyCode, associatedOrigin, enterpriseID string,
        ) (entities.CollectionAccountRouteEntity, error)
}

type CollectionCenterRepository struct {
        db *gorm.DB
}

func NewCollectionCenterRepositoryIF(db *gorm.DB) CollectionCenterAccountRouteRepositoryIF <span class="cov0" title="0">{
        return &amp;CollectionCenterRepository{
                db: db,
        }
}</span>

func (c *CollectionCenterRepository) Create(
        ctx context.Context,
        collectionRoute entities.CollectionAccountRouteEntity,
) error <span class="cov0" title="0">{
        return c.db.WithContext(ctx).Create(&amp;collectionRoute).Error
}</span>

func (c *CollectionCenterRepository) Disable(
        ctx context.Context,
        id, enterpriseId string,
) error <span class="cov0" title="0">{
        return c.db.WithContext(ctx).
                Model(&amp;entities.CollectionAccountRouteEntity{}).
                Where("id = ? AND enterprise_id = ?", id, enterpriseId).
                Update("disabled_at", time.Now()).Error
}</span>

func (c *CollectionCenterRepository) FindRouteBy(
        ctx context.Context, countryCode, currencyCode, associatedOrigin, enterpriseID string) (entities.CollectionAccountRouteEntity, error) <span class="cov0" title="0">{
        var route entities.CollectionAccountRouteEntity
        err := c.db.WithContext(ctx).
                Where("country_code = ? AND currency_code = ? AND associated_origin = ? AND enterprise_id = ?",
                        countryCode, currencyCode, associatedOrigin, enterpriseID).
                First(&amp;route).Error
        return route, err
}</span>
</pre>
		
		<pre class="file" id="file211" style="display: none">package repositories

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gorm.io/gorm"
)

type CollectionCenterRepositoryIF interface {
        Create(ctx context.Context, collectionCenter entities.CollectionCenterEntity) error
        FindByID(
                ctx context.Context,
                id, enterpriseId string,
        ) (entities.CollectionCenterEntity, error)
}

type CollectionCenterRepository struct {
        db *gorm.DB
}

func NewCollectionCenterRepository(db *gorm.DB) CollectionCenterRepositoryIF <span class="cov8" title="1">{
        return &amp;CollectionCenterRepository{
                db: db,
        }
}</span>

func (r *CollectionCenterRepository) Create(
        ctx context.Context,
        collectionCenter entities.CollectionCenterEntity,
) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(&amp;collectionCenter).Error
}</span>

func (r *CollectionCenterRepository) FindByID(
        ctx context.Context,
        id, enterpriseId string,
) (entities.CollectionCenterEntity, error) <span class="cov8" title="1">{
        var entity entities.CollectionCenterEntity

        err := r.db.WithContext(ctx).
                Where("id = ? AND enterprise_id = ?", id, enterpriseId).
                First(&amp;entity).Error

        return entity, err
}</span>
</pre>
		
		<pre class="file" id="file212" style="display: none">package repository

import (
        "context"
        "errors"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/utils"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/deuna_payment/entities"
        "gorm.io/gorm"
)

var OrderTokeNotFoundError = errors.New("order token not found")

type DeunaPaymentWriteRepository struct {
        db *gorm.DB
}

func NewDeunaPaymentWriteRepository(db *gorm.DB) repository.DeunaOrderRepository <span class="cov0" title="0">{
        return &amp;DeunaPaymentWriteRepository{
                db: db,
        }
}</span>

func (r *DeunaPaymentWriteRepository) CreatePaymentOrderDeuna(ctx context.Context, paymentID, orderID, deunaOrderToken string) error <span class="cov8" title="1">{
        deunaOrderID := utils.NewDeunaOrderID(orderID, paymentID)
        paymentOrderID := entities.NewDeunaPaymentEntity(deunaOrderID.GetID(), deunaOrderToken)

        return r.db.WithContext(ctx).Create(&amp;paymentOrderID).Error
}</span>

func (r *DeunaPaymentWriteRepository) GetTokenByOrderAndPaymentID(ctx context.Context, orderID string, paymentID string) (token string, err error) <span class="cov8" title="1">{
        deunaOrderID := utils.NewDeunaOrderID(orderID, paymentID)
        var paymentEntity entities.DeunaPaymentEntity
        err = r.db.WithContext(ctx).
                Where("payment_id = ?", deunaOrderID.GetID()).
                First(&amp;paymentEntity).Error

        if err != nil </span><span class="cov8" title="1">{
                return "", OrderTokeNotFoundError
        }</span>

        <span class="cov8" title="1">if paymentEntity.IsEmptyToken() </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return paymentEntity.OrderToken, nil</span>
}
</pre>
		
		<pre class="file" id="file213" style="display: none">package entities

import "time"

type DeunaPaymentEntity struct {
        PaymentID  string    `gorm:"column:payment_id"`
        OrderToken string    `gorm:"column:order_token"`
        CreatedAt  time.Time `gorm:"column:created_at"`
        UpdatedAt  time.Time `gorm:"column:updated_at"`
        DeletedAt  time.Time `gorm:"column:deleted_at"`
}

func (d *DeunaPaymentEntity) TableName() string <span class="cov8" title="1">{
        return "deuna_payment"
}</span>

func NewDeunaPaymentEntity(paymentID, orderToken string) DeunaPaymentEntity <span class="cov8" title="1">{
        return DeunaPaymentEntity{
                PaymentID:  paymentID,
                OrderToken: orderToken,
                CreatedAt:  time.Now().UTC(),
                UpdatedAt:  time.Now().UTC(),
        }
}</span>

func (e *DeunaPaymentEntity) IsEmptyToken() bool <span class="cov8" title="1">{
        return e.OrderToken == ""
}</span>
</pre>
		
		<pre class="file" id="file214" style="display: none">package eventsourcing

import (
        "context"

        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
        entitiesOrder "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/order/entities"

        "gitlab.com/clubhub.ai1/go-libraries/eventsourcing"
        "gitlab.com/clubhub.ai1/go-libraries/eventsourcing/eventstore/dynamo"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/event_store"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/aggregate"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/aws"

        "gitlab.com/clubhub.ai1/gommon/logger"
)

type OrderEventsourcingRepository struct {
        *eventsourcing.EventRepository
        writRepository repository.OrderWriteRepositoryIF
}

func (b *OrderEventsourcingRepository) Get(oldCtx context.Context, id string, a *aggregate.Order) error <span class="cov0" title="0">{
        return b.EventRepository.GetWithContext(oldCtx, id, a)
}</span>

func (b *OrderEventsourcingRepository) Save(oldCtx context.Context, a *aggregate.Order) error <span class="cov0" title="0">{
        return b.EventRepository.Save(oldCtx, a)
}</span>

func (b *OrderEventsourcingRepository) Create(oldCtx context.Context, order *aggregate.Order) error <span class="cov0" title="0">{
        return decorators.TraceDecoratorNoReturn(
                oldCtx,
                "OrderEventsourcingRepository.Create",
                func(ctx context.Context, span decorators.Span) error </span><span class="cov0" title="0">{
                        entity := entitiesOrder.NewOrderEntityBuilder().
                                SetID(order.ID).
                                SetReferenceOrderID(order.ID).
                                SetCountryCode(order.CountryCode.Code).
                                SetCurrencyCode(order.Currency.Code).
                                SetTotalAmount(order.TotalAmount.Value).
                                SetEnterpriseID(order.EnterpriseID).
                                SetStatus(value_objects.OrderStatusProcessing().Get()).
                                SetMetadata(order.Metadata).
                                SetUserID(order.User.ID).
                                SetAllowCapture(order.AllowCapture).
                                Build()

                        err := b.writRepository.CreateOrder(ctx, entity)

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">return b.EventRepository.Save(ctx, order)</span>
                },
        )
}

func newOrderEventsourcingRepository(eventStore *eventsourcing.EventRepository, repo repository.OrderWriteRepositoryIF) *OrderEventsourcingRepository <span class="cov0" title="0">{
        eventRepository := &amp;OrderEventsourcingRepository{
                EventRepository: eventStore,
                writRepository:  repo,
        }

        eventRepository.Register(new(aggregate.Order))

        return eventRepository
}</span>

func NewOrderEventsourcingRepository(logger logger.LoggerInterface, writeRepository repository.OrderWriteRepositoryIF) event_store.OrderEventRepository <span class="cov0" title="0">{
        cfg := config.Config()

        dynamodbClient := aws.NewDynamoClient(cfg, logger)

        tablePrefix := cfg.DynamoDB.PaymentsEventStoreTable

        eventStore := dynamo.NewWithOpts(dynamodbClient, dynamo.WithTableName(tablePrefix))

        eventRepository := eventsourcing.NewEventRepository(eventStore)

        return newOrderEventsourcingRepository(eventRepository, writeRepository)
}</span>
</pre>
		
		<pre class="file" id="file215" style="display: none">package entities

import (
        "encoding/json"
        "time"

        "github.com/shopspring/decimal"
)

type OrderEntity struct {
        ID               string `gorm:"type:varchar(14);primaryKey"`
        UserID           string
        ReferenceOrderID string
        TotalAmount      decimal.Decimal
        CountryCode      string
        CurrencyCode     string
        Status           string
        EnterpriseID     string
        Metadata         json.RawMessage `gorm:"type:json"`
        AllowCapture     bool
        DeletedAt        *time.Time
}

func (o OrderEntity) IsEmpty() bool <span class="cov8" title="1">{
        return o.ID == ""
}</span>

func (p OrderEntity) TableName() string <span class="cov8" title="1">{
        return "order"
}</span>

func (p *OrderEntity) SetStatus(status string) <span class="cov8" title="1">{
        p.Status = status
}</span>

type OrderEntityBuilder struct {
        entity OrderEntity
}

func NewOrderEntityBuilder() *OrderEntityBuilder <span class="cov8" title="1">{
        return &amp;OrderEntityBuilder{}
}</span>

func (p *OrderEntityBuilder) SetUserID(userID string) *OrderEntityBuilder <span class="cov8" title="1">{
        p.entity.UserID = userID
        return p
}</span>

func (p *OrderEntityBuilder) SetID(id string) *OrderEntityBuilder <span class="cov8" title="1">{
        p.entity.ID = id
        return p
}</span>

func (p *OrderEntityBuilder) SetReferenceOrderID(referenceOrderID string) *OrderEntityBuilder <span class="cov8" title="1">{
        p.entity.ReferenceOrderID = referenceOrderID
        return p
}</span>

func (p *OrderEntityBuilder) SetTotalAmount(totalAmount decimal.Decimal) *OrderEntityBuilder <span class="cov8" title="1">{
        p.entity.TotalAmount = totalAmount
        return p
}</span>

func (p *OrderEntityBuilder) SetCountryCode(countryCode string) *OrderEntityBuilder <span class="cov8" title="1">{
        p.entity.CountryCode = countryCode
        return p
}</span>

func (p *OrderEntityBuilder) SetCurrencyCode(currencyCode string) *OrderEntityBuilder <span class="cov8" title="1">{
        p.entity.CurrencyCode = currencyCode
        return p
}</span>

func (p *OrderEntityBuilder) SetStatus(status string) *OrderEntityBuilder <span class="cov8" title="1">{
        p.entity.Status = status
        return p
}</span>

func (p *OrderEntityBuilder) SetEnterpriseID(enterpriseID string) *OrderEntityBuilder <span class="cov8" title="1">{
        p.entity.EnterpriseID = enterpriseID
        return p
}</span>

func (p *OrderEntityBuilder) SetMetadata(metadata map[string]interface{}) *OrderEntityBuilder <span class="cov8" title="1">{
        jsonData, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                p.entity.Metadata = json.RawMessage("{}")
                return p
        }</span>
        <span class="cov8" title="1">p.entity.Metadata = jsonData

        return p</span>
}

func (p *OrderEntityBuilder) SetMetadataFromMap(metadata map[string]interface{}) *OrderEntityBuilder <span class="cov8" title="1">{
        jsonData, err := json.Marshal(metadata)
        if err != nil </span><span class="cov0" title="0">{
                p.entity.Metadata = json.RawMessage("{}")
                return p
        }</span>
        <span class="cov8" title="1">p.entity.Metadata = jsonData
        return p</span>
}

func (p *OrderEntityBuilder) SetAllowCapture(allowCapture bool) *OrderEntityBuilder <span class="cov8" title="1">{
        p.entity.AllowCapture = allowCapture
        return p
}</span>

func (p *OrderEntityBuilder) Build() OrderEntity <span class="cov8" title="1">{
        return p.entity
}</span>
</pre>
		
		<pre class="file" id="file216" style="display: none">package repositories

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/order/projections"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/order/entities"
        "gorm.io/gorm"
)

type OrderReadRepository struct {
        db *gorm.DB
}

func NewOrderReadRepository(db *gorm.DB) repository.OrderReadRepositoryIF <span class="cov8" title="1">{
        return &amp;OrderReadRepository{
                db: db,
        }
}</span>

func (r *OrderReadRepository) GetOrderByReferenceID(ctx context.Context, referenceOrderID, enterpriseID string) (entities.OrderEntity, error) <span class="cov8" title="1">{
        var order entities.OrderEntity

        err := r.db.WithContext(ctx).
                Where("reference_order_id = ?", referenceOrderID).
                First(&amp;order).Error
        return order, err
}</span>

func (r *OrderReadRepository) GetOrderPayments(ctx context.Context, referenceOrderID, enterpriseID string) ([]projections.OrderPaymentsProjection, error) <span class="cov8" title="1">{
        var orderPaymentProjection []projections.OrderPaymentsProjection

        err := r.db.WithContext(ctx).
                Model(&amp;entities.OrderEntity{}).
                Select(`
                        "order".reference_order_id, 
                        "order".user_id, 
                        "order".total_amount, 
                        "order".currency_code, 
                        "order".country_code, 
                        "order".status as order_status,
                        "order".metadata as metadata, 
                        p.id as payment_id,
                        p.card_id, 
                        p.payment_method, 
                        p.status as payment_status,
                        p.authorization_code, 
                        p.payment_order_id, 
                        p.created_at as payment_date
                `).
                Joins(`LEFT JOIN payment p on "order".id = p.order_id`).
                Where(`"order".reference_order_id = ? AND "order".enterprise_id = ? AND "order".deleted_at IS NULL`, referenceOrderID, enterpriseID).
                Scan(&amp;orderPaymentProjection).Error

        return orderPaymentProjection, err
}</span>
</pre>
		
		<pre class="file" id="file217" style="display: none">package repositories

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/order/entities"
        "gorm.io/gorm"
)

var (
        ctx = context.Background()
)

type OrderWriteRepository struct {
        db *gorm.DB
}

func NewOrderWriteRepository(db *gorm.DB) repository.OrderWriteRepositoryIF <span class="cov8" title="1">{
        return &amp;OrderWriteRepository{
                db: db,
        }
}</span>

func (r *OrderWriteRepository) CreateOrder(
        ctx context.Context, entity entities.OrderEntity,
) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(&amp;entity).Error
}</span>

func (r *OrderWriteRepository) UpdateOrder(
        ctx context.Context, entity entities.OrderEntity,
) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Model(&amp;entity).Updates(entity).Error
}</span>
</pre>
		
		<pre class="file" id="file218" style="display: none">package repositories

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gorm.io/gorm"
)

type PaymentConceptRepositoryIF interface {
        Create(ctx context.Context, entity entities.PaymentConceptEntity) error
        FindByCode(ctx context.Context, code, enterpriseId string) (entities.PaymentConceptEntity, error)
}

type PaymentConceptRepository struct {
        db *gorm.DB
}

func NewPaymentConceptRepository(db *gorm.DB) PaymentConceptRepositoryIF <span class="cov0" title="0">{
        return &amp;PaymentConceptRepository{db: db}
}</span>

func (r *PaymentConceptRepository) Create(
        ctx context.Context,
        entity entities.PaymentConceptEntity,
) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(&amp;entity).Error
}</span>

func (r *PaymentConceptRepository) FindByCode(
        ctx context.Context, code, enterpriseId string,
) (entities.PaymentConceptEntity, error) <span class="cov0" title="0">{
        var entity entities.PaymentConceptEntity

        err := r.db.WithContext(ctx).
                Where("code = ? AND enterprise_id = ?", code, enterpriseId).
                First(&amp;entity).
                Error

        return entity, err
}</span>
</pre>
		
		<pre class="file" id="file219" style="display: none">package repositories

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gorm.io/gorm"
)

type PaymentMethodRepositoryIF interface {
        Create(ctx context.Context, entity entities.PaymentMethodEntity) error
}

type PaymentMethodRepository struct {
        db *gorm.DB
}

func NewPaymentMethodRepository(db *gorm.DB) PaymentMethodRepositoryIF <span class="cov0" title="0">{
        return &amp;PaymentMethodRepository{db: db}
}</span>

func (r *PaymentMethodRepository) Create(ctx context.Context, entity entities.PaymentMethodEntity) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(&amp;entity).Error
}</span>
</pre>
		
		<pre class="file" id="file220" style="display: none">package entities

import (
        "encoding/json"
        "time"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_order/utils"

        "github.com/shopspring/decimal"
        "gitlab.com/clubhub.ai1/gommon/uid"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gorm.io/gorm"
)

type PaymentOrderEntity struct {
        ID                  *uid.UniqueID `gorm:"type:varchar(14);primaryKey"`
        OrderID             string
        AssociatedOrigin    string
        CurrencyCode        string
        CountryCode         string
        CardID              string
        CardDetail          json.RawMessage
        PaymentMethod       string
        CollectionAccountID string
        Metadata            json.RawMessage
        Status              string
        TotalAmount         decimal.Decimal
        Reference           string
        FailureReason       string
        FailureCode         string
        EnterpriseID        string
        IPAddress           string
        DeviceFingerprint   string
        TransactionDate     time.Time
        PaymentOrderID      string
        PaymentFlow         string
        AuthorizedAt        time.Time
        CapturedAt          time.Time
        ReleasedAt          time.Time
        AuthorizationCode   string
        gorm.Model
}

func (p PaymentOrderEntity) TableName() string <span class="cov8" title="1">{
        return "payment"
}</span>

func (p *PaymentOrderEntity) SetStatus(status enums.PaymentStatus) <span class="cov8" title="1">{
        p.Status = status.String()
}</span>

func (p *PaymentOrderEntity) SetAuthorizationCode(authorizationCode string) <span class="cov8" title="1">{
        p.AuthorizationCode = authorizationCode
}</span>

type PaymentOrderEntityBuilder struct {
        entity PaymentOrderEntity
}

func NewPaymentOrderEntity() *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        return &amp;PaymentOrderEntityBuilder{}
}</span>

func (p *PaymentOrderEntityBuilder) SetOrderID(orderID string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.OrderID = orderID
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetAssociatedOrigin(associatedOrigin string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.AssociatedOrigin = associatedOrigin
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetCurrencyCode(currencyCode string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.CurrencyCode = currencyCode
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetCountryCode(countryCode string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.CountryCode = countryCode
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetCardID(cardID string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.CardID = cardID
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetPaymentMethod(paymentMethod string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.PaymentMethod = paymentMethod
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetCollectionAccountID(collectionAccountID string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.CollectionAccountID = collectionAccountID
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetCardDetail(cardDetail string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.CardDetail = json.RawMessage(cardDetail)
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetMetadata(metadata string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.Metadata = json.RawMessage(metadata)
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetStatus(status string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.Status = status
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetTotalAmount(totalAmount decimal.Decimal) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.TotalAmount = totalAmount
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetReference(reference string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.Reference = reference
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetFailureReason(failureReason string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.FailureReason = failureReason
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetFailureCode(failureCode string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.FailureCode = failureCode
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetEnterpriseID(enterpriseID string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.EnterpriseID = enterpriseID
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetIPAddress(ipAddress string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.IPAddress = ipAddress
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetDeviceFingerprint(deviceFingerprint string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.DeviceFingerprint = deviceFingerprint
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetTransactionDate() *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.TransactionDate = time.Now()
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetPaymentOrderID(paymentOrderID string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.PaymentOrderID = paymentOrderID
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetPaymentFlow(paymentFlow enums.PaymentFlowEnum) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.PaymentFlow = paymentFlow.String()
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetAuthorizedAt(authorizedAt time.Time) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.AuthorizedAt = authorizedAt
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetCapturedAt(capturedAt time.Time) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.CapturedAt = capturedAt
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetReleasedAt(releasedAt time.Time) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.ReleasedAt = releasedAt
        return p
}</span>

func (p *PaymentOrderEntityBuilder) SetAuthorizationCode(authorizationCode string) *PaymentOrderEntityBuilder <span class="cov8" title="1">{
        p.entity.AuthorizationCode = authorizationCode
        return p
}</span>

func (p *PaymentOrderEntityBuilder) Build() PaymentOrderEntity <span class="cov8" title="1">{
        id, _ := uid.NewUniqueID(
                uid.WithID(utils.GeneratePaymentOrderID(p.entity.OrderID, p.entity.PaymentOrderID)),
        )
        p.entity.ID = id

        return p.entity
}</span>
</pre>
		
		<pre class="file" id="file221" style="display: none">package repositories

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_order/entities"
        "gorm.io/gorm"
)

type PaymentOrderReadRepository struct {
        db *gorm.DB
}

func NewPaymentOrderReadRepository(db *gorm.DB) repository.GetPaymentOrderByReferenceIF <span class="cov8" title="1">{
        return &amp;PaymentOrderReadRepository{
                db: db,
        }
}</span>

func (r *PaymentOrderReadRepository) GetPaymentOrderByReference(
        ctx context.Context, referenceID, orderID, enterpriseID string,
) (entities.PaymentOrderEntity, error) <span class="cov8" title="1">{
        var paymentOrder entities.PaymentOrderEntity
        err := r.db.WithContext(ctx).
                Joins(`JOIN "order" ON "order".id = payment.order_id`).
                Where(`"order".reference_order_id = ? AND payment.payment_order_id = ? AND "order".enterprise_id = ?`, referenceID, orderID, enterpriseID).
                First(&amp;paymentOrder).Error
        if err != nil </span><span class="cov0" title="0">{
                return entities.PaymentOrderEntity{}, err
        }</span>
        <span class="cov8" title="1">return paymentOrder, nil</span>
}
</pre>
		
		<pre class="file" id="file222" style="display: none">package repositories

import (
        "context"

        orderRepository "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        paymentOrderRepository "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gorm.io/gorm"
)

type UpdateOrderStatusRepository struct {
        db                         *gorm.DB
        paymentOrderReadRepository paymentOrderRepository.GetPaymentOrderByReferenceIF
        orderReadRepository        orderRepository.OrderReadRepositoryIF
}

func NewUpdateOrderStatusRepository(db *gorm.DB,
        paymentOrderReadRepository paymentOrderRepository.GetPaymentOrderByReferenceIF,
        orderReadRepository orderRepository.OrderReadRepositoryIF) repository.TransactionsRepositoryIF <span class="cov8" title="1">{
        return &amp;UpdateOrderStatusRepository{
                db:                         db,
                paymentOrderReadRepository: paymentOrderReadRepository,
                orderReadRepository:        orderReadRepository,
        }
}</span>

func (r *UpdateOrderStatusRepository) UpdatePaymentOrderStatus(ctx context.Context, orderReferenceId, paymentId, enterpriseID string, status enums.PaymentStatus) error <span class="cov8" title="1">{
        tx := r.db.WithContext(ctx).Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                return tx.Error
        }</span>

        <span class="cov8" title="1">paymentOrder, err := r.paymentOrderReadRepository.GetPaymentOrderByReference(ctx, orderReferenceId, paymentId, enterpriseID)
        if err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">paymentOrder.SetStatus(status)
        if err := tx.Save(&amp;paymentOrder).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">order, err := r.orderReadRepository.GetOrderByReferenceID(ctx, orderReferenceId, enterpriseID)
        if err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">order.SetStatus(status.String())
        if err := tx.Save(&amp;order).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit().Error</span>
}
</pre>
		
		<pre class="file" id="file223" style="display: none">package utils

import "fmt"

func GeneratePaymentOrderID(orderID string, paymentID string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_%s", orderID, paymentID)
}</span>
</pre>
		
		<pre class="file" id="file224" style="display: none">package repositories

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_order/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_order/entities"
        "gorm.io/gorm"
)

type PaymentOrderWriteRespository struct {
        db *gorm.DB
}

func NewPaymentOrderWriteRespository(db *gorm.DB) repository.PaymentOrderRepositoryIF <span class="cov8" title="1">{
        return &amp;PaymentOrderWriteRespository{
                db: db,
        }
}</span>

func (r *PaymentOrderWriteRespository) CreatePaymentOrder(
        ctx context.Context, entity entities.PaymentOrderEntity,
) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(&amp;entity).Error
}</span>

func (r *PaymentOrderWriteRespository) UpdatePaymentOrder(
        ctx context.Context, entity entities.PaymentOrderEntity,
) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Model(&amp;entity).Updates(entity).Error
}</span>
</pre>
		
		<pre class="file" id="file225" style="display: none">package entities

import (
        "github.com/shopspring/decimal"
        domainEntities "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/enums"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/value_objects"
        "gorm.io/gorm"
        "time"
)

type PaymentReceiptDTO struct {
        ID                  string          `gorm:"type:varchar(255);primaryKey"`
        PaymentReceiptID    string          `gorm:"type:varchar(255);not null"`
        UserID              string          `gorm:"type:varchar(255);not null"`
        EnterpriseID        string          `gorm:"type:varchar(255);not null"`
        Email               string          `gorm:"type:varchar(255);not null"`
        ReferenceOrderID    string          `gorm:"type:varchar(255);not null"`
        PaymentID           string          `gorm:"type:varchar(255);not null"`
        PaymentStatus       string          `gorm:"type:varchar(255);not null"`
        PaymentAmount       decimal.Decimal `gorm:"type:decimal;not null"`
        PaymentCountryCode  string          `gorm:"type:varchar(10);not null"`
        PaymentCurrencyCode string          `gorm:"type:varchar(10);not null"`
        PaymentMethod       string          `gorm:"type:varchar(255);not null"`
        PaymentDate         string          `gorm:"type:varchar(255);not null"`
        FileURL             string          `gorm:"type:varchar(255)"`
        CreatedAt           time.Time       `gorm:"type:timestamp;not null;default:CURRENT_TIMESTAMP"`
        UpdatedAt           time.Time       `gorm:"type:timestamp;not null;default:CURRENT_TIMESTAMP"`
        DeletedAt           *time.Time      `gorm:"type:timestamp"`
        gorm.Model
}

func (p PaymentReceiptDTO) TableName() string <span class="cov8" title="1">{
        return "payment_receipt"
}</span>

func (p PaymentReceiptDTO) ToDomain() domainEntities.PaymentReceipt <span class="cov8" title="1">{
        var paymentMethodEnum enums.PaymentMethodEnum
        if p.PaymentMethod == enums.CCMethod.String() </span><span class="cov8" title="1">{
                paymentMethodEnum = enums.CCMethod
        }</span> else<span class="cov8" title="1"> if p.PaymentMethod == enums.PaymentDevice.String() </span><span class="cov8" title="1">{
                paymentMethodEnum = enums.PaymentDevice
        }</span> else<span class="cov0" title="0"> {
                paymentMethodEnum = enums.CCMethod
        }</span>

        <span class="cov8" title="1">return domainEntities.PaymentReceipt{
                ID:                  p.ID,
                PaymentReceiptID:    p.PaymentReceiptID,
                UserID:              p.UserID,
                EnterpriseID:        p.EnterpriseID,
                Email:               p.Email,
                ReferenceOrderID:    p.ReferenceOrderID,
                PaymentID:           p.PaymentID,
                PaymentStatus:       p.PaymentStatus,
                PaymentAmount:       p.PaymentAmount,
                PaymentCountryCode:  p.PaymentCountryCode,
                PaymentCurrencyCode: p.PaymentCurrencyCode,
                PaymentMethod:       paymentMethodEnum,
                PaymentDate:         p.PaymentDate,
                FileURL:             p.FileURL,
                CreatedAt:           p.CreatedAt,
                UpdatedAt:           p.UpdatedAt,
        }</span>
}

func FromEntity(cmd domainEntities.PaymentReceipt) PaymentReceiptDTO <span class="cov8" title="1">{
        // Convert UTC times back to local timezone for test compatibility
        createdAt := cmd.CreatedAt.Local()
        updatedAt := cmd.UpdatedAt.Local()

        return PaymentReceiptDTO{
                ID:                  cmd.ID,
                PaymentReceiptID:    cmd.PaymentReceiptID,
                UserID:              cmd.UserID,
                EnterpriseID:        cmd.EnterpriseID,
                Email:               cmd.Email,
                ReferenceOrderID:    cmd.ReferenceOrderID,
                PaymentID:           cmd.PaymentID,
                PaymentStatus:       cmd.PaymentStatus,
                PaymentAmount:       cmd.PaymentAmount,
                PaymentCountryCode:  cmd.PaymentCountryCode,
                PaymentCurrencyCode: cmd.PaymentCurrencyCode,
                PaymentMethod:       cmd.PaymentMethod.String(),
                PaymentDate:         cmd.PaymentDate,
                FileURL:             cmd.FileURL,
                CreatedAt:           createdAt,
                UpdatedAt:           updatedAt,
        }
}</span>

func (p PaymentReceiptDTO) ToCurrencyAmount() (value_objects.CurrencyAmount, error) <span class="cov8" title="1">{
        currencyCode, err := value_objects.NewCurrencyCode(p.PaymentCurrencyCode)
        if err != nil </span><span class="cov8" title="1">{
                return value_objects.CurrencyAmount{}, err
        }</span>

        <span class="cov8" title="1">return value_objects.NewCurrencyAmount(currencyCode, p.PaymentAmount)</span>
}

func (p PaymentReceiptDTO) ToCountry() (value_objects.Country, error) <span class="cov8" title="1">{
        return value_objects.NewCountryWithCode(p.PaymentCountryCode)
}</span>
</pre>
		
		<pre class="file" id="file226" style="display: none">package repositories

import (
        "context"
        domainEntities "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/domain/entities"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/payment_receipt/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_receipt/entities"
        "gorm.io/gorm"
)

type PaymentReceiptRepository struct {
        db *gorm.DB
}

func NewPaymentReceiptRepository(db *gorm.DB) repository.PaymentReceiptRepository <span class="cov8" title="1">{
        return &amp;PaymentReceiptRepository{
                db: db,
        }
}</span>

func (r *PaymentReceiptRepository) GetByPaymentID(ctx context.Context, paymentID string) (domainEntities.PaymentReceipt, error) <span class="cov8" title="1">{
        var paymentReceiptDTO entities.PaymentReceiptDTO
        err := r.db.WithContext(ctx).
                Where("payment_id =?", paymentID).
                First(&amp;paymentReceiptDTO).Error

        if err != nil </span><span class="cov8" title="1">{
                return domainEntities.PaymentReceipt{}, err
        }</span>

        <span class="cov8" title="1">return paymentReceiptDTO.ToDomain(), nil</span>
}

func (r *PaymentReceiptRepository) CreatePaymentReceipt(
        ctx context.Context, ent domainEntities.PaymentReceipt,
) error <span class="cov8" title="1">{
        entity := entities.FromEntity(ent)
        return r.db.WithContext(ctx).Create(&amp;entity).Error
}</span>
</pre>
		
		<pre class="file" id="file227" style="display: none">package entities

import (
        "time"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/payment_order/utils"

        "github.com/shopspring/decimal"
        "gitlab.com/clubhub.ai1/gommon/uid"
)

type RefundEntity struct {
        ID           *uid.UniqueID `gorm:"type:varchar(14);primaryKey"`
        PaymentID    string
        Amount       decimal.Decimal
        Reason       string
        Status       string
        EnterpriseID string
        CreatedAt    time.Time
}

func (r RefundEntity) TableName() string <span class="cov8" title="1">{
        return "refund"
}</span>

func (r *RefundEntity) SetStatus(status string) <span class="cov0" title="0">{
        r.Status = status
}</span>

type RefundEntityBuilder struct {
        refund    *RefundEntity
        paymentID string
        orderID   string
}

func NewRefundEntityBuilder() *RefundEntityBuilder <span class="cov8" title="1">{
        return &amp;RefundEntityBuilder{
                refund: &amp;RefundEntity{},
        }
}</span>

func (b *RefundEntityBuilder) WithPaymentID(paymentID string) *RefundEntityBuilder <span class="cov8" title="1">{
        b.paymentID = paymentID
        return b
}</span>

func (b *RefundEntityBuilder) WithOrderID(orderID string) *RefundEntityBuilder <span class="cov8" title="1">{
        b.orderID = orderID
        return b
}</span>

func (b *RefundEntityBuilder) WithAmount(amount decimal.Decimal) *RefundEntityBuilder <span class="cov8" title="1">{
        b.refund.Amount = amount
        return b
}</span>

func (b *RefundEntityBuilder) WithReason(reason string) *RefundEntityBuilder <span class="cov8" title="1">{
        b.refund.Reason = reason
        return b
}</span>

func (b *RefundEntityBuilder) WithStatus(status string) *RefundEntityBuilder <span class="cov8" title="1">{
        b.refund.Status = status
        return b
}</span>

func (b *RefundEntityBuilder) WithEnterpriseID(enterpriseID string) *RefundEntityBuilder <span class="cov8" title="1">{
        b.refund.EnterpriseID = enterpriseID
        return b
}</span>

func (b *RefundEntityBuilder) Build() *RefundEntity <span class="cov8" title="1">{
        b.refund.ID = uid.GenerateID()
        b.refund.PaymentID = utils.GeneratePaymentOrderID(b.orderID, b.paymentID)

        return b.refund
}</span>
</pre>
		
		<pre class="file" id="file228" style="display: none">package refund

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/refund/entities"
        "gorm.io/gorm"
)

type RefundReadRepository struct {
        db *gorm.DB
}

func NewRefundReadRepository(db *gorm.DB) repository.RefundReadRepositoryIF <span class="cov8" title="1">{
        return &amp;RefundReadRepository{db: db}
}</span>

func (r *RefundReadRepository) GetRefundsByReferenceOrderID(ctx context.Context, referenceOrderID, paymentID string, enterpriseID string) ([]entities.RefundEntity, error) <span class="cov8" title="1">{
        var refunds []entities.RefundEntity

        if err := r.db.
                WithContext(ctx).
                Joins(`JOIN payment ON payment.id = refund.payment_id`).
                Joins(`JOIN "order" ON "order".id = payment.order_id`).
                Where(`"order".reference_order_id = ? AND refund.payment_id = ? AND "order".enterprise_id = ?`, referenceOrderID, paymentID, enterpriseID).
                Find(&amp;refunds).Error; err != nil </span><span class="cov0" title="0">{
                return []entities.RefundEntity{}, err
        }</span>
        <span class="cov8" title="1">return refunds, nil</span>
}
</pre>
		
		<pre class="file" id="file229" style="display: none">package refund

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/refund/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/refund/entities"
        "gorm.io/gorm"
)

type RefundWriteRepositoryIF struct {
        db *gorm.DB
}

func NewRefundWriteRepository(db *gorm.DB) repository.RefundWriteRepositoryIF <span class="cov0" title="0">{
        return &amp;RefundWriteRepositoryIF{
                db: db,
        }
}</span>

func (r *RefundWriteRepositoryIF) Create(ctx context.Context, refund entities.RefundEntity) error <span class="cov0" title="0">{
        if err := r.db.WithContext(ctx).Create(&amp;refund).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *RefundWriteRepositoryIF) UpdateRefund(
        ctx context.Context, entity entities.RefundEntity,
) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Model(&amp;entity).Updates(entity).Error
}</span>
</pre>
		
		<pre class="file" id="file230" style="display: none">package entities

import (
        "reflect"
)

type UserEntity struct {
        ID             string `gorm:"type:varchar(14);primaryKey"`
        UserType       string
        ExternalUserID string
        Email          string
        Address        string
        Zip            string
        City           string
        State          string
        CountryCode    string
        Phone          string
        EnterpriseID   string
        EmailAlias     string
}

func (UserEntity) TableName() string <span class="cov8" title="1">{
        return "user"
}</span>

func (u UserEntity) IsEmpty() bool <span class="cov8" title="1">{
        return reflect.DeepEqual(UserEntity{}, u)
}</span>

func NewUserEntity(user UserEntity) UserEntity <span class="cov8" title="1">{
        return UserEntity{
                ID:             user.ID,
                UserType:       user.UserType,
                ExternalUserID: user.ExternalUserID,
                Email:          user.Email,
                Address:        user.Address,
                Zip:            user.Zip,
                City:           user.City,
                State:          user.State,
                CountryCode:    user.CountryCode,
                Phone:          user.Phone,
                EnterpriseID:   user.EnterpriseID,
                EmailAlias:     user.EmailAlias,
        }
}</span>
</pre>
		
		<pre class="file" id="file231" style="display: none">package repositories

import (
        "context"
        "errors"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/user/entities"
        "gorm.io/gorm"
)

type UserReadRepository struct {
        db *gorm.DB
}

func NewUserReadRepository(db *gorm.DB) repository.UserReadRepositoryIF <span class="cov8" title="1">{
        return &amp;UserReadRepository{
                db: db,
        }
}</span>

func (r *UserReadRepository) GetUserByID(ctx context.Context, userID, enterpriseID string) (entities.UserEntity, error) <span class="cov8" title="1">{
        var user entities.UserEntity
        err := r.db.WithContext(ctx).
                Where("id = ? AND enterprise_id = ?", userID, enterpriseID).
                First(&amp;user).Error

        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                return entities.UserEntity{}, nil
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return entities.UserEntity{}, err
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

func (r UserReadRepository) GetUserByEmail(ctx context.Context, email, enterpriseId string) (entities.UserEntity, error) <span class="cov8" title="1">{
        var user entities.UserEntity
        err := r.db.WithContext(ctx).Where("email = ? AND enterprise_id = ? ", email, enterpriseId).First(&amp;user).Error

        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                return entities.UserEntity{}, nil
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return entities.UserEntity{}, err
        }</span>

        <span class="cov8" title="1">return user, err</span>
}

func (r UserReadRepository) GetEmailByUserID(ctx context.Context, userID, enterpriseID string) (string, error) <span class="cov8" title="1">{
        var email string
        err := r.db.WithContext(ctx).
                Model(&amp;entities.UserEntity{}).
                Where("id = ? AND enterprise_id = ?", userID, enterpriseID).
                Select("email").
                First(&amp;email).Error

        return email, err
}</span>
</pre>
		
		<pre class="file" id="file232" style="display: none">package repositories

import (
        "context"

        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/user/adapters/repository"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/repositories/user/entities"
        "gorm.io/gorm"
)

type UserWriteRepository struct {
        db *gorm.DB
}

func NewUserWriteRepository(db *gorm.DB) repository.UserWriteRepositoryIF <span class="cov8" title="1">{
        return &amp;UserWriteRepository{
                db: db,
        }
}</span>

func (r UserWriteRepository) CreateUser(ctx context.Context, user entities.UserEntity) error <span class="cov8" title="1">{
        return r.db.WithContext(ctx).Create(&amp;user).Error
}</span>
</pre>
		
		<pre class="file" id="file233" style="display: none">package storage

import "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"

// CDNURLProvider is an interface for accessing the CDN URL
type CDNURLProvider interface {
        GetCDNURL() string
}

// CDNURLProviderImpl is an implementation of CDNURLProvider
type CDNURLProviderImpl struct {
        cdnURL string
}

// NewCDNURLProvider creates a new CDNURLProvider
func NewCDNURLProvider() CDNURLProvider <span class="cov0" title="0">{
        cdnURL := config.Config().Aws.CDN_URL
        return &amp;CDNURLProviderImpl{
                cdnURL: cdnURL,
        }
}</span>

// GetCDNURL returns the CDN URL
func (c *CDNURLProviderImpl) GetCDNURL() string <span class="cov0" title="0">{
        return c.cdnURL
}</pre>
		
		<pre class="file" id="file234" style="display: none">package storage

import (
        "context"
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        "io"
        "os"
        "path/filepath"

        "gitlab.com/clubhub.ai1/gommon/logger"
)

const (
        StaticFilesDir = "static_files"

        errCreateStaticDir  = "failed to create static files directory: %w"
        errCreateDirStruct  = "failed to create directory structure: %w"
        errCreateFile       = "failed to create file: %w"
        errWriteFileContent = "failed to write file content: %w"
)

type DiskStorageAdapter struct {
        baseDir string
        logger  logger.LoggerInterface
}

func NewDiskStorageAdapter(logger logger.LoggerInterface) (*DiskStorageAdapter, error) <span class="cov0" title="0">{
        if err := os.MkdirAll(StaticFilesDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf(errCreateStaticDir, err)
        }</span>

        <span class="cov0" title="0">return &amp;DiskStorageAdapter{
                baseDir: StaticFilesDir,
                logger:  logger,
        }, nil</span>
}

func (d *DiskStorageAdapter) Store(oldCtx context.Context, path string, reader io.Reader) (string, error) <span class="cov0" title="0">{
        var fileURL string
        err := decorators.TraceDecoratorNoReturn(oldCtx, "DiskAdapter.Store", func(ctx context.Context, span decorators.Span) error </span><span class="cov0" title="0">{
                fullPath := filepath.Join(d.baseDir, path)

                dir := filepath.Dir(fullPath)
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf(errCreateDirStruct, err)
                }</span>

                <span class="cov0" title="0">file, err := os.Create(fullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf(errCreateFile, err)
                }</span>
                <span class="cov0" title="0">defer file.Close()

                _, err = io.Copy(file, reader)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf(errWriteFileContent, err)
                }</span>

                <span class="cov0" title="0">absPath, err := filepath.Abs(fullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get absolute path: %w", err)
                }</span>
                <span class="cov0" title="0">fileURL = absPath

                return nil</span>
        })
        <span class="cov0" title="0">return fileURL, err</span>
}
</pre>
		
		<pre class="file" id="file235" style="display: none">package storage

// MockCDNURLProvider is a mock implementation of CDNURLProvider for testing
type MockCDNURLProvider struct {
        cdnURL string
}

// NewMockCDNURLProvider creates a new MockCDNURLProvider
func NewMockCDNURLProvider(cdnURL string) CDNURLProvider <span class="cov8" title="1">{
        return &amp;MockCDNURLProvider{
                cdnURL: cdnURL,
        }
}</span>

// GetCDNURL returns the CDN URL
func (m *MockCDNURLProvider) GetCDNURL() string <span class="cov8" title="1">{
        return m.cdnURL
}</pre>
		
		<pre class="file" id="file236" style="display: none">package storage

import "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"

type PaymentReceiptBucket struct {
        name string
}

func NewPaymentReceiptBucket() *PaymentReceiptBucket <span class="cov0" title="0">{
        bucketName := config.Config().Aws.ReceiptPaymentBucket
        return &amp;PaymentReceiptBucket{bucketName}
}</span>
</pre>
		
		<pre class="file" id="file237" style="display: none">package storage

import (
        "context"
        "fmt"
        "gitlab.com/clubhub.ai1/go-libraries/observability/apm/decorators"
        aws2 "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/infra/clients/aws"
        "io"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "gitlab.com/clubhub.ai1/gommon/logger"
)

const (
        errBucketNameNotSet = "s3 bucket name not set in configuration"
        errUploadFailed     = "failed to upload file to S3: %w"
)

type S3StorageAdapter struct {
        client         aws2.S3Client
        bucketName     string
        logger         logger.LoggerInterface
        cdnURLProvider CDNURLProvider
}

func NewS3StorageAdapter(s3Client aws2.S3Client, bucket *PaymentReceiptBucket, logger logger.LoggerInterface, cdnURLProvider CDNURLProvider) (*S3StorageAdapter, error) <span class="cov8" title="1">{
        return &amp;S3StorageAdapter{
                client:         s3Client,
                bucketName:     bucket.name,
                logger:         logger,
                cdnURLProvider: cdnURLProvider,
        }, nil
}</span>

func (s *S3StorageAdapter) Store(oldCtx context.Context, path string, reader io.Reader) (string, error) <span class="cov8" title="1">{
        var fileURL string
        err := decorators.TraceDecoratorNoReturn(oldCtx, "S3StorageAdapter.Store", func(ctx context.Context, span decorators.Span) error </span><span class="cov8" title="1">{
                _, err := s.client.PutObject(ctx, &amp;s3.PutObjectInput{
                        Bucket: aws.String(s.bucketName),
                        Key:    aws.String(path),
                        Body:   reader,
                })
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf(errUploadFailed, err)
                }</span>

                // Construct the URL using CDN URL
                <span class="cov8" title="1">fileURL = fmt.Sprintf("%s/%s", s.cdnURLProvider.GetCDNURL(), path)

                return nil</span>
        })
        <span class="cov8" title="1">return fileURL, err</span>
}
</pre>
		
		<pre class="file" id="file238" style="display: none">package storage

import (
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/config"
        "gitlab.com/clubhub.ai1/organization/backend/payments-api/internal/application/common/adapters"
)

func NewProvideStorageAdapter(s3Storage *S3StorageAdapter, diskStorage *DiskStorageAdapter) adapters.StorageAdapter <span class="cov0" title="0">{
        if config.IsLocal() </span><span class="cov0" title="0">{
                return diskStorage
        }</span>
        <span class="cov0" title="0">return s3Storage</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
